from geodesic.bases import APIObject
from geodesic.account import User
from geodesic import raise_on_error
from geodesic.service import ServiceClient

from typing import Union
from functools import lru_cache

# Projects client
projects_client = ServiceClient("krampus", 1, "projects")


@lru_cache(maxsize=None)
def _get_project(alias_or_name: str = None):
    """
    Gets a project by name or alias. It's always
    better to specify the name to avoid ambiguity.
    The alias will be used to find a project that
    the user owns, but won't check other projects
    that the alias might match

    Args:
        alias_or_name: the name or alias of the project.
    """
    res = raise_on_error(projects_client.get(alias_or_name))
    p = res.json()['project']
    if p is None:
        return None
    return Project(**p)


def get_project(alias_or_name: str = None, refresh: bool = False):
    """
    Gets a project by name or alias. It's always
    better to specify the name to avoid ambiguity.
    The alias will be used to find a project that
    the user owns, but won't check other projects
    that the alias might match

    Args:
        alias_or_name: the name or alias of the project.
        refresh: projects are cached by default. If you want the latest
            list from the server, set refresh to True
    """
    if refresh:
        _get_project.cache_clear()
    return _get_project(alias_or_name)


def get_projects():
    res = raise_on_error(projects_client.get(''))
    return [Project(**p) for p in res.json()['projects']]


class Project(APIObject):
    """
    The Project class to manage groups of nodes and datasets.

    Args:
        **project: metadata about a particular project
    """
    _limit_setitem = [
        "alias",
        "description",
        "keywords",
        "owner"
    ]

    def __init__(self, **project):
        self._client = projects_client
        for k, v in project.items():
            if k == 'name':
                self._set_item('name', v)
            else:
                setattr(self, k, v)

    def create(self) -> None:
        """
        Creates new project for this object
        """
        raise_on_error(self._client.post("", project=self))
        project = get_project(self.alias)
        self._set_item('name', project.name)
        self._set_item('owner', project.owner)

    def delete(self) -> None:
        """
        Deletes this project
        """
        raise_on_error(self._client.delete(self.name))

    def update_permission(self, user: User, permissions: dict):
        """
        Updates the read/write access for a user on this project.

        Arguments:
            user: The user to update permissions for
            permissions: a dictionary of the read/write for the user

        Example:
        >>> p.update_permission(user, {'read': True, 'write': False})

        """
        for k, v in permissions.items():
            if k not in ['read', 'write']:
                raise ValueError("can only set read or write as permissions")
            if not isinstance(v, bool):
                raise ValueError("permissions must be boolean values for read/write")
        raise_on_error(self._client.put(f'{self.name}/permission/{user.subject}', **permissions))

    def permission(self, user: User):
        """
        Gets the read/write permissions of a user on this project

        Arguments:
            user: The user to check permissions for.
        """
        res = raise_on_error(self._client.get(f'{self.name}/permission/{user.subject}'))
        return res.json()

    @property
    def name(self):
        """
        Name of the project - this is autogenerated and read only.
        """
        return self['name']

    @property
    def alias(self):
        """
        A human readable name of the project.
        """
        return self['alias']

    @alias.setter
    def alias(self, v: str):
        if not isinstance(v, str):
            raise ValueError("alias must be a string")
        self._set_item('alias', v)

    @property
    def description(self):
        """
        A short description of this project
        """
        return self['description']

    @description.setter
    def description(self, v: str):
        if not isinstance(v, str):
            raise ValueError("description must be a string")
        self._set_item('description', v)

    @property
    def owner(self):
        """
        Owner/creator of this project
        """
        return self['owner']

    @owner.setter
    def owner(self, v: str):
        if not isinstance(v, str):
            raise ValueError("owner must be a string")
        self._set_item('owner', v)

    @property
    def keywords(self):
        """
        Keywords related to this project
        """
        return list(map(str.strip, self['keywords'].split(',')))

    @keywords.setter
    def keywords(self, v: Union[list, str]):
        if isinstance(v, str):
            self._set_item('keywords', v)
            return
        elif not isinstance(v, (list, tuple)):
            raise ValueError("keywords must be a list of strings")

        self._set_item('keywords', ', '.join(v))


# Only one project can be active at one time. Certain functions (e.g. in Entanglement)
# will reference this project. This is the global project by default.
active_project = None


def set_active_project(p: Union[Project, str]) -> Project:
    """
    Sets the active project. Can either be a project name/alias or
    """
    global active_project
    if isinstance(p, Project):
        active_project = p
    else:
        active_project = get_project(p)

    return active_project


def get_active_project() -> Project:
    """
    Gets the active project. If none exists, returns a handle to the
    'global' project.
    """
    global active_project
    if active_project is None:
        set_active_project('global')
    return active_project
