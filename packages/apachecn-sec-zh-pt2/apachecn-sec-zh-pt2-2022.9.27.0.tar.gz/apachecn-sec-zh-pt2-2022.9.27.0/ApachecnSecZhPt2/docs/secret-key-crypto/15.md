# 十五、矩阵方法

本章涵盖了

*   使用整数矩阵或环元素矩阵乘法的密码
*   用大整数和小整数相乘的密码
*   求解线性同余
*   构造环和可逆矩阵

矩阵是一种非常适合加密的工具，因为它们可以在一次操作中加密任意大的文本块。通常，消息中的每个块都被视为一个字节向量，即以 256 为模的整数。

![15-unnumb-1](img/15-unnumb-1.png)

当珊卓拉使用一个矩阵来加密讯息时，丽娃必须使用这个矩阵的逆来解密讯息。让我们从矩阵求逆的技术开始矩阵方法的讨论。

## 15.1 矩阵求逆

当已知明文时，有几种方法可以求解矩阵方程，如 C = AP。由于艾米丽知道 P 和 C，但不知道 A，她可以通过右乘 P '得到 CP' = APP' = A 来解出 A 的方程。所以艾米丽需要求 P 的倒数。丽娃做的正好相反。她知道 A，但不知道 P，所以她需要对 A 求逆。将等式左乘 A '，她得到 A'C = A'AP = P 。

这里说明的方法具有直接获得逆矩阵的优点，而不需要其他方法所需的中间步骤回代。方法是将给定矩阵与单位矩阵并排放置在一个 n×2n 双宽矩阵中。仅使用*初等行运算* 将左尺寸缩减为一个单位矩阵。这些行操作应用于双矩阵的每一行，因此当左半部分从原始矩阵变为单位矩阵时，右半部分从单位矩阵变为原始矩阵的逆矩阵。

基本的行操作是(1)将一行乘以一个可逆常数，(2)交换两行，(3)从另一行中减去一行的倍数。

该算法从左上角开始，依次将原始矩阵的元素转化为单位矩阵的元素，然后从左列开始。然后对第二列进行同样的操作，依此类推。如果在任何时候算法被卡住，这意味着活动列中的所有元素都是 2 的倍数，或者都是 13 的倍数，那么矩阵是不可逆的。如果这种情况发生在 Sandra 身上，她需要尝试不同的矩阵 a。通常在最下面一行的某个元素上加 1 就足够了。如果 Emily 遇到这种情况，她将需要 n 个以上的已知明文字符。这将给她一个(n+1)×n 矩阵。当她应用这个算法时，逆矩阵在双宽矩阵的右上角 n×n 部分。

这里有一个 3×3 的例子。这个矩阵工作在 26 个字母的英文字母表 上，所以矩阵元素是模 26 的整数。没有分数，也没有负数。因为这是对 26 取模，所以不是 2 的倍数也不是 13 的倍数的每个元素都有一个乘法逆运算。这使我们可以将每一行中的第一个非零元素变成 1，这样就很容易决定从任何其他行中减去一行的哪个倍数。原始矩阵是

![15-unnumb-1-equation-15-1](img/15-unnumb-1-equation-15-1.png)

通过在右侧添加一个 3×3 的单位矩阵，这种格式被扩展为双倍宽格式。

![15-unnumb-1-equation-15-2](img/15-unnumb-1-equation-15-2.png)

你马上就有麻烦了，因为任何一行中的第一个元素都不可逆。我故意这样做是为了展示一个非常有用的技巧。第 1 行的第一个元素是 13 的倍数，但不是 2 的倍数。第 2 行的第一个元素是 2 的倍数，但不是 13 的倍数。如果你简单地把第 2 行加到第 1 行，那么第一个元素就变成了 19，它既不是 2 的倍数也不是 13 的倍数，因此它是可逆的。问题已解决。

![15-unnumb-1-equation-15-3](img/15-unnumb-1-equation-15-3.png)

19 的乘法逆是 11 模 26，因为 19×11 = 209≡1 (mod 26)。将第 1 行乘以 11，将矩阵中的第一个元素变为 1。

![15-unnumb-1-equation-15-4](img/15-unnumb-1-equation-15-4.png)

现在，你可以通过从第 2 行减去 6 倍的顶行，从第 3 行减去 10 倍的顶行来完成第 1 列。这会将第 2 行和第 3 行中的第一个元素设置为零。

![15-unnumb-1-equation-15-5](img/15-unnumb-1-equation-15-5.png)

第二排工作时间到了。第 2 行的第一个非零元素是 9。9 的乘法逆是 3，因为 9×3 = 27≡1 (mod 26)。将第 2 行乘以 3，将该行的第一个元素变为 1。

![15-unnumb-1-equation-15-6](img/15-unnumb-1-equation-15-6.png)

这使您可以通过从第 1 行减去第 2 行，并从第 3 行减去第 2 行的 25 倍来完成第 2 列。注意双宽矩阵的左侧是如何逐渐变成单位矩阵的。

![15-unnumb-1-equation-15-7](img/15-unnumb-1-equation-15-7.png)

差不多完成了。第 3 行的第一个非零值是 21。21 的乘法逆是 5，所以你把矩阵最下面一行乘以 5。

![15-unnumb-1-equation-15-8](img/15-unnumb-1-equation-15-8.png)

现在你可以从第一行减去第三行的 9 倍，从第二行减去第三行的 19 倍，从而完成第三列。

![15-unnumb-1-equation-15-9](img/15-unnumb-1-equation-15-9.png)

搞定。双宽矩阵的左半部分现在存放的是单位矩阵，右半部分是原矩阵的逆矩阵。您可以通过将原始矩阵乘以逆矩阵来检查这一点。结果应该是单位矩阵——它是。

![15-unnumb-1-equation-15-10](img/15-unnumb-1-equation-15-10.png)

## 15.2 转置矩阵

先说一个很简单的矩阵方法，即*转置矩阵* ，相当于数学上的*置换矩阵* 。这是一个正方形矩阵，每行和每列都正好有一个 1。所有其他矩阵元素都是 0。如果您希望转置一个由 10 个字母组成的块，您可以将该块视为大小为 1×10 的行矩阵，并在右侧将其乘以大小为 10×10 的转置矩阵。结果将是一个字母被转置的 1×10 矩阵。

要将一个字母从块中的位置 2 移动到位置 5，可以将第 2 行第 5 列的元素设置为 1。下面是一个 4×4 转置矩阵的示例，它将消息块 ABCD 更改为 BADC。

![15-unnumb-1-equation-15-11](img/15-unnumb-1-equation-15-11.png)

转置矩阵本身并不特别实用，但是如果你有一个矩阵 M 和一个转置矩阵 T，你可以用矩阵 MT 代替 M，将它们合并成一个步骤。这样，你就可以在一个操作中同时进行替换和转置。

## 15.3 希尔密码

最早的基于矩阵的密码是*希尔密码* ，1929 年由亨特学院的莱斯特·希尔发明，发表在*美国数学月刊*上。1924 年，当时十几岁的杰克·莱文发明了一种类似的密码，后来成为北卡罗来纳州立大学的学生，并于 1926 年发表在一份低俗侦探杂志《弗林周刊》上。弗林*的*中的加密栏目由 M. E. Ohaver 负责，他发明了分段莫尔斯(第 4.4 节)。巧合的是，*弗林的周刊*也是肯德尔·福斯特·克罗森发表他的许多故事的地方，在第 4.4 节中也有提及。莱文的整个职业生涯都在试图推翻希尔的密码，并推广自己的密码。

希尔密码对 26 个字母的字母表进行运算，这些字母以某种混乱的顺序从 0 到 25 进行编号。也就是说，在矩阵运算之前执行一个简单的替换。你把明文字母分成三组。这些形成一个列向量，即一个 3×1 的矩阵 p，你把左边的这个列向量乘以一个 3×3 的矩阵 A，然后加上一个列向量 B，得到密文向量 C，在矩阵符号中这写成 C = AP + B，使用加法和乘法模 26。最后，使用相同的字母-数字对应关系将数字转换回字母。

不幸的是，许多作者将术语*希尔密码*限定为这种密码的一个弱淡化版本。为了避免歧义，让我们给希尔密码的几种版本编号。希尔-0 是最弱的版本。你用的是标准英文字母，没有混合，省略了 B 向量，这样 C = AP。Hill-1 稍微强一点。你仍然使用非混合字母表，但是 B 向量是非零的。希尔-2 是希尔最初提出的版本。你使用混合字母和非零 B 向量。Hill3 这与 9.6.1 节中的共轭矩阵双歧 密码相当。

最初发表的希尔密码 Hill-2 基本上是一种机密方法密码。字母到数字的转换以及矩阵 A 和 B 都是固定的。没有钥匙。任何知道这个方法的人都可以像预期的接收者一样容易地阅读信息。大多数讨论希尔密码的书籍和网站都忽略了混合字母表，而只关注矩阵运算。如果使用从字母到数字的固定转换，这将是合理的，因为已知的字母混合可以被去除。

我们先来看 case Hill-0，这里 A 是一个未知的 n×n 矩阵，向量 B 是 0，所以 C = AP。这是普通的老式矩阵乘法，我们在 11.3 节看到过。丽娃可以通过将密文乘以 A 的*逆矩阵*A’来解密消息，逆矩阵具有 A’A = AA’= I 的性质，其中 I 是*单位矩阵* 。在矩阵 I 中，每一个对角元素是 1，并且每隔一个元素是 0。单位矩阵类似于普通乘法中的数字 1，也就是说，对于每个数字 N，1×N = N×1 = N。对于矩阵，这可以转化为对于每个方阵 A，IA = AI = A。如果 Emily 可以确定 A’，她也可以破译消息。

希尔密码的 B = 0 版本容易受到已知明文攻击。如果艾米丽有 n 个已知明文的 <sup class="fm-superscript">2</sup> 字符，她可以将它们组成一个 n×n 矩阵。称这个矩阵 P，称对应的密文矩阵 C，那么 C = AP，其中 C，A，P 都是 n×n 的整数模 26 的矩阵。有几种方法可以解这个矩阵方程。第 15.1.1 节给出了一种方法。

如果加性向量 B 不是全零，那么 Emily 只需要再多 n 个已知明文的字符，她就可以把 B 从方程中消去。多余的已知明文字符可以形成列向量 P <sub class="fm-subscript">2</sub> ，对应的密文字符可以形成列向量 C <sub class="fm-subscript">2</sub> 。这些向量可以这样从方程中减去:(C-C <sub class="fm-subscript">2</sub> ) = A(P-P <sub class="fm-subscript">2</sub> )。这与 C = AP 具有相同的形式，并且以相同的方式求解，即通过对矩阵 P-P <sub class="fm-subscript">2</sub> 求逆。从 n×n 矩阵中减去 n×1 列向量，方法是从矩阵顶行的每个元素中减去向量的第一个元素，从矩阵第二行的每个元素中减去向量的第二个元素，依此类推。

![15-unnumb-1-equation-15-12](img/15-unnumb-1-equation-15-12.png)

假设你没有已知的明文。还是有可能解决 Hill-0 变异的。让我们继续假设一个机密的 3×3 乘法矩阵，C = AP。乘以 A '，A 的倒数，得到 P = A'C。在消息的每个块中，块的第一个明文字符只取决于 a 的顶行，也就是说只有 26<sup class="fm-superscript">3</sup>= 17576 种可能性，所以很容易全部尝试。顶行的每个组合将确定位置 1、4、7、.。。明文中。对于每个这样的组合，计算字母的频率。

您可以使用第 5.9.1 节中描述的高峰法将这些字母频率与标准英文字母频率进行比较。取那些具有最佳匹配的组合，比如前 1%或前 175 个组合。通过使用逆矩阵 A’的第二行和第三行，对每个块的第二个和第三个明文字母进行相同的操作。这为 3 行中的每一行提供了 175 种可能的组合。现在，您可以尝试这些组合的组合，以获得整个消息的可能重构。只有 175 个 <sup class="fm-superscript">3</sup> = 5.36×10 <sup class="fm-superscript">6</sup> 组合可以尝试。第 1 行的组合给出了每个区块中的第一个字母，第 2 行的组合给出了每个区块中的第二个字母，第 3 行的组合给出了每个区块中的第三个字母，所以每个字母都有。

现在，您可以使用三元模型频率来确定最有可能的明文。使用所有三元模型，不仅仅是 3 个字母的块，还包括跨块的三元模型。这与我们在第 5.10 节和第 8.2 节中使用的过程相同，所以我不会在这里重复所有的细节。如果这不能产生一个满意的结果，回到开始，并为每个字母取前 2%或前 350 个组合。

希尔密码 Hill-1 具有一个机密的 3×3 乘法矩阵和一个机密的 3×1 加法矩阵，但是具有一个未混合的字母表，等级为 3。在矩阵运算之前和之后都有关键字混合替换的情况下，它被评定为 5。它可以作为一般的三元模型替换密码来解决。矩阵越大，等级越高。为了达到 10 的评级，矩阵必须至少为 8×8，并且必须应用两次 Hill-3 矩阵运算。以下是步骤。(1)使用键控非线性替换将消息转换为数字形式。(2)将每个块乘以矩阵，并加上列向量。(3)对数字执行第二次非线性替换。(4)将每个块乘以第二矩阵，并添加第二列向量。(5)使用第三键控非线性替换将结果转换回字母。两个乘数矩阵可以是固定的，但是用于混合字母的 3 个键和 2 个加法列向量对于每个消息应该是变化的。称这个暗号为*。*

 *## 15.4 希尔密码，计算机版本

希尔的密码太复杂了，密码员无法用手操作。希尔还发明了一种机械装置来进行加密和解密。这样做是为了满足当时的专利法，专利法允许为机器申请专利，但不允许为数学算法申请专利。然而，这种密码在实践中几乎没有用处。

今天，在计算机时代，希尔密码又变得实用了。矩阵乘法对计算机来说是小菜一碟。使用 10×10 矩阵代替 3×3 矩阵是很容易的。对于已知明文攻击，Emily 需要 100 个字符，而不是 9 个已知明文字符。这几乎是不可能的，除了通过间谍活动或在战场上捕捉信息。希尔密码使用一个使用标准字母表的机密 10×10 矩阵，被评为 6 级。希尔密码使用一个机密的 10×10 矩阵，在矩阵乘法之前和之后都有密钥混合替换，其等级为 8。

通过拥有多个矩阵并定期或随机地为每个块选择矩阵，您可以进一步增强希尔密码。矩阵和明文块的大小可以不同。由于矩阵乘法是不可交换的，当你乘以左边或右边的矩阵时，你几乎总是得到不同的结果。当你在左边乘时，每个明文块必须作为一个列向量，而当你在右边乘时，必须作为一个行向量。这表明你可以通过周期性地或随机地交替两边来得到一个更安全的密码。可变矩阵、可变块大小和可变边。你可以选择或混合他们。

您也可以将换位与希尔密码结合使用，但是，并不是每次换位都会提高安全性。假设您正在使用 Hill-0 或 Hill-1 变体，在矩阵乘法之后，您转置每个块中的字母。这与使用具有不同矩阵乘法器的希尔密码相同。设 T 代表换位。在 Hill-1 加密后应用 T 得到 C = T(AP+B) = (TA)P+(TB)。你所做的就是用矩阵 TA 代替 A，用 TB 代替 b，Emily 可以用已知的明文来解密码，她永远不会知道有一个转置。如果您希望对 Hill-0 或 Hill-1 使用换位，您必须在不同的块之间交换字母，或者您必须在不同的块中交换不同的字母。

令人惊讶的是，当您使用 Hill-2 或 Hill-3 时，情况完全相同。这是因为简单的替换和换位互换。如果 S 是任意简单替换，T 是任意转置，M 是任意消息，则 S(T(M)) = T(S(M))，因此 ST = TS。因此，无论您使用哪种希尔密码变体，如果您要添加一个换位步骤，您必须在不同的块之间交换字母，或者您必须在不同的块中交换不同的字母，周期地或伪随机地。

另一个想法是将消息乘以两边的矩阵。如前所述，当您将文本块的左边乘以一个矩阵时，它必须被视为一个列向量，而当您将它乘以右边时，它必须被视为一个行向量。假设您使用 3×3 矩阵，加法矩阵 B = 0。使用单面矩阵乘法，每个密文字符的表达式有 3 项，每项包含一个明文字母和一个矩阵元素。对于双侧矩阵乘法，每个密文字母的表达式有 9 项，每项涉及一个明文字母和 2 个矩阵元素的乘积。所以明文字母的系数是二次的。在 81 个可能的二次系数中，有 27 个出现在这些表达式中。

对于 Hill-0 和 Hill-1 情况，Emily 仍然可以使用已知的明文来求解这些方程。有简单的方法和困难的方法。困难的方法是用 18 个已知明文字符来求解两个 3×3 矩阵中 18 个未知元素的 18 个二次方程。祝你好运！

最简单的方法是将 27 个二次系数中的每一个视为一个独立的变量。这将方程从 18 个变量的二次方程变为 27 个变量的线性方程。忽略这 27 个变量是如何从 18 个矩阵元素中形成的，只需将它们视为不可分割的单元。因为现在有 27 个未知数，艾米丽需要 27 个已知字母，而不是 18 个。不太可能，但有可能，尤其是如果她已经截获了多条她知道使用了同一个密钥的消息。例如，假设 Emily 知道从瑞典发送的每条消息都以单词 STOCKHOLM 结尾。因为斯德哥尔摩的出现可能开始于 3 个字母的不同位置，3 个不同的信息可以给她 27 个已知的字母位置。她可以轻松求解 27 个线性方程组得到 27 个系数。

从那里很容易解出 27 个一次二次方程来找到 18 个矩阵元素——但是为什么要这么麻烦呢？明文字母和密文字母之间的关系都是用 27 个二次系数来表示的。艾米莉知道这些系数是如何产生的没有任何好处。

希尔-1 的情况与希尔-0 基本相同。有 36 个未知数，因此 Emily 将需要 36 个已知明文字符。否则求解过程是一样的。Hill-2 和 Hill-3 没有可比的过程。这些最好作为三元模型替换密码来解决。

通过在每一边使用不同大小的矩阵，并在每一边不同地对齐矩阵，您可以从双边矩阵乘法中获得更大的优势。这里有两个这些技术的例子。在第一个示例中，左侧乘法是 3×3 矩阵，而右侧乘法是 4×4 矩阵。由于 3×3 矩阵与 4×4 矩阵对接，如图所示，我们称之为*对接配置* 。

![15-unnumb-2](img/15-unnumb-2.png)

这给了你 12 个字符的有效块大小。因为每个右侧的 4×4 矩阵跨越两个左侧的 3×3 矩阵，所以每个密文字符依赖于 6 个明文字符，而不是 4 个。利用这种配置，产生每个密文字符只需要 7 次乘法，所以这种方法非常快。当混合字母是机密的，但是矩阵是已知的时，平头密码 被评定为 6。如果混合字母和矩阵都是机密的，则它被评定为 8。如果矩阵是 6×6 和 7×7 或更大，则等级增加到 10。当然，不管桑德拉使用的矩阵大小应该是互质的。

*砖墙* 是另一种推荐的双面矩阵乘法的配置。这里的矩阵都是同样的大小，但是它们偏移了一半的宽度，就像墙上的砖块一样。下图说明了该方法。

![15-unnumb-3](img/15-unnumb-3.png)

注意矩阵的边界从不对齐。这种配置没有块结构，换句话说，你可以说整个消息是一个块。由于每个 4×4 右侧矩阵跨越两个左侧 4×4 矩阵，所以每个密文字母依赖于 8 个明文字母。这对于高安全性的工作来说已经足够了。

如果你实际上对第一个和最后一个块使用 2×2 矩阵，这将使那些块变得脆弱和易受攻击。它还要求您拥有 1×1 和 3×3 矩阵来处理不均匀的消息长度。最好通篇使用 4×4 矩阵。接下来的两个图显示了如何为长度为 13 的消息实现这一点。第一张图显示了左侧矩阵的位置，最后一个 4×4 矩阵与消息的右端齐平。

![15-unnumb-4](img/15-unnumb-4.png)

下图显示了右侧矩阵的位置，偏移了 2 个字符。第一个和最后一个 4×4 右侧矩阵与消息的结尾齐平。

![15-unnumb-5](img/15-unnumb-5.png)

这种定位最后一个矩阵的方法使最后一个左侧矩阵和最后一个右侧矩阵对齐。这可以通过绕到消息的开头来避免，就像这样。

![15-unnumb-6](img/15-unnumb-6.png)

当你在左侧矩阵乘法之前有一个混合密钥的简单替换，在右侧矩阵乘法之后有另一个，并且你使用大小为 6×6 或更大的机密矩阵时，砖墙密码 被评定为十个。

由于对矩阵求逆需要花费一些努力，所以最好对左右乘法都使用固定矩阵。使用固定矩阵会削弱密码，但您可以通过在两个矩阵乘法步骤之间添加第三个简单的替换来进行补偿。矩阵可以是任何偶数大小，6×6 或更大。与希尔密码相比，我们称之为*珠穆朗玛密码* 。珠峰密码 T5 被评为十级。

## 15.5 大整数乘法

大整数乘法在一个重要的意义上类似于矩阵乘法:在矩阵乘法中，乘积的每个元素是两个元素乘积的和，每个元素来自一个矩阵。在大整数乘法中，乘积的每个数字是两个数字乘积的和，每个大整数一个数字。无论如何，这是我把这个主题放在矩阵章节的基本原理。

一个 128 位的块可以被看作是 16 个字节，或者是一个 128 位整数的 16 位 256 进制数字。如果您将两个这样的基数为 256 的整数相乘，则需要 256 个乘积和 256 个加法(包括进位)。如果您使用的语言允许您将两个 32 位无符号整数相乘得到一个 64 位无符号乘积，那么速度会快很多。那么你只需要 16 次乘法和 16 次加法。如果语言允许 64 位整数与 128 位乘积相乘，那就更简单了。

非常大的数有更快的乘法方法，比如 Karatsuba 和 Toom-Cook ，但是这些方法对 128 位甚至 256 位数乘法的好处太小，不值得在这里使用，所以我不打算讨论大整数乘法的机制。一些计算机语言自动处理机制，所以用户永远不需要参与。

也就是说，考虑一个密码， *Mult128* ，其中消息以 128 位的块获取，并且每个块乘以一个机密的 128 位整数 M 模 2 <sup class="fm-superscript">128</sup> 。换句话说，只使用 256 位乘积的低半阶，丢弃高半阶。这意味着乘法中的一些中间乘积不需要计算，因为它们只对乘积的高阶端有贡献。

丽娃可以通过将密文乘以 M 模 2 <sup class="fm-superscript">128</sup> 的乘法逆运算 M’来读取消息。只要 M 是奇数，这个逆就存在。让我们看看如何找到一个乘法逆。

### 15.5.1 乘除同余

我在这本书的开头承诺，如果需要的话，我会提供所有必要的数学知识。这是其中的一部分。计算乘法逆元的方法包括乘法线性同余。在我展示如何做到这一点之前，让我们看一个例子，看看为什么这是一个问题。(我在 3.6 节用了这个例子的一部分。在继续之前，您可能希望重读该部分。)

不是所有的同余都有相同的强度。有些同余是强的，并且有唯一的解。有些同余是弱，有多种解法。一致性越强，它给出的信息就越多。考虑这些一致性，从最强到最弱排列如下:

![15-unnumb-7](img/15-unnumb-7.png)

出现这种差异的原因是，除了第一个同余式 ax≡b (mod n)之外，所有同余式中的参数 a、b 和 n 都有一个公因数。在 10x≡8 (mod 12)中，参数 10，8，12 有公因式 2，同余式有 2 个解。在 9x≡3 (mod 12)中，参数 9，3，12 有公因式 3，同余式有 3 个解。诸如此类。公因子越大，解越多，同余越弱。

当 a，b，n 有一个公约数 d 时，可以把同余除以 d，例如 9x≡3 (mod 12)的公因数为 3。除以 3 得到 3x≡1(模 4)。你可以通过视觉解决这个问题。解是 x≡3 (mod 4)。因为 3×3 = 9≡1 (mod 4)，所以这是正确的。把这个结果平移回(mod 12)，第一个解是 3 (mod 12)，你把 12/3 = 4 相加，然后再加上 4，得到另外两个解，即 7 (mod 12)和 11 (mod 12)。

概括一下，如果 a、b 和 n 有一个公约数 d，那么就有 d 个不同的解。第一个解是 a/d≡b/d (mod n/d)的解，其他解间隔 n/d。

让我们看看另外两种情况。再次假设 ax≡b (mod n)且 a 和 n 有一个不除 b 的公约数，例如 3x≡7 (mod 30)。那么同余无解。而是假设 a 和 b 有一个不除 n 的公约数 d，那么你可以把 a 和 b 除以 d，比如如果 10x≡25 (mod 37)，那么 2x≡5 (mod 37)。这可以在你的头脑中通过将 37 加 5，得到 2x≡42 (mod 37)来解决。除以 2 得到 x≡21 (mod 37)。

就像你可以把 a 和 b 除以一个常数一样，你也可以把 a 和 b 乘以一个常数 m，那个 m 一定不能和 n 有公因数，换句话说，m 必须是模 n 可逆的，否则你会让同余变弱，丢失信息。比如，假设给你 9x≡3 (mod 12)。这是一个有 3 个解的弱同余。如果把 a 和 b 乘以 2，同余就变成 18x≡6 (mod 12)，相当于 6x≡6 (mod 12)，有 6 个解。弱同余变得更弱了。

你也可以加减同余，同余有相同的模数。假设 ax≡b (mod n)，cx≡d (mod n)。这些可以相加得到(a+c)x≡b+d (mod n)，或者相减得到(a-c)x≡b-d (mod n)。这可以用来加强一组弱同余。比如假设你有 9x≡3 (mod 12)和 8x≡4 (mod 12)。第一个同余式有 3 个解，第二个有 4 个解。如果将它们相加，得到 17x≡7 (mod 12)，这就减少到 5x≡7 (mod 12)，这就有了唯一解 x≡11 (mod 12)。更聪明的是，如果你减去两个同余，那就得到(9-8)x≡(3-4) (mod 12)，直接得到 x≡11 (mod 12)。

## *15.6 解一次同余

现在 你知道如何安全地操作同余而不失力，我们可以着手解决如何求解一个线性同余 ax≡b (mod m)的问题，其中 a，b 和 m 是给定的常数，x 是我们试图寻找的未知值。在 b = 1 的特殊情况下，x 是 a 模 m 的乘法逆运算，大多数教科书只提到一种叫做*扩展欧几里德算法* 的技术。(欧几里得算法通常被认为是雅典的西厄蒂特斯发明的，他生活在欧几里得算法出现前大约一个世纪。那是一个非常好的方法。当模数很小时，或者当模数有几个不同的小质因数时，这可能是正确的方法。当因子分解未知且存在小因子的可能性时，这绝对是正确的方法。

然而，在密码学中，只有两种常见的情况需要我们计算乘法逆运算，当模数是质数时，以及当模数是 2 的幂时。本节将描述一种更简单、更直接的方法。

### 15.6.1 减少同余

求解一个同余 ax≡b (mod m)的基本方法是反复降低 x 的系数，最简单的方法是 *ResM* 。它将同余式乘以一个整数 n，这个整数 n 刚好足以使 x 的系数至少与模数一样大。即 a(n-1) < m ≤ an。您可以通过除以 m/a 并向上舍入来确定 n 的值，因此 2.0000 保持为 2，但 2.0001 将变为 3。当系数以 m 为模减小时，结果是一个更小的系数。

让我们从一个简单的 ResM 例子开始，以便获得基本的想法，并且当事情开始变得复杂时，便于后面的讨论。取同余 38x≡55 (mod 101)。我们知道 101/38 = 2.658，所以我们将同余式乘以 3，然后以 101 为模进行约简，如下所示:

![15-unnumb-8](img/15-unnumb-8.png)

注意，x 的系数从 38 减少到了 13。这个可以再减。我们有 101/13 = 7.769，所以我们把同余乘以 8，就像这样:

![15-unnumb-9](img/15-unnumb-9.png)

我们就快到了。101/3 = 33.667，所以将最后一个同余乘以 34，x 系数就减少到 1:

![15-unnumb-10](img/15-unnumb-10.png)

我们可以通过把 x = 36 插回原来的同余式 38x≡55 (mod 101)来检验这个结果。把 x 换成 36，得到 38×36≡55 (mod 101)，也就是 1368≡55 (mod 101)，这是真的。正确答案是 x≡36 (mod 101)。

### 15.6.2 对半规则

让我们来看一下 的小改进。我们可以称之为*对半法则*。大约一半的时候，m/a 的小数部分小于 1/2，一半的时候大于 1/2。设 q = m/a .那么一半时间 qa 更接近 m，一半时间(q+1)a 更接近 m。

一个数字例子可能有助于使这一点更清楚。设 m 是 101，设 a 是 40。那么 q = 101/40 = 2.525。分数. 525 大于 1/2。如果取 40×2，结果是 80，比 101 少 21。如果取 40×3，结果是 120，比 101 多 19。所以 40×3 比 40×2 更接近 101。因此，n = 3 是最佳乘数。

相反，假设 a 是 41。那么 m/a = 101/41 = 2.463。这一次，分数. 463 小于 1/2。如果取 41×2，结果是 82，比 101 少 19。如果取 41×3，结果是 123，比 101 多 22。所以 41×2 比 41×3 更接近 101。因此，n = 2 是最佳乘数。

概括一下，当 q = m/a 的小数部分小于 1/2 时，如果我们将 q 向下舍入，na 更接近 m，但当 m/a 的小数部分大于 1/2 时，如果我们将 q 向上舍入，na 更接近 m。使用下限和上限符号(第 13.3 节)，如果 frac(q) < 1/2，选择 n = ⌊ q ⌋，但是如果 frac(q) > 1/2，选择 n = ⌈ q ⌉ 。这听起来很容易，但有一个复杂的问题。当 n = ⌈ q ⌉ 时，na 大于 m，所以你通过减去 m 的倍数来减少同余，就像我们在本节开始时所做的那样。当 n = ⌊ q ⌋ 时，na 小于 m，所以你通过从 m 的倍数中减去它来减少同余

从...开始

![15-unnumb-33](img/15-unnumb-33.png)

由于 101/41 = 2.463，将同余乘以 2，给出

![15-unnumb-34](img/15-unnumb-34.png)

从 101 的倍数中减去这个数，即

![15-unnumb-35](img/15-unnumb-35.png)

由于 101-82 = 19 和 202-180 = 22，你得到

![15-unnumb-36](img/15-unnumb-36.png)

为了说明这带来了多大的改进，让我们并排解决一个有和没有对半规则的同余问题。

![15-unnumb-11](img/15-unnumb-11.png)

如果没有对半原则，还原需要 8 个步骤。根据对半原则，减少需要 4 个步骤。该比率因不同的系数和模数而异，但 8:4 是合理的典型值。使用对半法则的 ResM 可以称为 *ResMH* 。

### 梯子

当 整数很大的时候，这个还是有点慢，因为我们是在做大数的乘法和除法。*阶梯技术*可以用来避免这种情况。它对每个步骤使用两个同余。阶梯技术不是将 x 的系数乘以不断增加的数来使其值接近模数，而是将每个同余中的系数乘以一个小的数来使其值接近前一个系数。这需要一个额外的同余来启动这个过程。为此，我们使用同余式 mx≡m (mod m)，它相当于 0x≡0 (mod m)。

让我们来看一个使用更大数字的例子:

![15-unnumb-12](img/15-unnumb-12.png)

由于 28338689/6114257 约为 4.635，乘以 5 再减去得到

![15-unnumb-13](img/15-unnumb-13.png)

这里 6114257/2232596 大约是 2.739，所以乘以 3 再减去得到

![15-unnumb-14](img/15-unnumb-14.png)

继续这种方式得到，先后，

![15-unnumb-15](img/15-unnumb-15.png)

这些例子中的每一个都使用了质数模。当模数为复合模数时，情况变得更加复杂。我不会在这里涵盖所有这些复杂性。对于密码学来说，最重要的情况是模数是 2 的幂，比如 2 <sup class="fm-superscript">32</sup> 或 2 <sup class="fm-superscript">128</sup> 。在这种情况下，您在每个阶段选择的乘数必须是奇数。因此，不是将乘数舍入到最接近的整数，而是总是舍入到奇数。例如，3.14 将被舍入到 3，3.99 也将被舍入到 3。使用阶梯的 ResMH 可称为 *ResMHL* 。

### 15.6.4 连分数

一旦你有了两个或更多的线性同余，你可以通过使用一种叫做*连分数*的技术来更快地减少 x 的系数。连分数是一种用分数近似十进制数的方法。考虑十进制数 R = .13579。r 介于 1/7 和 1/8 之间。更准确地说，R 约为 1/7.3643。这个也可以写成 1/7+.3643。请注意，加号+是分数的分母。这表明加法是在分母中完成的，而不是将两个分数 1/7+3643 相加。

分数. 3643 可以近似为 1/2.745，或者 1/2+.745，那么 R 现在就是 1/7+1/2+.745。这里. 745 非常接近 3/4，所以近似值可以是 1/7+1/2+3/4。要把它还原成一个普通的分数，只需倒推:

![15-unnumb-15-equation-15-17](img/15-unnumb-15-equation-15-17.png)

小数 11/81 是. 13580，与. 13579 只相差. 00001。如你所见，这种方法给出了很好的近似值。

让我们再次尝试第 15.4.3 节中的例子，

6114257 x≥90926(修改 28338689)。

对于第二个同余，我们使用 0 = 0 的技巧，

28338689 x≥28338689(修改 28338689)。

这里 6114257/28338689 是

![15-unnumb-15-equation-15-18](img/15-unnumb-15-equation-15-18.png)
T2】

获得近似的一个好的经验法则是在一个大分母之前停止，在这个例子中是 24。截断 24 之前的连分数，得到

![15-unnumb-15-equation-15-19](img/15-unnumb-15-equation-15-19.png)
T2】

算出来是 241/1117。

将 6114257 的同余乘以 1117，将 28338689 的同余乘以 241，然后相减得到

![15-unnumb-16](img/15-unnumb-16.png)

这将 x 的系数从 6114257 降低到 1020，系数为 5994。所以连分式法比其他方法用的步骤少得多。但是，使用起来很棘手，因为上一步的系数可能比下一步的系数大得多，例如 6829625069 vs 1020 。 你可以通过在连分数步和半步之间交替来平衡系数。 ******

## 15.7 大整数密码

有许多密码可以用大整数乘法来构造。第 15.3 节描述了 Mult128 密码，其中消息采用 128 位块。每个块被视为一个 128 位整数，并乘以一个机密的 128 位整数 M 模 2 <sup class="fm-superscript">128</sup> 。为了获得良好的混合，乘法器的每个字节都应该非零。这仍然是弱的，因为每个密文块的低阶 n 位仅取决于明文的低阶 n 位和密钥 m 的低阶 n 位，这使得低阶字节的加密成为简单的替换。在乘法前后进行简单的替换并不能解决这个问题。同样，低阶 2 字节进行二元模型替换，低阶 3 字节进行三元模型替换。Mult128 被评为三级。

解决低位字节问题的一种超快速方法是将高位字节与低位字节合并，例如通过使用 **xors** 或 **adds** 合并函数。这将把评级提高到五级。更好的解决方案是使用**异或**或**相加**将高位 8 字节与低位 8 字节合并。这将评级提升至 7 级。这里有一个例子。

![15-unnumb-17](img/15-unnumb-17.png)

增强密码的一种方法是置换 16 个字节，然而，利用足够的密文，Emily 可以检测出哪个字节位置具有最小的可变性，因此必须是置换的低阶字节。*置换 Mult128* 被评为四级。

一个更强的方法是相乘、置换、再相乘。置换需要将弱低阶字节移入块的高阶半部分。合适的排列是(1)颠倒字节的顺序，(2)交换块的低阶和高阶部分，或者(3)以相反的顺序交错低阶和高阶字节。如果使用十六进制数字 0 到 F 从高到低对字节进行编号，那么这 3 种排列可以表示为

![15-unnumb-18](img/15-unnumb-18.png)

如果您的编程语言允许您将块既作为 32 位字又作为单字节来操作，那么颠倒 4 个字的顺序可能会更快，从而导致这种排列:

![15-unnumb-19](img/15-unnumb-19.png)

这个密码被命名为 *MPM128* ，等级为 7。

当你在这个过程中加入替换步骤时，力量就会激增。设 S <sub class="fm-subscript">1</sub> ，S <sub class="fm-subscript">2</sub> ，S <sub class="fm-subscript">3</sub> 和 S <sub class="fm-subscript">4</sub> 为 4 个独立的混合密钥替换，设 P 为固定排列 5BF4AE39D28C1706，设 M <sub class="fm-subscript">1</sub> ，M <sub class="fm-subscript">2</sub> 和 M <sub class="fm-subscript">3</sub> 为 3 个机密 128 位整数相乘。然后暗号 S<sub class="fm-subscript">1</sub>M<sub class="fm-subscript">1</sub>PS<sub class="fm-subscript">2</sub>M<sub class="fm-subscript">2</sub>S<sub class="fm-subscript">3</sub>PM<sub class="fm-subscript">3</sub>S<sub class="fm-subscript">4</sub>，称为*老虎* ， 被评为十级。

## 15.8 小整数乘法

Mult128 的缩小版可以使用普通的无符号 32 位乘法来完成。128 位块被视为四个 32 位整数。这些整数中的每一个都乘以一个机密的 32 位整数模 2 <sup class="fm-superscript">32</sup> 。这 4 个乘数必须是奇数，以便以后解密。这就产生了一个 32 位的密码。为了得到 128 位密码，4 个独立的 4 字节乘积可以被视为一个 16 字节块，并使用这个固定的 16 字节密钥转置进行混合(第 7.6 节):

![15-unnumb-20](img/15-unnumb-20.png)

转置之后是第二个乘法步骤，再次将 16 字节块视为四个 32 位整数。您可以使用相同的乘数或新的乘数。这之后是第二次转置，以及另一轮乘法，因此有 3 轮乘法和两轮转置。这个密码被称为 Mult32 、和，等级为 7。它比任何 Mult128 密码变体都要快得多。

让我们把一个 128 位块的 16 个字节看作一个 4×4 的字节矩阵。这个矩阵的任何一行中的 4 个字节可以被视为一个 32 位整数。通常，整数的 4 个字节从左到右取，最左边的字节是高位字节。然而，它们也可以按相反的顺序取值，最左边的字节是低位字节。考虑十六进制的数 01020304。如果我们以正常方式将这个乘以十六进制数 01010101 模 2 <sup class="fm-superscript">32</sup> ，结果就是十六进制的 0A090704。如果我们以相反的顺序将 04030201 乘以十六进制数 01010101 模 2 <sup class="fm-superscript">32</sup> ，结果就是十六进制的 0A060301。

同理，我们可以把任意一列中的 4 个字节当作一个 32 位的整数，无论是从上到下的顺序还是从下到上的顺序。称两个水平方向为东和西，称两个垂直方向为北和南。如果我们按照东、北、西、南的顺序将行和列乘以奇数 32 位整数模 2 <sup class="fm-superscript">32</sup> ，这提供了彻底的混合。这需要 16 个独立的 32 位乘法器。总密钥大小是 16×31 = 496 位，而不是 16×32 = 512，因为乘数必须是奇数。这个密码可以叫做*罗盘* ，等级为八级。

要将评分提高到 10 分，请添加一轮或多轮替换，例如，东、北、替换、西、南。更好的是，添加多个替代，如东，替代，北，西，替代，南。把这种*叫做* 。即使你使用固定的替代，如果它们是高度非线性的，CompassS 被评定为 10。

使用小整数乘法的另一种方法是做*循环乘法* 。设块中每 32 位行的字节从左到右编号为 1，2，3，4，即从高位字节到低位字节。将这个乘以一个奇数模 2 <sup class="fm-superscript">32</sup> 。将字节 1 移动到低位末端，因此顺序现在是 2、3、4、1。再乘以一个奇数模 2 <sup class="fm-superscript">32</sup> 。重复这两次以上，所以每个字节占据每个位置一次。也就是说，字节的顺序是 1234、2341、3412，最后是 4123。对于总共 16 次乘法和 12 次循环移位，应该对 4×4 字节矩阵的 4 行中的每一行都这样做。

然后对列进行同样的操作。总共有 32 次乘法和 24 次循环移位。这个循环乘法密码被定为八级。它可以有多达 32 个不同的 32 位密钥乘法器。

本节中的方法可以以多种方式与第 15.4 节中的方法相结合。这里仅举一个例子，我称之为 *Mat36* 。将消息分成 36 个字符的块，这些字符被视为 9 个 32 位整数。这些形成一个 3×3 的整数模 2 矩阵 <sup class="fm-superscript">32</sup> 。这个矩阵将乘以一个机密的 3×3 整数可逆矩阵。如果您简单地在右边乘以另一个 3×3 矩阵，9 个整数的低位字节将被弱加密。相反，将整个 36 字节块向左循环 16 位，然后将右边的块乘以第二个机密的 3×3 可逆整数矩阵。Mat36 被评为八级。

## 15.9 乘法模 P

当以 2 <sup class="fm-superscript">n</sup> 为模进行乘法运算时，低阶字节被弱加密，我们需要通过跳圈来修复这个弱点。当以素数 p 为模进行乘法运算时，不会出现这个问题。对于大型乘法器，乘积的每一位都取决于明文的每一位。还有一个不同的问题。让我们假设你已经选择了一个素数 P < 2 <sup class="fm-superscript">n</sup> 和一个乘数 M，其中 1 < M < P。这可以让你安全地将 0 到 P-1 的值乘以 M 模 P，因此丽娃可以通过乘以 M’来解密这些值，M’是 M 的倒数

然而，明文值 0 将保持不变，并且从 P 到 2 <sup class="fm-superscript">n</sup> -1 的明文值不能安全地相乘，因为结果将是不明确的。例如，3 和 P+3 乘以 M 模 P 会得到相同的结果，因为 3M≡PM+3M(mod P ),所以丽娃无法判断消息是 3 还是 P+3。这意味着从 P 到 2 <sup class="fm-superscript">n</sup> -1 的值必须保持不变。为此，将函数 modp 定义如下:

![15-unnumb-21](img/15-unnumb-21.png)

这个问题的一个解决方案是 Sandra 对明文进行异或运算。这暗示了一族*模 P 密码*。让我们确定 n = 64 的值，意味着 8 字节的块大小，质数模数 P = 2<sup class="fm-superscript">64</sup>-59 = 18446744073709551557，乘数 M = 39958679596607489，也是质数。

桑德拉通过选择一个机密的 64 位常数 C <sub xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" class="fm-subscript">1</sub> 作为密钥，计算 x = modp(c<sub xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" class="fm-subscript">1</sub>t5】⊕b)+c<sub xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" class="fm-subscript">1</sub>，对一个 64 位明文块 b 进行加密。这是家族中的第一个密码。称之为 *PMod1* 。它被评定为五级。家族中的第二个密码是 pmod 2*，它是 PMod1 的两次迭代，使用第二个 64 位常量 C <sub xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" class="fm-subscript">2</sub> :*

 *![15-unnumb-22](img/15-unnumb-22.png)

PMod2 被评为七级。家族中的第三个密码， *PMod3* ，有 3 次迭代，被评定为 9:

![15-unnumb-23](img/15-unnumb-23.png)

第四个成员， *PMod4* ，额定十。它的总密钥大小为 256 位，是块大小的 4 倍:

![15-unnumb-24](img/15-unnumb-24.png)

每次加法都是以 2 <sup class="fm-superscript">n</sup> 为模，而不是以 p 为模

四种 PModX 密码都非常快，因为大多数编程语言都直接支持 64 位加法、乘法和模除。在某些计算机中，它们是单一的机器指令。这使得 PModX 密码作为一个单元处理 4 或 8 个字节，而不是像 DES 那样分别处理每个 4 位块。这类密码非常适合软件加密。PMod2 比 DES 更安全，因为它的密钥更大，PMod4 比 3DES 更安全。

有第二种乘法模 P 的方法可以消除不变的值。这个想法是把从 0 到 2 <sup class="fm-superscript">64</sup> -1 的整数范围分成两个独立的范围，每个范围有不同的质数模和不同的乘数。选择两个素数 P 和 Q，使得 P+Q = 2 <sup class="fm-superscript">64</sup> +2。大约有 1016 个这样的对，所以很容易找到，例如 P = 9228410438352162389 和 Q = 9218333635357389229，以及两个大乘法器 M < P 和 N < Q。棘手的是，你必须移动每个范围，以便你只乘以范围 1 到 P-1 或 1 到 Q-1 中的数字。通过重新定义 modp 函数可以做到这一点。

![15-unnumb-25](img/15-unnumb-25.png)

有了这个重新定义的 modp 函数，PMod1 到 PMod4 密码的工作方式和以前一样，并且具有相同的等级。该图显示了范围 0 到 2 <sup class="fm-superscript">64</sup> -1 是如何划分的。

![15-unnumb-26](img/15-unnumb-26.png)

## 15.10 基数的变更

改变数基数与乘以一个大整数密切相关。当数字非常大时，改变数字基数是一个缓慢的操作，所以最好的策略是将消息分成块，并分别转换每个块。更改基数会模糊消息字节之间的间隔。

有两种方法可以将数字从一种基数转换成另一种基数。您可以从低端工作，也可以从高端工作。许多人在学校里学习这些技巧，但是随着时间的推移，他们经常忘记这些技巧。为了唤起大家的记忆，这里展示了这两种方法。我们将使用低端技术将数字 1A87 从基数 11 转换为基数 7，然后使用高端方法转换回基数 11。

使用低端技术，你反复用新基数除这个数。每个余数都成为转换后的数字的下一位。以下是转换 1A87 的步骤:

1A87/7 是 312，余数是 4 T2。

312/7 是 49，余数是 5(T2)。

49/7 是 7 加上余数 **4** 。

7/7 是 **1** 加上余数 **0** 。

所以 11 进制的 1A87 变成 7 进制的 10454。

使用高端技术，你重复地将高端数字乘以旧基数，然后添加下一个数字。以下是转换 10454 的步骤:

**1** ×7+ **0** 是 7。

7×7+ **4** 是 49。

49×7+ **5** 是 312。

312×7+ **4** 是 1A87。

如果你觉得这些数字不太对，请记住 7、49、312 和 1A87 都是以 11 为基数的。

基于不断变化的基数，你可以做出许多简单的密码。例如，16 字节块也是以 256 为基数表示的 16 位数。将这个数字转换成另一个基数，比如 263。现在，您可以转置基数为 263 的数字，或者执行替换，或者两者都执行。然后你可以把它转换成基数 277，做同样的事情。最后，你转换回基数 256。这需要一个 17 字节的数字来保存结果。您可以使用 256 到 362 之间的任何基数。请记住，如果任何结果有一个前导数字 0，该数字是必需的，以便丽娃可以解密密文。

如果每一个连续的基数比前一个大一点，那么每一阶段都需要相同的位数。只有在最后一步将数字转换回基数 256 时，位数才会增加。没有理由要求碱基是质数。

这里有一个基于基数变化的分组密码的概念。从一个机密的混合键控简单替换开始。S 操作字节，即从 0 到 255 的整数。通过保持任何大于 255 的数字不变，s 可以扩展到大于 256 的基数。这消除了为每个可能的碱基建立单独的替换表的需要。选择 3 个数基数 B <sub class="fm-subscript">1</sub> ，B <sub class="fm-subscript">2</sub> ，B <sub class="fm-subscript">3</sub> 满足 256<B<sub class="fm-subscript">1</sub>T23】B<sub class="fm-subscript">2</sub>T24】B<sub class="fm-subscript">3</sub>T25】363。您还需要在 16 个元素上进行 3 次键控移调 T <sub class="fm-subscript">1</sub> ，T <sub class="fm-subscript">2</sub> 和 T <sub class="fm-subscript">3</sub> 。这些元素是整数，可以大到 B <sub class="fm-subscript">3</sub> -1，所以它们每个都需要超过 1 个字节。

分组密码 *3Base* 由以下步骤组成:(1)替换 S. (2)转换为 base B <sub class="fm-subscript">1</sub> 。(3)替换 S. (4)转置 T <sub class="fm-subscript">1</sub> 。(5)转换到基数 B <sub class="fm-subscript">2</sub> 。(6)替换 S. (7)转置 T <sub class="fm-subscript">2</sub> 。(8)转换到底座 B <sub class="fm-subscript">3</sub> 。(9)替换 S. (10)转置 T <sub class="fm-subscript">3</sub> 。(11)换算成基数 256。(12)替换 s。直到步骤 11，密码块由 16 个元素组成。步骤 12 将块扩展到 17 字节。密码 3Base 被定级为 10。

## *15.11 环

一个 一个*环*是整数的抽象版本。也就是说，一个环是一组元素，它们可以像整数的加法和乘法一样进行加法和乘法运算。你已经熟悉了几个环:整数、有理数、实数、整数模某个定数，也许还有复数和代数数。一些不太熟悉的环是多项式，其系数是环的成员，矩阵的元素是环的元素，a +b√13 形式的数，a +b ∛ 7+c ∛ 49 形式的数，以及 a +b√2+c√3+d√6 形式的数，其中 a、b、c 和 d 可以是整数、有理数或模某个固定整数的整数。

在我们讨论如何在密码学中使用环之前，让我们先列出环的形式规则。环加用+号 a+b 表示，环乘用并置 ab 表示。

*   对于所有的环元素 a 和 b，a +b 和 ab 都是环的元素。(关闭)

*   对于所有的环元素 a、b、c，a +(b+c) = (a +b)+c .(加法的结合律)

*   对于所有环元素 a 和 b，a +b = b +a。(加法的交换法则)

*   存在一个环元素 0 使得 0+a = a +0 = a 对于所有的环元素 a .(加性恒等式)

*   对于每个环元素 a，都有一个元素-a 使得 a +(-a) = (-a)+a = 0。(加法逆)

*   对于所有的环元素 a、b 和 c，a(bc) = (ab)c(乘法结合律)

*   对于所有的环元素 a，b，c，a(b +c) = ab +ac，(a +b)c = ac +bc。(分配规则)

*   对于每个元素 a，有一个环元素 1 使得 1a = a1 = a。(乘法恒等式)

加加法逆时通常会去掉括号，所以(-a)+b 变成-a +b，a +(-b)变成 a-b。

注意，环乘法不一定是可交换的。如果环的乘法是可换的，那么这个环叫做*可换的* 。前面所有的例子都是交换环。现在，让我们假设所有讨论中的环都是可交换的。如果一个环元素 a 有一个乘法逆 a’，使得 aa’= 1，则称 a 为*可逆*。在处理有限环时，建议尝试将所有可能的元素对相乘，以确定哪些元素是可逆的，并保留一个逆矩阵表以供快速参考。

使用环算术进行加密的一个简单方法是将 11.8 节的波纹密码与 13.14.1 节的滞后线性加法相结合。我们来选择戒指 ***R13*** ，其元素形式为*a*+*b*√13，其中 a 和 b 为十六进制数字，即整数模 16。两个十六进制数字 a 和 b 组成一个字节，代表一个字符。比如字母 X 在 ASCII 码中表示为十六进制 58，对应***R13***环元素 5+8√13 。

两个 ***R13*** 环元素*a*+*b*√13 和 *c* + *d* √13 增加为(*a*+*c*)+(*b*+*d 例如:如果 *x* = 2+3√13 和 *y* = 4+5√13 ，那么*x*+*y*就是 6+8√13 和 *xy** 就是 11+6√

对于组合的纹波+滞后线性加法密码，可以称为*滞后纹波* ，你用 ax<sub class="fm-subscript">n</sub>+bx<sub class="fm-subscript">n-I</sub>+CX<sub class="fm-subscript">n-j</sub>代替 x <sub class="fm-subscript">n</sub> ，其中系数 a、b 和 c 是环的元素，在这种情况下是***R13***明文可以分成 16 字节的块，但是对于短消息，加密可以应用于整个消息。让我们假设后者。那么加密将会是

x<sub xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" class="fm-subscript">n</sub>= ax<sub xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" class="fm-subscript">【n4t】+bx<sub xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" class="fm-subscript">n-2</sub>+CX<sub xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" class="fm-subscript">n-5</sub>表示 n = 1，2，3，-我...。，l .</sub>

这里 a 是 ***R13*** 的可逆元素，b 和 c 是 ***R13*** 的任意元素，L 是消息的长度。运算是在环中进行的。您可能认为这是第 11.8 节中的 **madd** 组合功能的变体。通常的绕回将用于加密前几个字节。

对于使用已知固定滞后的单程，滞后波动被评定为 2，因为可能的系数组合只有 256 <sup class="fm-superscript">3</sup> 。在滞后纹波阶段之前和之后进行简单的替换，额定值增加到 5。使用 3 遍，每遍具有不同的系数和不同的滞后，评级为 6。

*三重波纹* 在每次波纹传递之前和最后一次波纹传递之后，使用 3 次传递和一次机密键控简单替换。每次传递都有不同的机密系数和滞后。或者，您可以在每次传递和回绕时从消息中的不同位置开始波动。三重波纹被评为 十级。

## 15.12 环上的矩阵

在 第 15.1 节和第 15.2 节中，我们研究了希尔密码，该密码将消息的每个块视为一个整数向量，并将该向量乘以一个以 26 或 256 为模的整数矩阵。以 26 或 256 为模的整数没什么神奇的。您可以使用任何环的元素来表示消息的字符。如果字符比环形元素多，可以使用成对或三元组的环形元素，就像在波利比乌斯正方形(第 9.1 节)中使用 1 到 5 的整数对来表示 25 个字母的字母表一样。

假设你在 ***R13*** 上使用了一个矩阵，其元素具有形式*a*+*b*√13 的环。如果您将明文块视为 32 个十六进制数字而不是 16 个字节的向量，并写出矩阵乘积的每个数字的表达式，您将看到密文中的每个十六进制数字都是明文数字的线性组合。所以在***R13***环上使用 16×16 的矩阵相当于在十六进制数字上使用 32×32 的矩阵，即整数模 16。因此，这种密码仍然容易受到已知明文攻击。这种攻击至少需要 256 字节的明文。大概 16×17 = 272 字节就足够了。

你，发送者，可以通过在矩阵乘法之前和之后使用一个带密钥的简单替换来轻易地击败这样的攻击。或者，你可以构建你自己的戒指，一个除了你的合法通信者之外任何人都不知道的戒指。只要你能保守你的戒指的机密，没人能对你的矩阵 密码发动任何攻击。

## 15.13 构建一个环

一个 N 元的 环，称为*阶* N 的环，用两个 N×N 的表，它的加法表和它的乘法表来表示。构建环可以分阶段完成。让我们构建一个由 8 个元素组成的环作为演示。首先构建加法表。从一开始你就知道环必须有两个元素，0 是加性单位，1 是乘法单位。对于所有的 a，和 0+a 和 a+0 是已知的。这给了我们加法表的顶行和左列。

![15-unnumb-27](img/15-unnumb-27.png)

接下来，从第二排开始。策略是取值尚未赋值的第一个总和，给该总和赋值，然后使用关联规则对其他总和进行所有可能的推断。假设你想要 1+1 = 2，2+1 = 3，3+1 = 4，4+1 = 0。使用关联规则，您现在可以填充表格的左上部分。比如你可以确定 2+2，因为 2+2 = (1+1)+2 = 1+(1+2) = 1+3 = 4。

![15-unnumb-28](img/15-unnumb-28.png)

由于 4+1 = 0，因此 1 的加逆为 4，4 的加逆为 1。同样，2 是 3 的加法逆，3 是 2 的加法逆。那么，我们应该给 5+1 赋什么值呢？它不能是 0，因为 4 和 5 不能都是 1 的加逆。它不能是 1，因为那样的话 5 就是 0 了。它不可能是 2，因为 5+1 = 1+1 意味着 5 = 1。同样，5+1 不可能是 3 或 4。它也不可能是 5，因为 5+5 = 5 意味着 5 = 0。剩下 5+1 = 6 或 5+1 = 7。这些是等价的，所以假设 5+1 = 6。这迫使 6+1 = 7 和 7+1 = 5。也就是说 5+1+1+1 = 5。这使得 1+1+1 = 0。既然我们已经知道 1+1+1 = 3，那就意味着 3 = 0。不可能。这是个死胡同。设置 4+1 = 0 不起作用。

哪里出了问题？循环 1+1+1+1+1 = 0 有 5 项。N 阶环中任何这样的循环的长度必须能整除 N。因为 5 不能整除 8，所以不可能完成加法表。这样你就有三个选择，让周期长度变成 2，4 或 8。如果你选择循环长度为 8，那么这个环就是以 8 为模的整数。如果选择周期长度 2，则加法与异或相同。因为目标是开发一个新的环，所以周期长度为 4。加法表必须是

![15-unnumb-29](img/15-unnumb-29.png)

现在可以用分配法则算出乘法表。比如 2×2 = 2×(1+1) = 2+2 = 0。

![15-unnumb-30](img/15-unnumb-30.png)

姑且称这个戒指为**。注意，1 和 3 是环***【R8***中仅有的具有乘法逆运算的元素，并且每一个都是它自己的逆运算。**

 **有两个环值得特别一提，高斯整数和四元数。

### 15.13.1 高斯整数

*高斯整数*是 a+bi 形式的数，其中 a 和 b 是整数，I 是虚数√-1。换句话说，高斯整数是实数和虚数都是整数的复数。对于密码用途，a 和 b 可以是模 16 的整数。高斯数 a+bi 因此可以用来表示十六进制数 ab。例如，字母 X，在十六进制 ASCII 码中是 58，可以用高斯整数 5+8i 来表示。

高斯 整数相加相乘如下:

![15-unnumb-31](img/15-unnumb-31.png)

其中加法和乘法以 16 为模进行，供密码 使用。

### 15.13.2 四元数

四元数 是爱尔兰皇家天文学家、都柏林三一学院的爱尔兰数学家威廉·罗恩·汉密尔顿于 1843 年发明的，用来描述旋转物体的运动。它们是 a+bi+cj+dk 形式的数，其中 a、b、c 和 d 是普通数，I、j 和 k 是抽象单位。四元数的定义关系是 I<sup class="fm-superscript">2</sup>= j<sup class="fm-superscript">2</sup>= k<sup class="fm-superscript">2</sup>= ijk =-1。从这个关系式中，您可以推导出这些乘法规则:

![15-unnumb-32](img/15-unnumb-32.png)

四元数乘法不可交换。四元数通常被用作非交换环的*例子。*

 *四元数在物理学中广泛用于表示球面上的点和固体的旋转。通过让 a、b、c 和 d 是模 16 或模 256 的整数，它们可以适用于密码用途。这将让每个四元数代表一条消息的 2 或 4 个字符。

使用四元数的另一种方法是让系数 a、b、c 和 d 是模 2 的整数 <sup class="fm-superscript">32</sup> 。您可以使用一组混合良好的 5 位、6 位或 8 位字符代码，这样每个系数可以分别代表 6、5 或 4 个字符。因此，整个四元数将代表消息的 24、20 或 16 个字符。你可以通过一个机密的四元数乘法器左乘或右乘 M 来加密消息四元数 M。AMB 说，因为四元数乘法是不可交换的，所以左乘和右乘都要强得多。与普通乘法一样，每个分量中的低阶字节是最弱的，因此在第一次乘法后，最好将整个 16 字节块循环左移 16 位。相同的字符代码集可用于将产品转换回标准 ASCII 字符，但使用不同的代码集更有效，最好是不同大小的代码。

让我们称这个方法为 *Qmult* 。Qmult 被评为十级。为了破译这个消息，丽娃必须左乘逆四元数 A’，右乘逆四元数 B’。四元数 a+bi+cj+dk 的逆由(a-bi-CJ-dk)/(a<sup class="fm-superscript">2</sup>+b<sup class="fm-superscript">2</sup>+c<sup class="fm-superscript">2</sup>+d<sup class="fm-superscript">2</sup>)给出。由于我们是以 2 <sup class="fm-superscript">32</sup> 为模运算，所以每当 a<sup class="fm-superscript">2</sup>+b<sup class="fm-superscript">2</sup>+c<sup class="fm-superscript">2</sup>+d<sup class="fm-superscript">2</sup>为奇数时，即每当系数中的一个或三个为 奇数时，就会有一个乘法逆。

## 15.14 寻找可逆矩阵

到用一个矩阵作希尔式密码，这个矩阵必须是可逆的。可逆矩阵通常很难找到。如果环中可逆元素的个数为 I，元素的总数为 r，那么该环上的随机 n×n 矩阵可逆的概率为(i/r) *n* 。对于**环，i/r 为 2/8 = 1/4。(这与有理数或实数上的矩阵形成鲜明对比，在有理数或实数上，除了 0 之外的每个元素都有乘法逆，因此几乎每个矩阵都是可逆的。)如果矩阵很小，您通常可以通过随机选择元素，然后尝试最后一个元素的所有可能值，或者最差情况下，最后两个元素，来找到一个可逆矩阵。通过使用最后 1 或 2 个元素，您可以将矩阵缩减到最下面的两行，而不必对每个试验进行完全缩减。**

 **我选择不在本书中讨论行列式，因为我不知道它们在密码学中的任何用途，然而，对于熟悉行列式的读者来说，如果矩阵行列式的值是环中的可逆元素，那么矩阵就是可逆的。特别地，整数上的矩阵只有当它的行列式为+1 或-1 时才是可逆的。

当期望矩阵较大时，*找*一个可逆矩阵可能不可行。相反，你需要*构造*一个可逆矩阵。首先以两种特定形式之一构造一组所需大小的矩阵:三角形和块对角线。以下是四种三角矩阵的 4×4 个例子。

![15-unnumb-32-equation-15-32](img/15-unnumb-32-equation-15-32.png)

上三角矩阵只在主对角线(左上到右下)上有非零元素。所有其他条目都为零。下三角矩阵只在主对角线上或主对角线下有非零元素。所有其他条目都为零。上反三角矩阵只有在反对角线(左下到右上)上有非零元素。所有其他条目都为零。较低的反三角矩阵只有在反对角线上或下面有非零元素。所有其他条目都为零。

如果对角线上的所有元素都是可逆的，那么三角矩阵就是可逆的。一个反三角矩阵是可逆的，如果反对角线上的所有元素都是可逆的。利用 15.1.1 节的技巧，可以很容易地求出这些矩阵的逆。对于上三角和下反三角矩阵，15.1.1 节的化简过程应从右向左进行。

一个一般的可逆矩阵可以通过将这些三角形相乘来构造。这件事必须谨慎从事。两个上三角矩阵的乘积仍将是上三角，两个下三角矩阵的乘积仍将是下三角。反三角矩阵没有这个性质。一个合理的方法是为这四种三角形分别构建一个矩阵，然后形成它们的乘积。如果三角矩阵是 A，B，C 和 D，并且它们的逆是 A’，B’，C’和 D’，那么乘积 ABCD 的逆是 D’C’B’A’。

除了三角矩阵，块对角矩阵也可以用来构造可逆矩阵。这是一个 5×5 块对角矩阵的例子。该矩阵可以被称为类型 2，3，因为它由沿着 5×5 矩阵的对角线排列的 2×2 矩阵和 3×3 矩阵组成。

![15-unnumb-32-equation-15-33](img/15-unnumb-32-equation-15-33.png)

两个同类型的块对角矩阵相乘，结果是同类型的块对角矩阵。

使用块对角矩阵的好处是你可以分别找到每个块的逆矩阵。如果你沿着对角线把这些逆矩阵串起来，结果就是整个矩阵的逆矩阵。找一个 16×16 的可逆矩阵可能不可行，但是找四个 4×4 的可逆矩阵也不是太难。通过乘以其他类型的块对角矩阵，或者乘以一些可逆的三角矩阵，可以将可逆的块对角矩阵扩展为全矩阵。

全力以赴。尽可能使用最大的块来构造你的可逆块对角矩阵，并使用 4 个三角矩阵，每种一个。你最终的可逆矩阵是所有五个矩阵的乘积。 *************