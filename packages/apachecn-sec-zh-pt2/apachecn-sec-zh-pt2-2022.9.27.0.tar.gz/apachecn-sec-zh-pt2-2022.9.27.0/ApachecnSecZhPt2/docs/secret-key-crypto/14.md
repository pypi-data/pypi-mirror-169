# 十四、一次性密码本

本章涵盖

*   一次性密码本
*   近似一次性密码本的弗南密码
*   Diffie-Hellman 密钥交换
*   构建 Diffie-Hellman 和公钥密码所需的大素数

最著名的流密码 是*一次性密码本*T5。许多作者将此术语限定为仅指明文和密钥流逐字节异或的密码。这是不符合历史的。第一个一次性密码本于 1882 年由加利福尼亚州萨克拉门托的银行家弗兰克·米勒发表，目的是通过缩短 电报信息来节省资金。米勒的电报代码使用 5 位数的代码组来表示商业电报中常见的单词和短语。为了保密，米勒提出了一种密码，在每个 5 位数的组中加入一个 3 位数。他的代码值足够小，以至于总和永远不会超过 99999。也就是说，代码都小于 99000。所以一次性 pad 本来就是十进制，不是二进制。

给一次性密码本命名的系统是由德国信号情报局的密码学家沃纳·昆泽在 1922 年左右设计的。昆泽的系统是基于一个标准的外交代码的五位数组。像米勒密码一样，昆泽密码在代码组中增加了密钥组。昆泽使用 5 位数的密钥组，这些密钥组被一位数一位数地添加到代码组中，而不用进位。因此，33333+56789 将产生 89012，而不是 90122。昆泽把钥匙放在 50 张的垫子上，每张垫子包含 8 行 6 个钥匙组。这些便笺簿的页面被用于加密一条消息一次，然后被丢弃。因此得名一次性密码本。后来的发展包括使用水溶性墨水和水溶性纸进行快速处理。

另一个版本的一次性垫是由英国作家兼编剧(*偷窥狂*)利奥(Leopold Samuel)马克斯于 1940 年左右发明的。它被英国间谍广泛使用。马克斯的版本用字母代替数字。发送者将密钥字母加到模 26 的明文字母上，得到密文字母。换句话说，马克斯的一次性密码本是一个带有随机密钥的贝拉索密码。麻省理工学院教授 Claude Shannon 在 1940 年至 1945 年的某个时候发明了同样的密码，苏联信息理论家 Vladimir Kotelnikov 在 1941 年或之前发明了一个版本，但其细节仍然保密。Shannon 和 Kotelnikov 都给出了一次性密码本不能被打破的数学证明。它仍然是唯一被证明无法破解的加密方法。

由于米勒 1882 年的一次性密码本和昆泽 1922 年的一次性密码本都使用十进制加法作为它们的组合函数，并且由于马克斯 1940 年的一次性密码本使用模 26 加法，任何人断言一次性密码本仅限于使用异或来组合密钥和明文都是不合理的。一次性密码本的定义特征是

1.  密钥至少与消息一样长，

2.  密钥与真正的随机密钥无法区分，

3.  密钥的每个字符或块与明文的一个字符或相等大小的块组合，并且

4.  该密钥只使用一次。

    任何满足这四个标准的密码都是一次性密码本。然而，为了证明一次性密码本不能被破坏，需要另一个更强的条件:

5.  任何给定的明文字符转换成任何给定的密文字符的概率是相等的。

说了这么多，让我们来看看一个历史密码，它基于异或运算，与一次性密码系统密切相关。

## 14.1 弗南密码

到 1918 年 的时候，许多外交使团已经不再需要人工电报员发送和接收需要手写的信息。取而代之的是，1870 年法国电报工程师émile Baudot 发明的 5 列 Baudot 码(T5)或 1901 年新西兰记者 Donald Murray 发明的 Baudot-Murray 码(T8)。(我不会涵盖这些代码的细节，因为它们在 1870 年到 20 世纪 50 年代之间改变了几次，当时西方联合银行停止使用它们。1963 年后，当 ASCII 码取而代之时，波德风格的代码被完全抛弃。重要的特征是人工打字员将信息键入 5 列纸带上，由此信息可以直接传送并在接收端打印出来，而无需任何人工干预。

像莫尔斯电码一样，博多电码和博多-默里电码都不提供任何保密性。任何人都可以直接从磁带上读出信息。直到 1918 年，如果需要保密，信息在输入磁带之前必须由人工密码员手工加密，然后打印出来，由接收端的另一名密码员手工解密。需要一种方法来加速这一过程。进入 Vernam 。

1918 年，应陆军通信兵约瑟夫·奥·莫伯尼的要求，AT & T 贝尔实验室的吉尔贝·桑德福德·维尔南发明了维尔南密码。这个想法简单而巧妙。人类打字员会像以前一样把信息键入磁带，但传输的是字符码与键码的异或运算。键码是由一个单独的纸带提供的，纸带上印有看似随机的字符序列。在接收端，传输的字符将与破译它们的磁带拷贝进行异或运算。每盘磁带有 1000 个随机字符，因此长消息每 1000 个字符重复一次密钥。

此图显示了包含明文和密钥的两盘磁带、用于读取磁带的拾音器、用于将密钥与明文进行异或运算的电路，以及位于接收端的打孔机，该打孔机可能位于远处。根据设置，打孔机可以由打印机或发射器代替。

![14-unnumb-1](img/14-unnumb-1.png)

这是我自己的图表，因为我找不到 Vernam 机器本身的图片，大概是因为它已经被分类了。

我称这些关键磁带为“随机的”,因为它们是由一个人在打字机式键盘上敲出来的，这是 Friden Flexowriter 的前身。结果是靠近键盘中心的字符比靠近角落的字符使用得更频繁。人类不擅长产生随机数或字符。但对于 1918 年来说，这是一个非常强大的密码。

许多资料来源错误地把弗南密码称为一次性密码本，可能是因为它是第一个用二进制密钥对二进制信息进行异或运算的密码。然而，弗南密码不是一次性密码本，因为它是重复的。它有 1000 个字符的固定周期。此外，一次性密码本是米勒在 36 年前发明的，最初是基于十进制的系统。

对于一个繁忙的大使馆来说，每天可能会有 100 条或更多的密码信息。如果大使馆与其他几个大使馆通信，就需要多套磁带。用于华盛顿到柏林的磁带将与用于柏林到华盛顿交通的磁带分开。这些带子都标有 6 位数的序列号。在每条消息发出之前，磁带号会以*明文*T3】传输，即不加密。办事员需要弄清楚哪些磁带是给哪个大使馆的，哪些磁带已经用过，需要销毁。新磁带必须源源不断地提供给每个大使馆。

弗南很快设计了第二个版本，使用了两盘磁带，都与明文进行异或运算。一个磁带有 1000 个字符，另一个磁带有 999 个字符，有效周期为 999，000 个字符。同样的两盘磁带可以使用一整天，只需在每盘磁带的不同点开始每条消息。比方说，如果一个大使馆有 100 条胶带，那么只要胶带还能用，就可以在不同的日子里使用不同的胶带组合。

很容易看出 Vernam 的 2 磁带机器如何扩展到 3 或 4 磁带。据我所知，这从未发生过，因为这些基于磁带的机器很快被转子机器 所取代(见第 5.10 节)。

## 14.2 钥匙供应

一次性密码本的最大问题是提供足够的钥匙。纸带方法对于 10 个电台来说可能是足够的，每个电台每天发送 100 条信息，但是对于 100 个电台来说是不可行的，每个电台每天发送 1000 条信息。

许多关于密码学的书籍和论文描述了以下难题:桑德拉和丽娃决定使用一次性密码本交换信息。他们每个人都有一个长随机密钥的副本。他们一段一段地使用这把钥匙，直到用完为止。现在他们需要另一把随机钥匙。桑德拉可以选择它并发送给丽娃，但是它需要被加密，这样艾米丽就不能得到它。最安全的方法是使用一次一密来加密，所以他们需要另一个相同长度的密钥来加密新密钥。同样，桑德拉可以选择它并将其发送到丽娃，但该密钥也需要加密。所以他们需要另一把钥匙，无止境。

解决这一困境的方法是双管齐下的。首先，随机密钥流可以使用 13.15 节的技术进行刷新，例如滞后加法。例如，每天一次，或者每当各方决定时，可以从基础密钥中导出新的密钥。其次，这些派生的每日密钥不需要直接用作消息密钥。相反，消息密钥可以从每日密钥中构造。这样，即使 Emily 恢复了任何消息密钥，她也离恢复基本密钥还差两层。接下来的几节将描述一些产生消息密钥的方法。

每种方法被设计成满足两个目标:( 1a)该方法必须能够每天生成足够的消息密钥材料，使得没有两个消息密钥重叠，或者(1b)Emily 检测消息密钥的重叠部分一定是不可行的，以及(2)Emily 重建派生密钥或基本密钥的部分一定是不可行的。

### 14.2.1 循环密钥

使用第 13.14 节的技术导出每日密钥。每日密钥的连续部分用于生成消息密钥，例如通过轻度加密。一个简单的键控替换就足够了。我建议在连续的键之间留一个随机宽度的间隙，可能是 1 到 32 个字节。当到达每日密钥的末尾时，它使用滞后线性加法的单遍循环(第 13.14.1 节)来扩展它，以便在消息量大的日子使用。您可以通过想象每次发送一条消息时，它的键加上任何间隙都从每日键的前面移动到每日键的结尾，然后使用滞后线性加法进行刷新来形象化地描述这一点。桑德拉和丽娃必须同步进行。

当桑德拉和丽娃几乎不可能同时向对方发送消息时，这种方法非常适用于低消息量。对于更高的消息量，最好使用两个基本密钥和两个日常密钥，一个用于桑德拉到丽娃的消息，另一个用于 丽娃到桑德拉。

### 14.2.2 组合键

对于每条长度为 *L* 的消息，从每日键中取出长度为 *L* 的三段。把这几个段叫做 x，y，z，在日调 p <sub class="fm-subscript">x</sub> ，p <sub class="fm-subscript">y</sub> 和 p <sub class="fm-subscript">z</sub> 中叫它们的起始位置。如果这些位置中的任何一个接近每日键的末尾，则该段可能会折回到开头。消息密钥的每个字节通过取 x、y 和 z 中相应字节的线性组合来形成。也就是说，

![14-unnumb-1-equation-14-1](img/14-unnumb-1-equation-14-1.png)

其中系数 a、b 和 c 可以是从 1 到 255 的任何奇数。对于每个消息，三个系数 a、b 和 c 以及三个起始位置 p <sub class="fm-subscript">x</sub> ，p <sub class="fm-subscript">y</sub> 和 p <sub class="fm-subscript">z</sub> 的值必须不同。这些可以事先商定，或者加密并随每条消息一起发送。

### 14.2.3 选择键

对于长度为 L 的每个消息，从每日密钥中随机选择的位置中取出两个不重叠的片段。第一段是长度为 l 的*选择器*，s。第二段是长度为 256 的*股票* ，x。为了对消息中的第 n 个<sup xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" class="fm-superscript">字符 m <sub xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" class="fm-subscript">n</sub> 进行加密，我们首先从选择器中取出相应的字节 p = s <sub xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" class="fm-subscript">n</sub> 。这个 p 选择在股票中取关键字节的位置，即 k <sub xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" class="fm-subscript">n</sub> = x <sub xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" class="fm-subscript">p</sub> 。使用任何组合函数如**异或**或**相加**将密钥字节 k <sub xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" class="fm-subscript">n</sub> 与消息字节 m <sub xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" class="fm-subscript">n</sub> 组合。</sup>

使用密钥字节 k <sub class="fm-subscript">n</sub> 后，x <sub class="fm-subscript">p</sub> 在股票中被替换为(ax <sub class="fm-subscript">p</sub> +b) mod 256。系数 a 和 b 必须满足赫尔-多贝尔条件(13.4 节)，即 a≡1(模 4)和 b≡1(模 2)。实际上，股票 x 的 256 个位置中的每一个都成为一个独立的线性同余伪随机数发生器(PRNG )。对于股票的所有 256 个位置，系数 a 和 b 可以相同，也可以不同。一种选择是对 a 和 b 使用两对不同的值，并根据某种固定模式选择第一对或第二对。不管使用多少对值，它们对于不同的消息应该是不同的。

另一种更新股票的方案是将 x <sub class="fm-subscript">p</sub> 替换为(ax<sub class="fm-subscript">p</sub>+bx<sub class="fm-subscript">p-1</sub>)mod 256，其中 a 和 b 为 1 到 255 之间的任意奇数。您也可以选择将 x <sub class="fm-subscript">p</sub> 替换为(ax<sub class="fm-subscript">p</sub>+bx<sub class="fm-subscript">p-I</sub>)mod 256，其中 I 是 2 到 255 之间的任意整数。

由于 a 和 b 只有 8192 个可能的值，并且由于应该避免值 a = 1，所以重复是不可避免的。然而，这不是问题，只要 Emily 不能辨别每条消息使用了哪一对值。重要的一点是，Emily 不能累积她知道具有相同值 a 和 b 的多个消息。使用指示符的一个缺点是，对手可能会收集几个具有相同指示符的消息，因此他们知道那些消息具有相同的密钥。

## 14.3 指标

在经典密码学中，同一个密钥经常被使用很长时间，有时长达数月或数年。在现代，密钥通常用于单一消息。使用一次性密码本，信息键只能使用一次。否则，Emily 可以将一条消息滑动到另一条消息上，并使用重合指数(第 5.7 节)来检测重叠部分。

对于适度的双向消息流量，桑德拉和丽娃可以使用一个小本子，该本子将根据例如一天中的时间和一周中的日期来列出要使用的密钥。在计算机出现之前，通常的做法是给每条信息编号。消息号可以被加密并与消息一起发送。桑德拉和丽娃会用留言号码在书里查找答案。

当消息流量变得更高时，或者当有多方交换消息时，密钥簿变得不可用。即使这本书被一个计算机文件所取代，这一点仍然成立。解决这个问题的一个办法是使用指标。一个*指示符*是一条与消息一起发送的信息，接收者可以用它来确定密钥。

在早期，指示符只是密钥本身，隐藏在消息内部。例如，消息的第三组是密钥，或者前 8 组的第一个字符构成密钥。一个稍微复杂一点的版本可能是第二组的中间数字告诉你哪一组是关键。这类指示器的明显问题是，一旦 Emily 学会了这个系统，她就可以阅读所有的信息。即使 Emily 不知道该系统，她也可以简单地尝试消息中的所有组，看看其中是否有一个是关键。如果她找到几把这样的钥匙，也许就能推断出模式。

更安全的方法是加密密钥，并将其用作指示器。这就是德国人在第二次世界大战期间用他们的恩尼格玛机所做的。他们有一个特殊的设置，每天都在改变，用来加密消息密钥。他们首先将 Enigma 设置为每日设置，并用该设置对消息密钥加密两次。然后，他们会将机器重置为信息密钥，由操作员随机选择，并对信息进行加密。波兰人*Bomba*T5】利用这种双重加密的消息密钥来推导出那些密钥。(bomba kryptologiczna 是一种机电装置，由波兰首席密码学家 Marian Rejewski 于 1938 年设计，用于破解德国的恩尼格玛密码信息。)德国人意识到这一点，就停止了这种做法，波兰人被黑了；他们再也看不懂英格玛密码了。艾伦·图灵预见到了这个问题，并设计了他的*炸弹*来处理 cribs 或者可能的明文。法国的解谜机也被称为 bombe，据说是以 *bombe glacée* 命名的，这是一种类似圆顶形状的冷冻甜点，就像烤阿拉斯加。

第 14.2 节描述了从每日密钥生成消息密钥的几种方法。这些方法中的每一种都使用一小组参数来生成每个消息关键字，例如滞后线性加法的系数，或者每日关键字中的位置。这些参数集非常适合用作指示器。

## 14.4 Diffie-Hellman 密钥交换

所以 多为古典方法。再说一个更现代的方法。Diffie-Hellman 密钥交换系统是由斯坦福大学教授 Martin Hellman 和他的研究助理 Bailey Whitfield Diffie 于 1976 年发明的，后者后来就职于 Sun Microsystems。1974 年，当时还是加州大学伯克利分校本科生的 Ralph Merkle 发明了公开密钥加密的基本概念。

Diffie-Hellman 密钥交换的本质特征是，即使艾米丽截获了他们交换的所有消息，桑德拉和丽娃也能建立安全的加密密钥。为了建立交换，桑德拉和丽娃必须就一个大素数 P 和该素数的本原根 w 达成一致。或者，Sandra 可以简单地选择 P 和 w，并将它们发送到丽娃。p 和 w 可以明文发送。回想一下 13.3 节，找到原始根是很容易的。对于大多数素数，2、3、5 或 7 中至少有一个是本原根。

桑德拉选择了一个机密指数 s，并计算出 x = w <sup class="fm-superscript">s</sup> mod P。她将值 x 发送给丽娃，但对 s 的值保密。丽娃选择一个机密指数 r，并计算 y = w <sup class="fm-superscript">r</sup> mod P。她将值 y 发送给桑德拉，但对自己保留 r 的值。现在桑德拉可以计算 y <sup class="fm-superscript">s</sup> mod P，也就是 w <sup class="fm-superscript">rs</sup> mod P，丽娃可以计算 x <sup class="fm-superscript">r</sup> mod P，也就是 w <sup class="fm-superscript">sr</sup> mod P，由于 w <sup class="fm-superscript">rs</sup> = w <sup class="fm-superscript">sr</sup> ，桑德拉和丽娃已经计算出了相同的值，他们可以用这个值作为一个加密密钥，或者将这个值拆分成几个加密密钥。第 13.3 节描述了一种执行指数运算的有效方法。

一些作者(和维基百科)将 Diffie-Hellman 密钥交换描述为一种公钥方法。他们讨论将桑德拉和丽娃的公钥和他们的私钥结合起来。这不是真的。Diffie-Hellman 中不涉及公钥。即使你认为指数 r 和 s 是密钥，它们都是机密密钥。

假设艾米丽截获了桑德拉和丽娃之间的所有信息。那么艾米丽知道 P，w，x，y，也就是 w <sup class="fm-superscript">s</sup> mod P 和 w <sup class="fm-superscript">r</sup> mod P，但是不知道 s，r 或者 w <sup class="fm-superscript">rs</sup> mod P，确定 w <sup class="fm-superscript">rs</sup> mod P 就叫做*迪菲-赫尔曼问题*。不知道这是否与确定 r 和 s 相同，但它们被认为是同样困难的问题。确定 s 和 r，给定 P，w，以及 x 或 y 中的一个，称为*离散对数问题* 。众所周知，这是一个非常困难的问题。当 P、r 和 s 足够大时，该问题被认为在计算上是不可行的。专家们对 P 必须有多大意见不一，但普遍的建议是 300 和 600 个十进制数字。一些实现允许 P 达到 1234 个十进制数字，即 4096 位。指数 r 和 s 可以小得多。专家建议的范围从 40 位小数到 150 位小数。

一种叫做*西尔弗-波利格-海尔曼*算法的算法，对于罗兰·西尔弗、斯蒂芬·波利格和马丁·海尔曼来说，可以轻松解决 P-1 只有小因子时的离散对数问题。该算法允许您分别求解每个小因子。因此，桑德拉必须确定 P 是一个*安全的*素数，这意味着 P-1 至少有一个大因子，比如 q > 10 <sup class="fm-superscript">35</sup> 。理想情况下，桑德拉应该选择 P 为 2Q+1 形式的素数，其中 Q 也是素数。相应的质数 Q 被称为索菲·热尔曼质数，以法国数论家玛丽-索菲·热尔曼的名字命名，她也研究声学和弹性。如果 Q-1 和 Q+1 都有大的质因数，那就更强了。在下一节中，我们将显式地构造 Q，使得 Q-1 有一个大的质因数。很有可能 Q+1 也有一个很大的质因数，仅仅是偶然，只是因为 Q 太大了。只有小因子的数称为*平滑数* 。随着数量的增加，它们变得非常罕见。

### *14.4.1 构造大素数，旧

构造大素数的常规方法，你可以在很多网站上找到，从随机选择所需大小的奇数 N 开始，然后测试 N 是否是素数。首先你尝试几百个小质数。如果 N 能被其中任何一个整除，那么它就不是质数。重新选择。这个初步测试是值得的，因为它是如此之快。接下来，通过应用概率素性测试来测试 N 是否是素数。最常见的测试是加里·米勒和迈克尔·拉宾发明的*米勒-拉宾*测试。设 N-1 = 2 <sup class="fm-superscript">h</sup> d，其中 d 为奇数。也就是 2 <sup class="fm-superscript">h</sup> 是 2 的最大幂平均除以 N-1。第一步，在 2 到 N-2 的范围内选择一个基数 b，测试 b <sup class="fm-superscript">d</sup> ≡1(mod N)。如果这是真的，那么 N 通过。如果没有，那就看是 b<sup class="fm-superscript">2d</sup>≦-1(mod N)，还是 b<sup class="fm-superscript">4d</sup>≦-1(mod N)等等。只要指数 2 <sup class="fm-superscript">g</sup> d 保持小于 2 <sup class="fm-superscript">h</sup> d，就继续下去。如果你找到这样的值 g，那么 N 通过测试，b 被称为 N 的素性的*见证* 。如果没有找到这样的 g，那么你肯定知道 N 不是素的，所以你必须为 N 重新开始一个新的值

如果 N 通过，还是有 1/4 的概率 N 是复合的。如果你想把 N 不是素数的概率降低到 1/2<sup class="fm-superscript">128</sup>，你将需要 64 次米勒-拉宾测试，每次都有不同的基数 b，不幸的是，这仍然不能保证。米勒-拉宾测试错误地将卡迈克尔数识别为质数。这些数字不是质数，但每个 b 都是质数的见证。它们是由伊利诺伊大学的罗伯特卡迈克尔在 1910 年发现的。前几个卡迈克尔数字是 561，1105，1729，2465，2821，6601，8911，10585，15841，29341 和 41041。Carmichael 数倾向于具有小的素数因子，因此通过 64 次 Miller-Rabin 测试，并且还发现 N 不能被前几百个素数中的任何一个整除，使得 N 极有可能是素数。

这是一个寻找特定大小的素数的好方法，但并不能保证 N 是安全的素数，而且比本节的方法要慢很多。如果 S 是你需要的素数的大小，你需要寻找一个素数的尝试次数大约是 ln(S)。因此，对于一个 500 位数的素数，你需要大约 ln(10 个 <sup class="fm-superscript">500 个</sup>或者大约 1151 次试验，每次试验需要 64 次米勒-拉宾测试和数百次试验划分。使用我在这一节介绍的方法可以节省你几个小时甚至几个星期的计算机时间，这取决于你使用的是哪种计算机以及 等于需要多大的素数。

### 14.4.2 构造大素数，新

一种 寻找大质数的方法是从任意大整数 N 开始，然后尝试 2N+1、2N+3、2N+5、...测试每一个直到你碰到一个质数。在此基础上的一个小改进是测试 6N+1，6N+5，6N+7，6N+11，6N+13，...。这消除了测试中所有的 2 和 3 的倍数。也可以试试 30N+1，30N+7，30N+11，30N+13，...以消除 2、3 和 5 的倍数，类似地，对于 2×3×5×7 = 210，以此类推。

有多种方法可以检验一个给定的整数 N 是否是素数。最简单的方法是试除法。要测试 N 是否是素数，请尝试将 N 除以√N 以内的每个素数，如果这些素数中的任何一个能整除 N，那么 N 就是合数，否则 N 就是素数。试除法最多有用到大约 N = 10 <sup class="fm-superscript">12</sup> ，可能 10 <sup class="fm-superscript">14</sup> ，但是对于更大的 N，试除法太费时。大多数其他的质数测试仅仅是概率测试，可以告诉你这个数字是*可能是*一个质数。

有一个测试可以肯定地告诉你一个数是质数:如果一个整数 N > 1 有一个本原根，它就是质数。回想一下 13.3 节，如果 r <sup class="fm-superscript">N-1</sup> mod N = 1，r<sup class="fm-superscript">(N-1)/p</sup>mod N≦1，则 r 是 N 的本原根，对于 N-1 的任意一个素数 p。为了测试 N 的素性，你只需要计算 r <sup class="fm-superscript">x</sup> mod N 的值 x = N-1 和 x = (N-1)/p 的 N-1 的每个不同的素因子 p。姑且称这种方法为*本原根素性测试* ，或简称*根测试* 。它是由法国数学家爱德华·卢卡斯在 1876 年发明的，同样是爱德华·卢卡斯创造了术语*斐波那契数*T19】(第 3.4 节)。卢卡斯于 1891 年死于一场悲惨的汤事故。

尝试 2，3，5，7，11，13 作为可能的原始根就足够了。如果 N 有任何本原根，很可能这 6 个值中至少有一个是本原根。如果这些值都不是原始根，就不要浪费时间去尝试其他值了。将注意力转移到下一个质数候选者会更有效率。

卢卡斯的根测试的问题是你需要分解 N-1，如果 N 有 300 或更多的数字，那么分解 N-1 实际上是不可能的，至少在没有量子 T2 计算机的情况下。这也是为什么你在很多讨论素数测试的书或者网站上没有看到提到这个测试的原因。

有一种方法可以绕过这个障碍。请记住，你的目标不是找到一个测试素数的通用方法。您的目标是获得一个大素数作为 Diffie-Hellman 密钥交换的模数。因此，你可以用*构造*素数，而不是用*寻找*素数。

诀窍是选择 N-1 个已知因素。例如，您可以选择 N-1 的形式为 2 <sup class="fm-superscript">n</sup> ，因此 N 的形式为 2 <sup class="fm-superscript">n</sup> +1。N-1 的唯一质因数是 2。要找到 2 <sup class="fm-superscript">n</sup> +1 形式的素数，你只需要找到一个数 b，使得 b <sup class="fm-superscript">N-1</sup> mod N = 1，b<sup class="fm-superscript">(N-1)/2</sup>mod N≦1。建议你试试 b = 2，3，5，7，11，13。如果这些都不是本原根，那就跳过 N = 2 <sup class="fm-superscript">n</sup> +1，看看 N = 2 <sup class="fm-superscript">n+1</sup> +1 是不是素数。这一搜索将使你得到素数 3，5，17，257 和 65537。虽然人们已经花费了数千小时的计算机时间来搜索，但还不知道是否还有其他人。这 5 个素数被称为费马素数以纪念法国数学家皮耶·德·费玛，他因对等式 a<sup class="fm-superscript">n</sup>+b<sup class="fm-superscript">n</sup>= c<sup class="fm-superscript">n</sup>的旁注而闻名。

概述

在我进入细节之前，让我概述一下构造一个大素数 p 的一般方法。该方法必须完成三件事:

1.  P-1 必须有一个大的质因数，这样 P 是安全的，

2.  每个候选 P 都应该有很高的概率是质数，这样你就需要尽可能少地做质数测试，并且

3.  P-1 应该有几个不同的素数因子，以便每个素数测试尽可能快。

任何对大素数的搜索都需要测试数百甚至数千个候选者。让我们称期望的测试次数为 e。这里的方法是让 P-1 的每个候选数是两个数的乘积 cK。系数 c 将逐步通过一系列相对较小的数，通常与 e 相当。核 K 将是一个大素数，两个大素数的乘积，或者至多 2 个素数的幂的乘积，p <sup class="fm-superscript">a</sup> q <sup class="fm-superscript">b</sup> ，其中 p 和 q 中至少有一个是大素数。我们先来看看如何选择系数，然后再来看看如何选择 核。

系数

选择系数最简单的方法是一次一个地遍历素数。因为系数必须是偶数，所以每个素数用两次，2×2，2×3，2×5，2×7，...。姑且称这种方法为 *PickPrimes* 。PickPrimes 最小化 cK 中不同素数因子的数量。c 中最多有 2 个不同的素因子，k 中最多有 2 个不同的素因子。然而，PickPrimes 对减少所需的测试次数没有什么作用。

选择系数的第二种方法是使它们具有 p <sup class="fm-superscript">a</sup> q <sup class="fm-superscript">b</sup> 或 p <sup class="fm-superscript">a</sup> q <sup class="fm-superscript">b</sup> r <sup class="fm-superscript">c</sup> 或类似的形式。这里 p、q 和 r 是小素数，例如 2、3 和 5，或者 2、5 和 7。(在本节的后面，我们将看到必须省略 3 的情况。)这样，P 永远不可能是 2、3 或 5 的倍数，这就大大增加了 P 成为质数的几率。如果使用这种方法，您可能希望预先计算并排序 系数列表。

内核

核 K 至少要有一个大质因数 R，我建议 R 至少为 2 <sup class="fm-superscript">128</sup> ，约为 3.4×10 <sup class="fm-superscript">38</sup> 。如果你的对手有量子计算机，让 R 至少 2 <sup class="fm-superscript">256</sup> = 1.16×10 <sup class="fm-superscript">77</sup> 。那么，你从哪里得到这些质数呢？如果你愿意满足于 30 位数的素数，你可以从 bigprimes.org 网上得到一些。

如果你希望生成许多大素数，或者非常大的素数，你可以自己生成。提前准备，建立一个不同大小的质数表。把这个表叫做 PrimeTab 。一定要保存好 PrimeTab，这样无论何时你需要更多的灌注，你都不必重复这个过程。你可以用 100 以下的 25 个素数开始你的素数表。你可能已经记住了，所以只要把它们输入到你的程序中就可以了。接下来，如果你愿意，你可以使用试除法生成一些 3 到 12 位数的素数，比如每个位数 2 到 3 个素数。我建议你随机地这样做，这样你就不会在每次使用这种方法的时候构造相同的素数(这样每个使用这种方法的读者就不会生成相同的素数)。在这个阶段 PrimeTab 可能有大约 50 个 素数。

构造 R(小步法)

现在 让我们开始尝试构造 Q-1 的大质因数 R。你可以通过寻找每个都比上一个素数大一点的素数，一小步一小步地增加到 R，或者你可以一步到位。如果你希望生成很多大素数，那么就用小步骤构建，这样 PrimeTab 就会有很多条目供以后使用。为了说明这两种技术，让我们用小步骤构造 R，然后用大步骤构造 Q。

假设 PrimeTab 包含 k 个素数，p<sub xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" class="fm-subscript">1</sub>T34】p<sub xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" class="fm-subscript">2</sub>T35】p<sub xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" class="fm-subscript">3</sub>T36】...< p <sub xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" class="fm-subscript">k</sub> 。为了构造下一个素数，首先从表中选择任意两个素数，比如 p <sub xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" class="fm-subscript">i</sub> 和 p <sub xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" class="fm-subscript">j</sub> 。设 r 为乘积 p <sub xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" class="fm-subscript">i</sub> p <sub xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" class="fm-subscript">j</sub> 。如果 r < p <sub xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" class="fm-subscript">k</sub> ，你可能想要使用一个更大的 I 或 j，这样你就不会产生太多的小素数。当然你需要一些小素数，所以我建议在 p<sub xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" class="fm-subscript">I</sub>p<sub xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" class="fm-subscript">j</sub>T39】p<sub xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" class="fm-subscript">k</sub>T26】2/3 的时候选择一个较大的 I 或者 j。首先用 Lucas 测试看看 R = 2r+1 是不是素数。这很容易，因为你知道 R-1 仅有的质因数是 2，p <sub xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" class="fm-subscript">i</sub> 和 p <sub xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" class="fm-subscript">j</sub> 。如果 2r+1 不是素数，试试 4r+1，6r+1，10r+1，...使用 PickPrimes 方法选择系数。当数字开始超过 20 位数时，寻找一个素数可能需要对每个 素数进行 50 次或更多次的尝试。

减少测试次数

当 数字变得非常大时，在搜索本原根之前，你可以通过检查每个候选 nr+1 是否能被许多小素数整除来节省时间。例如，您可以验证 nr+1 不能被前 100 个素数中的任何一个整除。你可以通过提前计算前 100 个素数中的每一个的 x <sub class="fm-subscript">i</sub> = r mod p <sub class="fm-subscript">i</sub> 来加快测试速度。然后，不是计算(nr+1) mod p <sub class="fm-subscript">i</sub> ，其中 r 可能有几百位，而是计算(nx <sub class="fm-subscript">i</sub> +1) mod p <sub class="fm-subscript">i</sub> ，其中 x <sub class="fm-subscript">i</sub> 只有 1 到 3 位。也就是说，你只做一次试除法(r mod p <sub class="fm-subscript">i</sub> )，而不是对 n 的每个值做一次。让我们把这个方法叫做 *PrimeCheck* 。

素数检查之所以有效，是因为候选素数是按顺序选择的。你不能用寻找大素数的传统方法做到这一点，因为候选素数是随机选择的。对于这种方法来说，这使得用小素数进行试除法要快得多，而且因为它更快，你可以使用更多的小素数，比如说 300 而不是 100，从而减少所需的试凑次数。

如前所述，如果 2、3、5、7、11 或 13 中没有一个是 nr+1 的本原根，则跳过该候选项并尝试 n 的下一个值，直到找到下一个素数。由于该方法对每个候选人仅使用 6 次测试，而传统方法使用 64 次测试，因此该方法快 10 倍以上。将你找到的每个素数添加到 素数表中。

构造 P 和 Q(巨跃法)

假设 你的目标是找到一个 300 位数的苏菲·杰曼素数。继续增加素数 Tab，直到它至少有一个大素数，比如 R > 2 <sup class="fm-superscript">128</sup> 。现在你已经准备好用一个巨大的飞跃来产生你的 300 位数的质数了。首先选择所需尺寸的目标 T，比如 T = 10 <sup class="fm-superscript">300</sup> 。可以使 P 任意接近目标值，但是 Diffie-Hellman 密钥交换不需要这样。t 将仅仅是期望的最小尺寸。

下一步是求 Q，回想一下，Q 必须满足三个要求:Q 必须是素数，Q-1 必须是大素数 R 的倍数，P = 2Q+1 也必须是素数。求 Q 的策略是从某个种子数 t 开始，其质因数都是已知的，并尝试 2t+1，4t+1，6t+1，10t+1，...使用 PickPrimes。

警告如果让 t 是 3 的倍数，那么 Q 的形式就是 3x+1。这使得 P = 2Q+1 = 6x+3 是 3 的倍数。让 t 是 3 的倍数意味着 P 永远不可能是质数。

既然 T 是 P 的最小值，Q 约为 P/2，那么 T 应该约为 T/2。要构造 T，从 PrimeTab 中最大的素数，即 R 开始，取 R 的小于 T/2 的最大幂，比如说 R <sup class="fm-superscript">r</sup> 。举个例子，如果 T 是 10 <sup class="fm-superscript">300</sup> ，R 大约是 10 <sup class="fm-superscript">40</sup> ，那么 T/2 大约是 5×10 <sup class="fm-superscript">299</sup> ，那么 R 就是 7。这意味着 R <sup class="fm-superscript">r</sup> 约为 10 <sup class="fm-superscript">280</sup> 。从 10 <sup class="fm-superscript">40</sup> 直接到 10 <sup class="fm-superscript">280</sup> 是一个巨大的飞跃。这个 R <sup class="fm-superscript">r</sup> 远小于 5×10 <sup class="fm-superscript">299</sup> ，所以设置 t = R <sup class="fm-superscript">7</sup> S，这里 S 约为 5×10 <sup class="fm-superscript">19</sup> 。当 S < 10 <sup class="fm-superscript">12</sup> 时，可以用试除法求下一个大于 S 的素数，如果这是 S’，那么 t 就是 R<sup class="fm-superscript">7</sup>S’。当 S > 10 <sup class="fm-superscript">12</sup> 时，你可以使 S’成为一个来自 PrimeTab 的素数和一个你必须选择的小于 10 <sup class="fm-superscript">12</sup> 的素数的乘积，或者你可以使 S’成为一个素数的平方或立方。假设是后者。在本例中，S 约为 5×10 <sup class="fm-superscript">19</sup> 。这个的平方根大概是 7，071，067，812。下一个更高的素数是 U = 7,071,067,851。所以 t 会是 R <sup class="fm-superscript">7</sup> U <sup class="fm-superscript">2</sup> 。

现在你已经构造了 t，并且知道了它的所有质因数，你可以开始搜索 Q，测试 2t+1，4t+1，6t+1，10t+1，...使用根测试。随机选择的数 N 有大约 1/ln(N)是素数的概率。当 N 约为 10 <sup class="fm-superscript">300</sup> 时，ln(N)约为 690。这意味着要尝试 690 次才能找到 nt+1 形式的素数。P 是素数也是必要的，这也有 1/690 左右的概率。这意味着需要大约 690 次 <sup class="fm-superscript">2</sup> = 476100 次尝试才能找到 Q = nt+1 和 P = 2Q+1，这两个都是质数。那要做很多测试。

这些测试很耗时，所以任何减少测试次数的方法都是有价值的。在这种情况下，我们可以使用 PrimeCheck 的自然扩展。对于每个素数 p <sub class="fm-subscript">i</sub> ，像之前一样计算 x <sub class="fm-subscript">i</sub> = t mod p <sub class="fm-subscript">i</sub> 。对于 n 的每个值，检查 nx <sub class="fm-subscript">i</sub> +1 是否能被 p <sub class="fm-subscript">i</sub> 整除以验证 Q 不是 p <sub class="fm-subscript">i</sub> 的倍数，还要检查 2(nx <sub class="fm-subscript">i</sub> +1)即 2nx <sub class="fm-subscript">i</sub> +3 是否能被 p <sub class="fm-subscript">i</sub> 整除以验证 P 不是 p <sub class="fm-subscript">i</sub> 的倍数。这样你就从 x <sub class="fm-subscript">i</sub> 列表中得到 double 值。

机密素数

对于 有些密码你可能需要使用一个机密的质数，只有你自己和你的合法通信者知道。你仍然可以使用本节的方法来构造你的质数，但是，你需要确保任何对手都不能按照同样的步骤来发现你的质数。我推荐两个预防措施。(1)当初始化 PrimeTab 时，不是 2 或 3 个 3 到 12 位数的素数，而是随机选择 5 到 10 个 3 到 14 位数的素数。在 PrimeTab 中瞄准至少 100 个初始素数。(2)使用小步骤方法构造 P、Q 和 R，最好在最初的和素数之外使用至少 100 个附加步骤。

确切的尺寸

构造素数的大跳跃方法可以很容易地修改，以找到精确大小的素数。这里有一个例子。假设你需要一个 10 <sup class="fm-superscript">300</sup> 到 1.1×10 <sup class="fm-superscript">300</sup> 之间的素数。选择 r 略大于 10 <sup class="fm-superscript">300</sup> /2000000，即 5×10 <sup class="fm-superscript">294</sup> 。使用 PickPrimes，但是从 1000000 开始，即 1000003，1000033，1000037，1000039，...。使用 PrimeCheck 减少测试次数。

在 1，000，000 到 1，100，000 之间大约有 6700 个素数，在 10 <sup class="fm-superscript">300</sup> 到 1.1×10 <sup class="fm-superscript">300</sup> 之间的每 690 个数中大约有 1 个是素数，所以几乎可以肯定你会找到所需大小的素数。这个概率很容易计算。在期望范围内的任何给定数字不是质数的几率是 689/690。所有 6700 个被选中的数字都不是质数的几率是(689/690) <sup class="fm-superscript">6700</sup> ，或者. 00006。所以 成功 的几率是 99.994%。 ******