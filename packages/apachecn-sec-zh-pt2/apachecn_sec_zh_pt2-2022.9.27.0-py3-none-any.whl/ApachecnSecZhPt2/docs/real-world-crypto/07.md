# 七、签名和零知识证明

本章涵盖了

*   零知识证明和密码签名
*   现有的加密签名标准
*   签名的微妙行为和避免它们的陷阱

您将了解到最普遍、最强大的加密原语之一——数字签名。简而言之，数字签名类似于您所熟悉的现实生活中的签名，即您在支票和合同上书写的签名。当然，除了数字签名是加密的，因此它们比它们的笔和纸等价物提供了更多的保证。

在协议的世界里，数字签名开启了许多不同的可能性，在本书的第二部分你会一次又一次地遇到它们。在这一章中，我将介绍这个新的原语是什么，它如何在现实世界中使用，以及现代数字签名标准是什么。最后，我将谈谈安全考虑和使用数字签名的危险。

注 签名在密码学中通常被称为*数字签名*或*签名方案*。在本书中，我交替使用这些术语。

对于这一章，你需要阅读

*   第二章杂凑函数

*   第五章重点交流

*   第六章非对称加密

## 7.1 什么是签名？

我在第一章中解释过，加密签名与现实生活中的签名非常相似。因此，它们通常是最容易理解的加密原语之一:

*   只有您可以使用您的签名来签署任意消息。

*   任何人都可以在邮件上验证你的签名。

由于我们在非对称加密领域，你可能会猜到这种不对称是如何发生的。一个*签名方案*通常包含三种不同的算法:

*   一种密钥对生成算法，签名者使用它来创建新的私有和公共密钥(公共密钥可以与任何人共享)。

*   一种采用私钥和消息生成签名的签名算法。

*   采用公钥、消息和签名并返回成功或错误消息的验证算法。

有时私钥也被称为*签名密钥*，而公钥被称为*验证密钥*。有道理，对吧？我在图 7.1 中概括了这三种算法。

![](img/07_01.png)

图 7.1 数字签名界面。像其他公钥加密算法一样，您首先需要通过一个密钥生成算法生成一个密钥对，该算法采用一个安全参数和一些随机性。然后，您可以使用带有私钥的签名算法对消息进行签名，并使用带有公钥的验证算法对消息上的签名进行验证。如果您没有访问相关私钥的权限，就不能伪造验证公钥的签名。

签名有什么用？它们适用于验证消息的来源以及消息的完整性:

*   *出处*——如果上面有我的签名，那就是我写的。

*   *完整性*—如果有人修改了消息，签名就会失效。

注意 虽然这两个属性与认证相关联，但它们通常被区分为两个独立的属性:*来源认证*和*消息认证*(或完整性)。

从某种意义上来说，签名类似于你在第 3 章学到的消息认证代码(MAC)。但与 MAC 不同，它们允许我们不对称地认证消息:参与者可以在不知道私钥或签名密钥的情况下验证消息是否被篡改。接下来，我将向您展示如何在实践中使用这些算法。

运动

正如您在第 3 章中看到的，MAC 产生的认证标签必须在恒定时间内进行验证，以避免计时攻击。你认为我们需要为验证签名做同样的事情吗？

### 7.1.1 实践中如何签名和验证签名

我们来看一个实际例子。为此，我使用了 pyca/cryptography([https://cryptography . io](https://cryptography.io))，这是一个备受推崇的 Python 库。下面的清单只是生成一个密钥对，使用私钥部分对消息进行签名，然后使用公钥部分验证签名。

清单 7.1 用 Python 签署和验证签名

```
from cryptography.hazmat.primitives.asymmetric.ed25519 import (
    Ed25519PrivateKey                                              ❶
)

private_key = Ed25519PrivateKey.generate()                         ❷
public_key = private_key.public_key()                              ❷

message = b"example.com has the public key 0xab70..."              ❸
signature = private_key.sign(message)                              ❸

try:                                                               ❹
    public_key.verify(signature, message)                          ❹
    print("valid signature")                                       ❹
except InvalidSignature:                                           ❹
    print("invalid signature")                                     ❹
```

❶ 使用 Ed25519 签名算法，这是一种流行的签名方案

❷ 先生成私钥，再生成公钥

❸ 使用私钥，签署消息并获得签名

❹使用公钥，验证消息上的签名

如我之前所说，数字签名开启了现实世界中的许多用例。让我们在下一节看一个例子。

### 7.1.2 签名的一个主要用例:经认证的密钥交换

第 5 章和第 6 章介绍了两个参与者之间执行密钥交换的不同方式。在相同的章节中，您了解到这些密钥交换对于协商共享机密是有用的，共享机密可用于通过认证的加密算法保护通信。然而，密钥交换并没有完全解决在两个参与者之间建立安全连接的问题，因为一个活跃的中间人(MITM)攻击者可以扮演密钥交换的双方。这是签名进入环的地方。

假设 Alice 和 Bob 试图在他们之间建立一个安全的通信通道，并且 Bob 知道 Alice 的验证密钥。知道了这一点，Alice 就可以使用她的签名密钥来验证她在密钥交换中的身份:她生成一个密钥交换密钥对，用她的签名密钥对公钥部分进行签名，然后将密钥交换公钥与签名一起发送。Bob 可以使用他已知的相关验证密钥来验证签名是否有效，然后使用密钥交换公钥来执行密钥交换。

我们称这样的密钥交换为*认证密钥交换*。如果签名无效，Bob 可以知道有人正在积极地 MITM 密钥交换。我在图 7.2 中说明了认证密钥交换。

![](img/07_02.png)

图 7.2 第一幅图(上图)代表一个未经认证的密钥交换，对于一个活跃的 MITM 攻击者来说是不安全的，他可以通过交换他们自己的公钥来模拟交换的双方。第二张图片(底部)表示密钥交换的开始，通过 Alice 在她的公钥上的签名进行验证。由于 Bob(他知道 Alice 的验证密钥)在消息被 MITM 攻击者篡改后无法验证签名，他中止了密钥交换。

注意，在这个例子中，密钥交换只在一方被认证:虽然 Alice 不能被模仿，但是 Bob 可以。如果双方都被认证(鲍勃会签署他的密钥交换部分)，我们称这个密钥交换为*相互认证的密钥交换*。签名密钥交换可能看起来还不是非常有用。似乎我们把事先不知道 Alice 的密钥交换公钥的问题移到了事先不知道她的验证密钥的问题上。下一节将介绍认证密钥交换的实际应用，这将更有意义。

### 7.1.3 真实世界的使用:公钥基础设施

如果你假设信任是*可传递的*，签名会变得更加强大。我的意思是，如果你信任我，我信任爱丽丝，那么你也可以信任爱丽丝。她很酷。

信任的传递性允许你以极端的方式扩展系统中的信任。假设您对某个权威机构及其验证密钥有信心。此外，假设这个机构已经签署了消息，表明 Charles 的公钥是什么，David 的公钥是什么，等等。然后，你可以选择对这个映射有信心！这样的映射被称为*公钥基础设施*。例如，如果您试图与 Charles 进行密钥交换，而他声称他的公钥是一个看起来像 3848 的大数字。。。，您可以通过检查您“亲爱的”权威机构是否签署了类似“Charles 的公钥是 3848”的消息来验证这一点。。."

这个概念的一个实际应用是 *web 公钥基础设施* (web PKI)。web PKI 是您的 web 浏览器用来验证它与您每天访问的大量网站进行的密钥交换的工具。对 web PKI(如图 7.3 所示)的一个简单解释如下:当你下载一个浏览器时，它带有一些嵌入到程序中的验证密钥。这个验证密钥链接到一个权威机构，该机构的责任是签署成千上万个网站的公钥，这样你就可以在不知道这些公钥的情况下信任它们。你没有看到的是，这些网站必须向权威机构证明他们真正拥有自己的域名，然后才能获得公钥签名。(实际上，您的浏览器信任许多权威机构来完成这项工作，而不仅仅是一个。)

![](img/07_03.png)

图 7.3 在 web PKI 中，浏览器信任一个权威机构来证明一些域链接到一些公钥。当安全地访问一个网站时，您的浏览器可以通过验证权威机构的签名来验证该网站的公钥确实是他们的(而不是来自某个 MITM)。

在这一部分，你从高层次的角度了解了签名。让我们更深入地了解签名是如何工作的。但为此，我们首先需要绕道而行，看一看一种叫做零知识证明(ZKP)的东西。

## 7.2 零知识证明:签名的起源

要理解签名在密码学中是如何工作的，最好的方法就是理解它们来自哪里。出于这个原因，让我们花点时间简单介绍一下 ZKPs，然后我将回到签名。

想象一下，佩吉想要向维克多证明什么。例如，她想证明她知道某个组元素的底数的离散对数。换句话说，她想证明她知道 *x* 给定*Y*=*g*T7】x 与 *g* 某组的生成元。

![](img/07_03_UN01.png)

当然，最简单的解决方案是佩吉简单地发送值 *x* (称为*证人*)。这个解决方案将是一个简单的*知识证明*，这个也可以，除非 Peggy 不想让 Victor 知道。

注 从理论上来说，我们说这个协议产生的一个证明是*完成的*如果佩姬可以用它向维克多证明她认识证人的话。如果她不能用它来证明她所知道的，那么这个方案就没用了，对吗？

在密码学中，我们最感兴趣的是不会向验证者泄露证人的知识证明。这样的证明被称为*零知识证明* (ZKPs)。

### 7.2.1 Schnorr 识别协议:交互式零知识证明

在接下来的几页中，我将从被破坏的协议中逐步构建一个 ZKP，向你展示爱丽丝如何证明她知道 *x* 而不泄露 *x* 。

在密码学中，处理这类问题的典型方法是“隐藏”具有一定随机性的值(例如，通过加密)。但是我们做的不仅仅是隐藏:我们还想证明它就在那里。为了做到这一点，我们需要一个代数的方法来隐藏它。一个简单的解决方案是简单地给见证添加一个随机生成的值 *k* :

*s*=*k*+*x*

然后，佩吉可以将隐藏的见证人 *s* 和随机值 *k* 一起发送给维克多。此时，维克多没有理由相信佩吉确实在 *s* 中隐藏了证人。的确，如果她不知道证人 *x* ，那么 *s* 很可能只是某个随机值。维克多所知道的是，证人 *x* 隐藏在 *g* 的指数中，因为他知道*Y*=*g*<sup class="fm-superscript2">x</sup>。

为了查看佩吉是否真的认识证人，维克多可以检查她给他的信息是否与他所知道的相符，这也必须在 *g* 的指数中完成(因为证人就在这里)。换句话说，Victor 检查这两个数字是否相等:

*   *g*<sup class="fm-superscript2">s</sup>(=*g*<sup class="fm-superscript1">T8】k+*x*</sup>)

*   *Y*×*g*T5】k(=*g*<sup class="fm-superscript2">x</sup>×*g*<sup class="fm-superscript2">k</sup>=*g*<sup class="fm-superscript1">*x*+*k*</sup>)

这个想法是，只有认识证人 *x* 的人才能构建一个满足这个等式的“盲”证人 *s* 。因此，这是知识的证明。我在图 7.4 中概括了这个 ZKP 系统。

![](img/07_04.png)

图 7.4 为了向 Victor 证明她认识一个证人 *x* ，Peggy 将其隐藏(通过将其添加到一个随机值 *k* 中)并发送隐藏的证人 *s* 来代替。

没那么快。这个方案有一个问题——它显然不安全！事实上，因为隐藏证人 *x* 的等式只有一个未知数( *x* 本身)，所以维克多可以简单地反转等式来检索证人:

*x*=*s*–*k*

为了解决这个问题，佩吉可以隐藏随机值 *k* 本身！这一次，她必须将随机值隐藏在指数中(而不是将其与另一个随机值相加)，以确保维克托的方程仍然有效:

*R*=*g*T5】k

通过这种方式，Victor 不知道值 *k* (这是第 5 章中涉及的离散对数问题)，因此，无法恢复证人 *x* 。然而，他仍然有足够的信息来验证佩吉知道 *x* ！Victor 只需检查*g*<sup class="fm-superscript2">s</sup>(=*g*<sup class="fm-superscript1">*k*+*x*</sup>=*g*<sup class="fm-superscript2">k</sup>×*g*<sup class="fm-superscript2">x</sup>是否等于*Y*×*R*(=*g*我在图 7.5 中回顾了 ZKP 协议的第二次尝试。

![](img/07_05.png)

图 7.5 做一个知识证明*零知识*，证明者可以用一个随机值 *k* 隐藏见证人 *x* ，然后隐藏随机值本身。

我们的计划还有最后一个问题——佩吉可以作弊。她可以让维克多相信她认识 *x* 而不认识 *x* ！她所要做的就是颠倒她计算证明的步骤。她首先生成一个随机值 *s* ，然后根据 *s* 计算值 *R* :

*R*=*g*T5】s×*Y*<sup class="fm-superscript">–1</sup>

Victor 然后计算出*Y*×*R*=*Y*×*g*T9】s×*Y*T13】–1，确实匹配 *g* <sup class="fm-superscript2">s</sup> 。(Peggy 使用逆运算来计算值的技巧在密码学的许多攻击中都有使用。)

注 从理论上来说，我们说，如果佩姬无法欺骗(如果她不知道 *x* ，那么她就无法欺骗维克多)，那么这个方案就是“健全的”。

为了让 ZKP 协议听起来合理，Victor 必须确保 Peggy 从 *R* 计算 *s* ，而不是逆运算。为此，Victor 使协议*交互*:

1.  佩吉必须提交她的随机值 *k* ，这样她以后就不能改变它了。

2.  在得到 Peggy 的承诺后，Victor 在协议中介绍了自己的一些随意性。他生成一个随机值 *c* (称为*挑战*)并发送给佩吉。

3.  然后，佩姬可以根据随机值 *k* 和挑战 *c* 计算她的隐藏提交。

注意 你已经在第二章中学习了提交方案，我们使用了一个哈希函数来提交一个值，这个值我们以后可以公开。但是基于哈希函数的承诺方案不允许我们对隐藏值进行有趣的运算。相反，我们可以简单地将生成器提高到值， *g* <sup class="fm-superscript3">k</sup> ，我们已经在做了。

因为没有维克多的挑战 *c* 佩吉无法执行最后一步，并且维克多不会在没有看到对随机值 *k* 的承诺的情况下将挑战发送给她，佩吉被迫基于 *k* 计算 *s* 。我在图 7.6 中说明的获得的协议通常被称为作为 *Schnorr 识别协议*。

![](img/07_06.png)

图 7.6 施诺尔辨认协议是一个交互式的 ZKP，它是*完全的*(佩吉可以证明她认识某个证人)*声音的*(佩吉如果不认识证人就什么也证明不了)*零知识*(维克多对证人一无所知)。

所谓的*交互式 ZKP 系统*遵循三步模式(承诺、挑战和证明),在文献中通常被称为*适马协议*,有时也被写成σ协议(由于希腊字母的说明性形状)。但是这和数字签名有什么关系呢？

注 schn orr 鉴别协议在*诚实验证者零知识* (HVZK) *模型*中起作用:如果验证者(Victor)行为不诚实，没有随机选择挑战，他们可以了解到证人的一些情况。一些更强的 ZKP 方案是零知识的，即使验证者是恶意的。

### 7.2.2 作为非交互式零知识证明的签名

之前的交互式 ZKP 的问题是，嗯，它是*交互式*，而现实世界的协议通常不喜欢交互性。除非两个参与者同时在线，否则交互式协议增加了一些不可忽略的开销，因为它们需要几个消息(可能通过网络)并且增加了无限的延迟。由于这个原因，交互式 zkp 在应用密码术的世界中大多是缺席的。

然而，所有这些讨论并不是毫无意义的！1986 年，阿莫斯·菲亚特和阿迪·萨莫尔发表了一项技术，允许人们轻松地将交互式 ZKP 转换成非交互式 ZKP。他们引入的技巧(被称为*菲亚特-沙米尔启发式*或*菲亚特-沙米尔转换*)是让证明者自己计算挑战，以一种他们无法控制的方式。

这里有一个窍门——将挑战计算为到那时为止作为协议的一部分发送和接收的所有消息的哈希(我们称之为*抄本*)。如果我们假设哈希函数给出的输出与真正的随机数没有区别(换句话说，它看起来是随机的)，那么它可以成功地模拟验证者的角色。

Schnorr 更进了一步。他注意到哈希中可以包含任何内容！例如，如果我们在里面包含一条消息呢？我们得到的不仅仅是我们认识某个证人 *x* 的证据，而是对一条与该证据加密关联的信息的承诺。换句话说，如果证据是正确的，那么只有知道证人(成为签名密钥)的人才能提交该消息。

*那是签名！*数字签名只是非交互式的 zkp。将 Fiat-Shamir 变换应用于 Schnorr 识别协议，我们得到了 *Schnorr 签名方案*，我在图 7.7 中说明了。

![](img/07_07.png)

图 7.7 左边的协议是之前讨论过的 Schnorr 识别协议，是一个交互协议。右边的协议是 Schnorr 签名，它是左边协议的非交互式版本(其中验证者消息被对抄本上的哈希函数的调用所代替)。

概括地说，Schnorr 签名本质上是两个值， *R* 和 *s* ，其中 *R* 是对某个机密随机值的承诺(通常称为 *nonce* ，因为它需要每个签名都是唯一的)，而 *s* 是在承诺 *R* 、私钥(见证方 *x* 和消息的帮助下计算的值。接下来，让我们看看签名算法的现代标准。

## 7.3 您应该使用(或不使用)的签名算法

和密码学中的其他领域一样，数字签名有很多标准，有时候很难理解用哪一个。这就是我在这里的原因！幸运的是，签名的算法类型与密钥交换的相似:有基于算术模大数的算法，如 Diffie-Hellman (DH)和 RSA，也有基于椭圆曲线的算法，如椭圆曲线 Diffie-Hellman (ECDH)。

确保你充分理解了第五章和第六章中的算法，因为我们现在要在这些算法的基础上进行构建。有趣的是，介绍 DH 密钥交换的论文还提出了数字签名的概念(没有给出解决方案):

*为了开发一个能够用某种纯电子形式的通信来替代当前书面合同的系统，我们必须发现一种与书面签名具有相同属性的数字现象。任何人都必须很容易识别签名的真实性，但是除了合法的签名者之外，任何人都不可能出示签名。我们将把任何这样的技术称为单向认证。由于任何数字信号都可以被精确复制，一个真正的数字签名必须在不为人知的情况下被识别*。

Diffie 和 Hellman(“密码学新方向”，1976 年)

一年后(1977 年)，第一个签名算法(称为 RSA)与 RSA 非对称加密算法(在第 6 章中有所介绍)一起推出。RSA 签名是我们要学习的第一个算法。

1991 年，NIST 提出了*数字签名算法(DSA)* 作为避免 Schnorr 签名专利的尝试。由于这个原因，DSA 是 Schnorr 签名的一个怪异变体，在没有安全证明的情况下发布(尽管到目前为止还没有发现攻击)。该算法被许多人采用，但很快被一个名为 *ECDSA* (椭圆曲线数字签名算法)的椭圆曲线版本取代，正如椭圆曲线 Diffie-Hellman (ECDH)取代 Diffie-Hellman (DH)一样，这得益于它更小的密钥(见第 5 章)。ECDSA 是我将在本节中讨论的第二个签名算法。

在 Schnorr 签名的专利于 2008 年到期后，ChaCha20-Poly1305(在第 4 章中介绍)和 X25519(在第 5 章中介绍)的发明者 Daniel J. Bernstein 引入了一个新的签名方案，称为*edd sa*(Edwards-curve 数字签名算法)，基于 Schnorr 签名。自从 EdDSA 发明以来，它很快获得了广泛的应用，现在被认为是现实世界应用中数字签名的最先进技术。EdDSA 是我将在本节中讨论的第三个也是最后一个签名算法。

### 7.3.1 RSA PKCS#1 v1.5:一个糟糕的标准

RSA 签名目前到处都在使用，尽管它们不应该被使用(正如您将在本节中看到的，它们存在许多问题)。这是因为该算法是第一个被标准化的签名方案，而且现实世界的应用程序向更新更好的算法转移的速度很慢。因此，在您的旅程中，您很可能会遇到 RSA 签名，我不能不解释它们是如何工作的，以及哪些标准是被采用的。但是我想说的是，如果您理解了第 6 章中 RSA 加密的工作原理，那么这一节应该很简单，因为使用 RSA 签名与使用 RSA 加密正好相反:

*   要签名，你*用私钥(而不是公钥)加密*消息，产生一个签名(组中的随机元素)。

*   为了验证签名，你*用公钥(而不是私钥)解密*签名。如果它返回原始消息，那么签名是有效的。

注 实际上，消息在被签名之前通常被哈希，因为它将占用更少的空间(RSA 只能对小于其模数的消息进行签名)。结果也被解释为一个大数字，以便可以在数学运算中使用。

如果你的私钥是私钥指数 *d* ，公钥是公钥指数 *e* 和公钥模数 *N* ，你可以

*   通过计算签署消息*签名* = *消息*T5】dT7】modT9】N

*   通过计算*签名*<sup class="fm-superscript2">e</sup>mod*N*来验证签名，并检查它是否等于消息

我在图 7.8 中直观地说明了这一点。

![](img/07_08.png)

图 7.8 要使用 RSA 签名，我们只需执行 RSA 加密算法的逆运算:我们用私有指数对消息求幂，然后为了验证，我们用公共指数对签名求幂，公共指数返回给消息。

这是可行的，因为只有知道私有指数 *d* 的人才能在消息上生成签名。与 RSA 加密一样，安全性与因式分解问题的难度紧密相关。

使用 RSA 进行签名的标准是什么？幸运的是，它们遵循与 RSA 加密相同的模式:

*   在 PKCS#1 v1.5 文档中，用于加密的 RSA 被松散地标准化。同一文档包含了与 RSA 签名的规范(没有安全证明)。

*   RSA 随后在 PKCS#1 v2 文档中以更好的结构被再次标准化(称为 RSA-OAEP)。RSA 签名也出现了同样的情况，RSA-PSS 在同一文档中被标准化(带有安全证明)。

我在关于非对称加密的第 6 章中谈到了 RSA PKCS#1 v1.5。该文档中标准化的签名方案与加密方案非常相似。要签名，首先使用您选择的哈希函数对消息进行哈希处理，然后根据 PKCS#1 v1.5 的签名填充(类似于同一标准中的加密填充)进行填充。接下来，用您的私有指数加密填充和哈希的消息。我在图 7.9 中对此进行了说明。

![](img/07_09.png)

图 7.9 RSA PKCS#1 v1.5 签名。为了签名，哈希然后用 PKCS#1 v1.5 填充方案填充消息。最后一步是用私钥 *d* 模 *N* 对填充的哈希消息求幂。要进行验证，只需用公共指数 *e* 模 *N* 对签名求幂，并验证它是否与填充和哈希后的消息匹配。

众多 RSA

顺便说一句，不要被围绕 RSA 的不同术语所迷惑。有 RSA(*非对称加密原语*)和 RSA(*签名原语*)。除此之外，还有 RSA(该公司)，由 RSA 的发明者创立。当提到使用 RSA 加密时，大多数人会提到 RSA PKCS#1 v1.5 和 RSA-OAEP 方案。当提到使用 RSA 的签名时，大多数人会提到 RSA PKCS#1 v1.5 和 RSA-PSS 方案。

我知道这可能会令人困惑，尤其是对于 PKCS#1 v1.5 标准。虽然在 PKCS#1 v1.5 中有正式的名称来区分加密和签名算法(RSAES-PKCS1-v1_5 用于加密，RSASSA-PKCS1-v1_5 用于签名)，但我很少看到使用这些名称。

在第六章中，我提到了针对 RSA PKCS#1 v1.5 版加密的破坏性攻击；不幸的是，RSA PKCS # 1 1.5 版签名也是如此。1998 年，在 Bleichenbacher 发现 RSA PKCS#1 v1.5 对加密的毁灭性攻击后，他决定看看签名标准。Bleichenbacher 在 2006 年带着对 RSA PKCS#1 v1.5 的*签名伪造*攻击回来了，这是对签名攻击的最具灾难性的类型之一——攻击者可以在不知道私钥的情况下伪造签名！与第一次攻击直接破解加密算法不同，第二次攻击是实现攻击。这意味着如果签名方案被正确实现(根据规范)，攻击就不会成功。

一个实现缺陷听起来并不像一个算法缺陷那么糟糕，也就是说，如果它很容易避免并且不会影响很多实现的话。不幸的是，2019 年显示，令人尴尬的 RSA PKCS#1 v1.5 签名开源实现实际上落入了那个陷阱，并错误地实现了标准(参见 Chau 等人的“用符号执行分析语义正确性:关于 PKCS#1 v1.5 签名验证的案例研究”)。各种实现缺陷最终导致了 Bleichenbacher 伪造攻击的不同变体。

不幸的是，用于签名的 RSA PKCS#1 v1.5 仍然被广泛使用。如果出于向后兼容的原因，你真的*不得不*使用这个算法，请注意这些问题。话虽如此，但这并不意味着用于签名的 RSA 是不安全的。故事并没有到此结束。

### 7.3.2 RSA-PSS:更好的标准

RSA-PSS 在更新的 PKCS#1 v2.1 中被标准化，并包含了一个安全证明(不同于以前的 PKCS#1 v1.5 中标准化的签名方案)。新的规范是这样工作的:

*   使用 PSS 编码算法对消息进行编码

*   使用 RSA 对编码的消息进行签名(如 PKCS#1 v1.5 标准中所做的)

PSS 编码稍微复杂一些，并且类似于 OAEP(最佳非对称加密填充)。我在图 7.10 中对此进行了说明。

![](img/07_10.png)

图 7.10 RSA-PSS 签名方案使用掩码生成函数(MGF)对消息进行编码，就像你在第 6 章中学习的 RSA-OAEP 算法一样，然后以通常的 RSA 方式进行签名。

验证 RSA-PSS 生成的签名只是在签名被提升到公共指数模公共模数时反转编码的问题。

PSS 的可证明安全性

PSS(用于*概率签名方案*)是可证明安全的，这意味着没有人能够在不知道私钥的情况下伪造签名。RSA-PSS 不是证明如果 RSA 是安全的，那么 RSA-PSS 是安全的，而是证明了逆命题:如果有人能破解 RSA-PSS，那么有人也能破解 RSA。这是密码学中常用的证明方法。当然，这只有在 RSA 是安全的情况下才有效，这是我们在证明中假设的。

如果你还记得的话，我在第六章中还谈到了 RSA 加密的第三种算法(称为 RSA-KEM)，这是一种更简单的算法，没有人使用过，但也被证明是安全的。有趣的是，RSA for signatures 也反映了 RSA 加密历史的这一部分，并且有一个几乎没人使用的简单得多的算法；它叫做*全域名哈希* (FDH)。FDH 的工作方式是简单地哈希一条消息，然后使用 RSA 对其签名(将摘要解释为一个数字)。

尽管 RSA-PSS 和 FDH 都有安全证明并且更容易正确实现，但今天大多数协议仍然使用 RSA PKCS#1 v1.5 进行签名。这只是另一个通常发生在不认可的加密算法周围的缓慢的例子。因为旧的实现仍然必须与新的实现一起工作，所以很难移除或替换算法。想想不更新应用程序的用户、不提供新版本软件的供应商、无法更新的硬件设备等等。接下来，我们来看一个更现代的算法。

### 7.3.3 椭圆曲线数字签名算法(ECDSA)

在这一节中，我们来看看 ECDSA，它是 DSA 的一种椭圆曲线变体，其发明目的只是为了规避 Schnorr 签名中的专利。许多标准中都规定了签名方案，包括 NIST 的 FIPS 186-2、ISO 14888-3、ANSI X9.62、IEEE P1363 等等。并非所有的标准都兼容，希望互操作的应用程序必须确保它们使用相同的标准。

不幸的是，和 DSA 一样，ECDSA 没有安全证明，而 Schnorr 签名有。尽管如此，ECDSA 已经被广泛采用，并且是最常用的签名方案之一。在这一节中，我将解释 ECDSA 如何工作以及如何使用它。与所有此类方案一样，公钥几乎总是根据相同的公式生成:

*   私钥是随机生成的一个大数 *x* 。

*   公钥是将 *x* 作为一个生成器(椭圆曲线密码学中称为*基点*)创建的一个组中的一个索引来获得的。

更具体地说，在 ECDSA 中，使用[*x**G*计算公钥，这是标量 *x* 与基点 *G* 的标量乘法。

加法还是乘法记数法？

注意，我使用了*加法符号*(在标量周围放置括号的椭圆曲线语法)，但是如果我想使用*乘法符号*，我可以编写*public _ key*=*G*<sup class="fm-superscript3">x</sup>。这些差异在实践中无关紧要。大多数情况下，不关心群的基本性质的密码协议是使用乘法符号编写的，而专门在基于椭圆曲线的群中定义的协议倾向于使用加法符号编写。

为了计算 ECDSA 签名，您需要与 Schnorr 签名相同的输入:您正在签名的消息的哈希( *H* ( *m* ))、您的私钥 *x* ，以及每个签名唯一的随机数 *k* 。ECDSA 签名是两个整数， *r* 和 *s* ，计算如下:

*   *r* 是*k**G*的 x 坐标

*   *s* 等于*k*t1(*h*(*m*)+*xr【T12 })】*

为了验证 ECDSA 签名，验证者需要使用相同的哈希消息 *H* ( *m* )、签名者的公钥以及签名值 *r* 和 *s* 。然后验证者

1.  计算[*H*(*m*)*s*<sup class="fm-superscript">–1</sup>*G*+[*RS*<sup class="fm-superscript">–1</sup>]*public _ key*

2.  验证获得的点的 x 坐标与签名的值 *r* 相同

你肯定能听出和 Schnorr 签名有一些相似之处。随机数 *k* 有时被称为*随机数*，因为它是一个只能使用一次的数字，有时也被称为*临时密钥*，因为它必须保密。

警告我再重申一遍: *k* 决不能重复，也不可预测！如果没有这些，恢复私钥是很容易的。

一般来说，加密库在幕后执行这个 nonce 的生成(即 *k* 值),但有时他们不这样做，而是让调用者提供它。当然，这是一个灾难的处方。例如，在 2010 年，索尼的 Playstation 3 被发现使用带有重复 nonces 的 ECDSA(这泄露了他们的私钥)。

警告更微妙的是，如果 nonce *k* 不是均匀随机选取的(具体来说，如果你能预测前几位)，仍然存在强大的攻击，可以在短时间内恢复私钥(所谓的*格攻击*)。理论上，我们称这种密钥检索攻击为*完全破解*(因为它们破解一切！).这种完全中断在实践中非常罕见，这使得 ECDSA 成为一种可能以惊人的方式失败的算法。

存在避免随机数问题的尝试。例如，RFC 6979 规定了一种*确定性 ECDSA* 方案，即基于消息和私钥生成随机数。这意味着对相同的消息签名两次涉及相同的 nonce 两次，因此产生相同的签名两次(这显然不是问题)。

【ECDSA 中使用的椭圆曲线与椭圆曲线 Diffie-Hellman (ECDH)算法(见第 5 章)中流行的曲线非常相似，只有一个明显的例外: *Secp256k1* 。Secp256k1 曲线在 SEC 2:“推荐的椭圆曲线域参数”(【https://secg.org/sec2-v2.pdf】)中定义，由高效密码组标准(SECG)编写。由于对我在第五章提到的 NIST 曲线缺乏信任，比特币决定使用它而不是更流行的 NIST 曲线后，它获得了很大的吸引力。

Secp256k1 是一种椭圆曲线，被称为 *Koblitz 曲线*。Koblitz 曲线只是一条椭圆曲线，其参数中有一些约束，允许实现优化曲线上的一些操作。椭圆曲线具有以下等式:

*和*<sup class="fm-superscript">【2】</sup>=*<sup class="fm-superscript">【3】</sup>+*【ax】*+*【b】**

 *其中 *a* = 0、 *b* = 7 为常数， *x* 和 *y* 定义在以素数 *p* 为模的数上:

*p*= 2<sup class="fm-superscript">192</sup>–2<sup class="fm-superscript">32</sup>–2<sup class="fm-superscript">12</sup>–2<sup class="fm-superscript">8</sup>–2<sup class="fm-superscript">7</sup>–2<sup class="fm-superscript">6</sup>–2<sup class="fm-superscript">3</sup>–1

这定义了一组素数阶，就像 NIST 曲线一样。今天，我们有有效的公式来计算椭圆曲线上的点数。以下是素数，即 Secp256k1 曲线中的点数(包括无穷远点):

【例】19554 . 868686866667

我们用坐标的定点 *G* 作为生成器(或基点)

*x*= 5506626302227734366957871889516853432625064175500187360389116729240

和

y= 326705100207588169780830851305070431844712732759337482424。

尽管如此，今天 ECDSA 主要用于 NIST 曲线 P-256(有时也称为*secp 256 r 1*；注意区别)。接下来让我们看看另一个广泛流行的签名方案。

### 7.3.4 爱德华兹曲线数字签名算法(EdDSA)

我来介绍一下本章最后一个签名算法， *Edwards-curve 数字签名算法* (EdDSA)，由 Daniel J. Bernstein 于 2011 年发表，旨在回应政府机构创造的 NIST 和其他曲线缺乏信任的问题。EdDSA 这个名字似乎表明它是像 ECDSA 一样基于 DSA 算法，但这是骗人的。EdDSA 实际上是基于 Schnorr 签名的，这是可能的，因为 Schnorr 签名的专利在 2008 年初就到期了。

EdDSA 的一个特点是，该方案不要求每次签名操作都有新的随机性。EdDSA 确定性地产生签名*。这使得该算法非常有吸引力，并且已经被许多协议和标准采用。*

 *EdDSA 有望被纳入 NIST 即将发布的 FIPS 186-5 标准更新版本(截至 2021 年初仍为草案)。当前的官方标准是 RFC 8032，它定义了两条不同安全级别的曲线，用于 EdDSA。两个定义的曲线都是*扭曲的爱德华兹曲线*(一种能够实现有趣的实施优化的椭圆曲线):

*   *Edwards25519 基于丹尼尔·j·伯恩斯坦(Daniel J. Bernstein)的 Curve25519(已在第五章中介绍)。*它的曲线运算比 Curve25519 实现得更快，这要归功于椭圆曲线类型实现的优化。由于它是在 Curve25519 之后发明的，基于 Curve25519 的密钥交换 X25519 并没有从这些速度改进中受益。与 Curve25519 一样，Edwards25519 提供 128 位安全性。

*   *Edwards448 是基于迈克·汉堡的 Ed448-Goldilocks 曲线。*它提供 224 位安全。

在实践中，EdDSA 大多用 Edwards25519 曲线实例化，组合被称为 *Ed25519* (而带有 Edwards448 的 EdDSA 被简称为 Ed448)。使用 EdDSA 的密钥生成与其他现有方案略有不同。EdDSA 不是直接生成一个签名密钥，而是生成一个机密密钥，然后用它来导出实际的签名密钥和另一个密钥，我们称之为 nonce 密钥。那个临时密钥很重要！它用于确定性地生成所需的每个签名随机数。

注意 根据您使用的加密库，您可能会存储机密密钥或两个派生密钥:签名密钥和临时密钥。这并不重要，但是如果您不知道这一点，那么如果您遇到 Ed25519 密钥被存储为 32 字节或 64 字节(取决于所使用的实现),您可能会感到困惑。

为了签名，EdDSA 首先通过将 nonce 密钥与要签名的消息哈希来确定性地生成 nonce。此后，类似于 Schnorr 签名的过程如下:

1.  将随机数计算为*哈希* ( *随机数密钥* || *消息*)

2.  将承诺 *R* 计算为[*nonce*】*G*，其中 *G* 是组的基点

3.  将挑战计算为*哈希* ( *承诺* || *公钥* || *消息*)

4.  计算证明 *S* 为 *nonce* + *挑战* × *签名密钥*

署名为( *R* ， *S* )。我在图 7.11 中说明了 EdDSA 的重要部分。

![](img/07_11.png)

图 7.11 EdDSA 密钥生成产生一个机密密钥，然后用于导出另外两个密钥。第一个导出密钥是实际的签名密钥，因此可以用于导出公钥；另一个派生密钥是 nonce 密钥，用于在签名操作期间确定性地派生 nonce。EdDSA 签名类似于 Schnorr 签名，除了(1)随机数从随机数密钥和消息中确定性地生成，以及(2)签名者的公钥作为质询的一部分被包括在内。

注意随机数(或临时密钥)是如何确定性地而不是概率性地从随机数密钥和给定消息中导出的。这意味着对两个不同的消息进行签名应该涉及两个不同的随机数，巧妙地防止签名者重用随机数，从而泄露密钥(ECDSA 就可能发生这种情况)。对同一消息进行两次签名会产生两次相同的 nonce，然后产生两次相同的签名。这显然不是问题。可以通过计算以下两个等式来验证签名:

*S**G*

*R*+*哈希* ( *R* || *公钥* || *消息*)】*公钥*

如果两个值匹配，则签名有效。这正是 Schnorr 签名的工作方式，除了我们现在在一个椭圆曲线组中，我在这里使用加法符号。

EdDSA 最广泛使用的实例 Ed25519 是用 Edwards25519 曲线和 SHA-512 作为哈希函数定义的。Edwards25519 曲线由满足该方程的所有点定义:

–*x*<sup class="fm-superscript">【2】</sup>+*和*<sup class="fm-superscript">【2】</sup>= 1+***x***

其中值 *d* 是大数

【例】56860 . 46868668661

和变量 *x* 和 *y* 取模 *p* 大数 2<sup class="fm-superscript">255</sup>–19(用于 Curve25519 的同一个素数)。基点是坐标的 *G*

*x*= 151122213495354007725011514095853151145401269304185720604613283949847762202

和

*y*= 4631683569492647816942839400347516314130793625256157833603165251855960。

RFC 8032 实际上使用 Edwards25519 曲线定义了 EdDSA 的三种变体。所有三种变体都遵循相同的密钥生成算法，但使用不同的签名和验证算法:

*   *【ed 25519(或 pured 25519)*——这是我之前解释过的算法。

*   *ed 25519 CTX*—这种算法引入了一个强制性的定制字符串，在实践中即使使用，也很少实现。唯一的区别是，每次调用哈希函数时，都会添加一些用户选择的前缀。

*   *Ed25519ph(或 hashed 25519)*—这允许应用程序在签署消息之前对其进行预哈希处理(因此名字中有 *ph* )。它也建立在 Ed25519ctx 之上，允许调用者包含一个可选的自定义字符串。

添加一个*定制字符串*在密码学中相当常见，正如你在第二章中看到的一些哈希函数或者将在第八章中看到的密钥派生函数。当协议中的参与者在不同的上下文中使用相同的密钥来签署消息时，这是一个有用的补充。例如，您可以想象一个应用程序，它允许您使用您的私钥签署交易，还可以签署发给您交谈的人的私人消息。如果您错误地签署了一个看起来像是事务的消息并发送给了您邪恶的朋友 Eve，如果没有办法区分您正在签署的两种类型的有效载荷，她可能会尝试将其作为有效的事务重新发布。

Ed25519ph 的推出仅仅是为了满足需要签署大消息的呼叫者。正如你在第 2 章中看到的，哈希函数通常提供一个“初始化-更新-终结”接口，允许你连续哈希一个数据流，而不必将整个输入保存在内存中。

现在，您已经完成了在现实应用中使用的签名方案之旅。接下来，让我们看看在使用这些签名算法时，如何可能会搬起石头砸自己的脚。但首先，回顾一下:

*   RSA PKCS#1 v1.5 仍在广泛使用，但很难正确实施，许多实施已被发现被破坏。

*   RSA-PSS 具有安全性证明，更易于实现，但是由于基于椭圆曲线的更新方案，其采用率很低。

*   ECDSA 是 RSA PKCS#1 v1.5 的主要竞争对手，主要用于 NIST 曲线 P-256，但在 Secp256k1 似乎占主导地位的加密货币领域除外。

*   Ed25519 基于 Schnorr 签名，已被广泛采用，与 ECDSA 相比更易于实施；对于每个签名操作，它不需要新的随机性。如果可以的话，这是你应该使用的算法。

## 7.4 签名方案的微妙行为

签名方案可能表现出许多微妙的特性。虽然它们在大多数协议中可能无关紧要，但是在处理更复杂和非常规的协议时，没有意识到这些“陷阱”可能最终会使您陷入困境。本章的结尾重点关注数字签名的已知问题。

### 7.4.1 签名替换攻击

*数字签名并不唯一地标识一把钥匙或一条信息*。

—安德鲁·艾耶尔(《让我们加密》中的重复签名密钥选择攻击，2015)

*替换攻击*，也被称为*重复签名密钥选择* (DSKS)，在 RSA PKCS#1 v1.5 和 RSA-PSS 上都有可能。有两种 DSKS 变体:

*   *密钥替换攻击*—不同的密钥对或公钥用于验证给定消息上的给定签名。

*   *消息密钥替换攻击*——不同的密钥对或公钥被用来验证一条*新*消息上的给定签名。

再来一次:第一次攻击修复消息和签名；第二个只修复签名。我在图 7.12 中概括了这一点。

![](img/07_12.png)

图 7.12 像 RSA 这样的签名算法容易受到密钥替换攻击，这对于密码学的大多数用户来说都是令人惊讶和意想不到的行为。一种*密钥替换*攻击允许一个人在一条消息上获取一个签名，并创建一个新的密钥对来验证原始签名。一种叫做*消息密钥替换*的变种允许攻击者创建一个新的密钥对和一个在原始签名下有效的新消息。

适应性选择消息攻击下的存在不可伪造性(EUF-CMA)

替换攻击是理论密码学和应用密码学之间的一个鸿沟。密码学中的签名通常用 *EUF-CMA 模型*来分析，该模型代表在适应性选择消息攻击下的存在不可伪造性。在这个模型中，您生成一个密钥对，然后我请求您签署一些任意的消息。当我观察您生成的签名时，如果我能在某个时间点生成一个我以前没有请求的消息的有效签名，我就赢了。不幸的是，这个 EUF-CMA 模型似乎没有包含每一种边缘情况，而且像替代这样的危险微妙之处也没有被考虑在内。

### 7.4.2 签名延展性

*2014 年 2 月，曾经最大的比特币交易所 MtGox 关闭并申请破产，声称攻击者利用延展性攻击来耗尽其账户*。

—Christian Decker 和 Roger Wattenhofer(“比特币交易延展性和 MtGox”，2014 年)

大多数签名方案都是可延展的*:如果你给我一个有效的签名，我可以修改这个签名，使它成为一个不同的，但仍然有效的签名。我不知道签名密钥是什么，但我设法创建了一个新的有效签名。*

 *不可延展性并不一定意味着签名是独一无二的:如果我是签名者，我通常可以为同一条消息创建不同的签名，这通常没问题。一些构造，如可验证随机函数(你将在第八章后面看到)依赖于签名的唯一性，因此它们必须处理这个问题或使用具有唯一签名的签名方案(如博纳-林恩-沙查姆或 BLS 签名)。

强大的 EUF-CMA

称为 SUF-CMA(强 EUF-CMA)的新安全模型试图在签名方案的安全定义中包含不可延展性(或抗延展性)。一些最近的标准，如 RFC 8032，它规定了 Ed25519，包括针对可延展性攻击的缓解措施。因为这些缓解措施并不总是存在或常见，所以您不应该依赖于协议中不可延展的签名。

如何处理所有这些信息？请放心，签名方案肯定不会被破坏，如果您对签名的使用不是太出格，您可能不应该担心。但是，如果您正在设计加密协议，或者如果您正在实现一个比日常加密更复杂的协议，您可能希望将这些微妙的属性隐藏起来。

## 总结

*   数字签名类似于纸笔签名，但有加密技术支持，因此任何不控制签名(私人)密钥的人都无法伪造。

*   数字签名可用于认证来源(例如，密钥交换的一方)以及提供可传递的信任(如果我信任 Alice，她信任 Bob，我也可以信任 Bob)。

*   零知识证明(ZKPs)允许证明者证明特定信息的知识(称为见证),而不透露该信息。签名可以被视为非交互式 zkp，因为它们不要求验证者在签名操作期间在线。

*   你可以使用许多标准来签名:

    *   RSA PKCS#1 v1.5 目前被广泛使用，但不推荐使用，因为它很难正确实施。
    *   RSA-PSS 是一个更好的签名方案，因为它更容易实现并且具有安全性证明。不幸的是，它现在并不流行，因为椭圆曲线变体支持更短的密钥，因此对网络协议更有吸引力。
    *   目前最流行的签名方案是基于椭圆曲线的:ECDSA 和 EdDSA。ECDSA 通常与 NIST 曲线 P-256 一起使用，EdDSA 通常与 Edwards25519 曲线一起使用(这种组合称为 Ed25519)。
*   如果以非传统方式使用签名，一些微妙的属性可能会很危险:

    *   因为一些签名方案容易受到密钥替换攻击，所以总是避免关于谁签署了消息的模糊性。外部参与者可以创建新的密钥对来验证消息上已经存在的签名，或者创建新的密钥对和新的消息来验证给定的签名。
    *   不要依赖签名的唯一性。首先，在大多数签名方案中，签名者可以为同一消息创建任意数量的签名。第二，大多数签名方案是可延展的 T2，这意味着外部参与者可以接受一个签名并为同一消息创建另一个有效的签名。***