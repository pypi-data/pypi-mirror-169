# 十七、附录：练习答案

## 第二章

*如果作为承诺方案使用，你能看出一个哈希函数是否提供隐藏和绑定吗？*。

哈希函数*隐藏*得益于前像抵抗属性；也就是说，如果你的输入足够随机以至于没人能猜到。为了解决这个问题，你可以生成一个随机数，并与你的输入进行哈希运算，之后，你可以将你的输入和随机数一起透露给*公开*你的承诺。由于第二个前像阻力特性，哈希函数被*绑定*。

*对了，这个字符串没有办法表示 256 位(32 字节)吧？这怎么安全呢？*。

我们不在乎碰撞阻力。我们只关心第二前像阻力。因此，我们可以截断摘要以减小其大小。

你能猜出恐怖海盗罗伯茨(丝绸之路网站站长的化名)是如何获得包含网站名称的哈希码的吗？。

可怕的海盗 Roberts 创造了许多密钥，直到其中一个以很酷的 base32 表示结束。脸书也做了同样的事情，可以从 Facebook corewwwi . onion([https://Facebook . com/notes/protect-the-graph/making-connections-to-Facebook-more-secure/1526085754298237](https://facebook.com/notes/protect-the-graph/making-connections-to-facebook-more-secure/1526085754298237)访问。这些被称为*虚荣心地址*。

## 第三章

你能找出一个可变长度的计数器是如何让攻击者伪造认证标签的吗？。

通过观察下面的消息，其中`||`表示字符串串联，`MAC(k,` `"1"` `||` `"1` `is` `my` `favorite` `number")`，攻击者可以伪造第十一条消息的有效认证标签，`MAC(k,``"11"``|``"``is``my``favorite``number")`。

*注意:并非所有 MAC 都是 PRF。你能看出为什么吗？*。

假设下面的函数是有效的 MAC 和 PRF: `MAC(key,` `input)`，那么下面的函数是有效的 MAC 吗？`NEW_MAC` `=` `MAC(key,` `input)` `||` `0x01`它是有效的 PRF 吗？它是有效的 MAC，因为它可以防止伪造，但它不是有效的 PRF，因为您可以很容易地将输出与完全随机的字符串区分开来(因为最后一个字节总是设置为 1)。

## 第六章

*和所有人使用同一个共享机密会很糟糕；你能看出为什么吗？*。

如果我可以用这个共享的机密加密给你的信息，我也可以解密来自其他人的信息。

*你看出为什么不能马上使用密钥交换输出了吗？*。

记住你在第 5 章“关键交易”中学到的东西。在(FF)DH 中，计算以大素数 *p* 为模。我们以一个小素数为例，65，537。在十六进制中，我们的 *p* 写成`0x010001`，在二进制中写成`0000` `0001` `0000` `0000` `0000` `0001`。在二进制中，注意第一个数字前面的零，因为我们用字节(8 位的倍数)来表示数字。

如果你懂模运算，你就知道以这个质数为模的数 *p* 永远不会更大，也就是说前 7 位永远被设为 0。此外，第八位通常会被设置为 0 而不是 1。这不是*齐刷刷地乱*。理想情况下，每一位被设置为 1 或 0 的概率应该相同。

## 第七章

*正如你在第三章看到的，MAC 产生的认证标签必须在恒定时间内进行验证，以避免计时攻击。你认为我们需要为验证签名做同样的事情吗？*。

不是。这是因为认证标签的验证涉及密钥。验证签名只涉及公钥，因此不需要在恒定时间内验证。

## 第八章

想象一下，把不同来源的熵简单地异或在一起就能混合起来。你能看出这怎么可能没有帮助吗？。

熵的后门来源可以将其输出设置为所有其他熵来源的 XOR，有效地将所有熵抵消为 0。

像 BLS(在图 8.5 和第 7 章中提到)这样的签名方案产生唯一的签名，但是对于 ECDSA 和 EdDSA 来说这是不正确的。你知道为什么吗？。

在 ECDSA 中，签名者可以选择不同的随机数来为相同的密钥对和消息生成不同的签名。虽然 EdDSA 是一种基于要签名的消息确定性地导出随机数的签名算法，但这并不意味着签名者不能使用他们选择的任何随机数。

## 第九章

服务器私钥在某个时间点的泄露将是毁灭性的，因为 MITM 攻击者将能够解密所有先前记录的对话。你知道这是怎么发生的吗？。

然后，攻击者就可以倒回历史，在握手时冒充服务器。事实上，攻击者现在有了服务器的私钥。执行密钥交换和导出握手后对称密钥的所有其他信息都是公开的。

*值`signatureAlgorithm`和`signatureValue`不包含在实际证书`tbsCertificate`中。你知道为什么吗？*。

证书颁发机构(CA)需要对证书进行签名，这就导致了一个悖论:签名不能是签名本身的一部分。因此，CA 必须将签名附加到证书上。其他标准和协议可能使用不同的技术。例如，您可以将签名作为`tbsCertificate`的一部分，并在签名或验证证书时假装它全是 0。

## 第十章

*你知道为什么邮件的内容是加密前压缩而不是加密后压缩吗？*。

根据密码的定义，密文与随机字符串是无法区分的。因此，压缩算法无法找到有效压缩加密数据的模式。因此，压缩总是在加密之前应用。

你能想出一种明确的方式来签署消息吗？。

一行:验证上下文。一种方法是在签名中包含发送者和接收者的姓名以及他们的公钥，然后对其进行加密。

## 第十一章

*有时，应用程序试图解决服务器在注册时获知用户密码的问题，方法是在将密码发送给服务器之前，让客户端对密码进行哈希处理(可能使用密码哈希)。你能确定这是否真的有效吗？*。

像臭名昭著的哈希传递攻击(【https://en.wikipedia.org/wiki/Pass_the_hash】)显示的那样，客户端哈希单独不起作用；如果服务器直接存储爱丽丝的哈希密码，那么任何窃取它的人也可以用它作为密码来认证为爱丽丝。一些应用程序同时执行客户端哈希和服务器端哈希，在这种情况下，这可能会阻止主动攻击者知道原始密码(尽管主动攻击者可能能够通过更新客户端应用程序的代码来禁用客户端哈希)。

*设想一个协议，你必须输入正确的 4 位 PIN 码才能安全地连接到设备。仅通过猜测选择正确 PIN 的几率有多大？*。

猜对的概率是万分之一。如果你用这些赔率玩乐透，你会很开心的。