# 八、随机性与机密

本章涵盖了

*   什么是随机性，为什么随机性很重要
*   获得强随机性，产生机密
*   随机性的陷阱

这是本书第一部分的最后一章，在我们进入第二部分学习现实世界中使用的实际协议之前，我还有最后一件事要告诉你。这是我迄今为止严重忽视的东西——随机性。

你一定已经注意到，在你所学的每一种加密算法中(除了哈希函数)，你都不得不在某些时候使用随机性:密钥、随机数、iv、质数、挑战等等。当我经历这些不同的概念时，随机性总是来自于一些神奇的黑盒。这并非不典型。在密码学白皮书中，随机性通常用在顶部画一个带美元符号的箭头来表示。但在某些时候，我们需要问自己这样一个问题，“这种随机性到底从何而来？”

在这一章中，我将为你提供一个答案，当提到随机性时，密码学意味着什么。我还将为您提供一些关于现实世界中加密应用程序获得随机性的实用方法。

注 对于本章，你需要阅读第二章关于哈希函数和第三章关于消息认证码的内容。

## 8.1 什么是随机性？

每个人都在某种程度上理解随机性的概念。无论是玩骰子，还是买彩票，我们都接触过。我第一次接触随机性是在很小的时候，当时我意识到，每当我按下计算器上的一个 RAND 按钮时，它都会产生一个不同的数字。这使我苦恼不已。我对电子学知之甚少，但我认为我能理解它的一些局限性。当我把 4 和 5 加在一起时，肯定会有一些电路进行计算并给出结果。但是一个随机的按钮？随机数是从哪里来的？我无法理解。

我花了一些时间去问正确的问题，并且明白计算器实际上是在作弊！他们会硬编码一大串随机数，然后一个接一个地检查。这些列表表现出很好的随机性，这意味着如果你观察你得到的随机数，1 和 9 一样多，1 和 2 一样多，等等。这些列表将模拟一个*均匀分布*:数字以相等的比例分布(均匀)。

当出于安全和加密目的需要随机数时，随机性必须是*不可预测的*。当然，在那个时候，没有人会把那些计算器的“随机性”用于任何与安全有关的事情。相反，加密应用程序从观察难以预测的物理现象中提取随机性。

例如，很难预测掷骰子的结果，尽管掷骰子是一个确定的过程；如果你知道所有的初始条件(你如何投掷骰子，骰子本身，空气摩擦，桌子的抓地力，等等)，你应该能够预测结果。也就是说，所有这些因素对最终结果的影响如此之大，以至于对初始条件的了解稍有不精确就会扰乱我们的预测。一个结果对其初始条件的极端敏感性被称为*混沌理论*，这也是天气等事物难以准确预测超过一定天数的原因。

下面的图片是我在一次参观位于旧金山的 Cloudflare 总部时拍摄的。LavaRand 是一堵熔岩灯墙，这些灯产生难以预测形状的蜡。在墙前设置一个摄像头，提取图像并将其转换为随机字节。

![](img/08_001_UN01.png)

应用程序通常依靠操作系统来提供可用的随机性，而操作系统又根据运行它的设备类型，使用不同的技巧来收集随机性。随机性的常见来源(也称为*熵来源*)可以是硬件中断的时间(例如，你的鼠标移动)、软件中断、硬盘寻道时间等等。

熵

在信息论中，*熵*这个词用来判断一个字符串包含多少随机性。这个术语是由 Claude Shannon 创造的，他设计了一个熵公式，随着字符串表现出越来越多的不可预测性(从 0 开始表示完全可预测)，该公式将输出越来越大的数字。公式或者数字本身对我们来说并没有那么有趣，但是在密码学中，你经常会听到“这个字符串熵值低”(意味着它是可预测的)或者“这个字符串熵值高”(意味着它不太可预测)。

观察中断等事件产生的随机性不大；当设备启动时，这些事件往往是高度可预测的，它们也可能受到外部因素的恶意影响。今天，越来越多的设备可以使用额外的传感器和硬件辅助设备来提供更好的熵源。这些硬件随机数发生器通常被称为*真随机数发生器*(trng)，因为它们利用外部不可预测的物理现象，如热噪声来提取随机性。

通过所有这些不同类型的输入获得的噪声通常不“干净”,并且有时不提供足够的熵(如果有的话)。例如，从某个熵源获得的第一个比特可能经常是 0，或者连续的比特可能(更有可能)相等。因此，*随机抽取器*必须清除并收集几个噪声源，然后才能用于加密应用。例如，这可以通过将哈希函数应用于不同的源并将摘要异或在一起来实现。

这就是随机性的全部吗？可惜没有。从噪音中提取随机性是一个缓慢的过程。对于一些可能需要大量随机数的应用程序来说，这可能会成为一个瓶颈。下一节将描述操作系统和现实世界的应用程序如何促进随机数的生成。

## 8.2 慢随机性？使用伪随机数发生器(PRNG)

到处都在使用随机性。在这一点上，你应该相信这是真的，至少对于密码学来说是这样，但是令人惊讶的是，密码学并不是唯一大量使用随机数的地方。例如，像 ls 这样的简单 Unix 程序也需要随机性！由于程序中的错误如果被利用可能是毁灭性的，二进制文件试图使用许多技巧来防御低级攻击；其中之一是 *ASLR* (地址空间布局随机化)，它在每次运行时随机化进程的内存布局，因此需要随机数。另一个例子是网络协议 TCP，它在每次创建连接时使用随机数来产生不可预测的数字序列，并阻止试图劫持连接的攻击。虽然所有这些都超出了本书的范围，但了解一下在现实世界中有多少随机性最终被用于安全目的还是很有好处的。

我在上一节中暗示过，不幸的是，获得不可预测的随机性是一个缓慢的过程。这有时是由于熵源产生噪音的速度较慢。因此，操作系统通常通过使用*伪随机数发生器* (PRNGs)来优化随机数的产生。

注意 为了与不被设计为安全的随机数发生器(以及在不同类型的应用中有用的随机数发生器，如视频游戏)形成对比，prng 有时被称为 CSPRNGs，用于*密码安全的*prng。NIST 想要以不同的方式做事(像往常一样)，经常把他们的 prng*称为确定性随机位生成器*(drbg)。

PRNG 需要一个初始机密，通常称为*种子*，我们可以通过将不同的熵源混合在一起获得，然后可以快速产生大量随机数。我在图 8.1 中举例说明了一个 PRNG。

![](img/08_01.png)

图 8.1 伪随机数发生器(PRNG)根据一个种子生成一个随机数序列。使用相同的种子使 PRNG 产生相同的随机数序列。使用随机输出的知识来恢复状态应该是不可能的(函数`next`是一种方法)。由此可见，仅仅通过观察产生的随机数来预测未来的随机数或恢复先前产生的随机数也是不可能的。

密码安全的 PRNGs 通常表现出以下特性:

*   *确定性* —两次使用相同的种子产生相同的随机数序列。这不同于我之前提到的不可预测的随机抽取:如果你知道 PRNG 使用的种子，PRNG 应该是完全可预测的。这就是为什么这种构造被称为*伪*随机，这就是为什么 PRNG 可以非常快。

*   *与随机*难以区分——在实践中，你应该无法区分 PRNG 从一组可能的数字中输出一个随机数和一个小仙女公正地从同一组数字中选择一个随机数(假设仙女知道一种神奇的方法来挑选一个数字，这样每个可能的数字都可以以相等的概率被选中)。因此，仅凭观察产生的随机数，任何人都无法恢复 PRNG 的内部状态。

最后一点很重要！PRNG 模拟随机均匀地挑选一个数字*，这意味着该组中的每个数字都有均等的机会被选中。例如，如果您的 PRNG 产生 8 个字节的随机数，则该集合是所有可能的 8 个字节的字符串，并且每个 8 个字节的值应该有相等的概率成为可以从您的 PRNG 中获得的下一个值。这包括 PRNG 在过去某个时候已经产生的值。*

 *此外，许多 PRNGs 还具有额外的安全属性。如果攻击者了解到状态(例如，在某个时间点进入你的计算机)不允许 PRNG 检索先前生成的随机数，那么 PRNG 具有*前向保密性*。我在图 8.2 中对此进行了说明。

![](img/08_02.png)

图 8.2 如果状态的泄露不允许恢复先前生成的随机数，则 PRNG 具有前向保密性。

获得 PRNG 的*状态*意味着您可以确定它将生成的所有未来伪随机数。为了防止这种情况，一些 PRNGs 具有定期自我“修复”的机制(以防出现危害)。这种修复可以通过在 PRNG 被播种后重新注入(或重新播种)新熵来实现。这个属性叫做*后向保密*。我在图 8.3 中说明了这个。

![](img/08_03.png)

图 8.3 如果一个状态的妥协不允许预测 PRNG 产生的未来随机数，则 PRNG 具有后向保密性。只有在折衷后产生新的熵并将其注入更新函数时，这种情况才会发生。

注 术语*前向*和*后向保密*经常引起混淆。如果你读到这一节，认为前向保密不应该是后向保密，后向保密应该是前向保密，那么你没有疯。由于这个原因，后向保密有时被称为未来保密，甚至是妥协后保密。

如果正确播种，PRNGs 可以非常快，并且被认为是产生大量用于加密目的的随机值的安全方法。使用可预测的数字或太小的数字显然不是播种 PRNG 的安全方法。这实际上意味着我们有安全的加密方法来快速地将适当大小的机密扩展到数十亿个其他机密密钥。很酷，对吧？这就是为什么大多数(如果不是全部的话)加密应用不使用直接从噪声中提取的随机数，而是在初始步骤中使用它们来播种 PRNG，然后在需要时切换到从 PRNG 生成随机数。

双 EC 借壳

今天，PRNGs 大多是基于启发式的构造。这是因为基于数学难题(如离散对数)的构造太慢，不切实际。一个臭名昭著的例子是由 NSA 发明的依靠椭圆曲线的*双 EC* 。大约在 2006 年，双 EC PRNG 被推向各种标准，包括一些 NIST 出版物，不久之后，几名研究人员独立地发现了算法中的一个潜在后门。这一点后来在 2013 年斯诺登爆料中得到证实，一年后该算法从多个标准中退出。

为了安全起见，PRNG 必须播下一个*不可预知的*机密。更准确地说，我们说 PRNG 随机抽取均匀采样的 *n* 字节的密钥。这意味着我们应该从所有可能的 *n* 字节字符串的集合中随机选取密钥，其中每个字节字符串都有相同的机会被选取。

在这本书里，我谈到了许多密码算法，它们产生的输出与随机输出(从随机选择的值中)无法区分。直觉上，你应该在想我们可以用这些算法来产生随机数吗？你是对的！哈希函数、xof、分组密码、流密码和 MAC 可用于产生随机数。哈希函数和 MAC 在理论上没有被定义为提供与随机无法区分的输出，但在实践中，它们经常是这样的。另一方面，像密钥交换和签名这样的非对称算法(几乎总是)与随机算法没有区别。由于这个原因，它们的输出通常在用作随机数之前被哈希。

实际上，因为 AES 在大多数机器上都是硬件支持的，所以习惯上看到 AES-CTR 被用来产生随机数。对称密钥成为种子，而密文成为随机数(例如，对于 0 的无限字符串的加密)。在实践中，为了提供前向和后向保密，这些结构增加了一点复杂性。幸运的是，您现在已经足够理解下一节了，这一节提供了获取真实随机性的概述。

## 8.3 在实践中获得随机性

您已经了解了操作系统为其程序提供加密安全随机数所需的三个要素:

*   *噪声源* —这些是操作系统从不可预测的物理现象(如设备温度或鼠标移动)中获取原始随机性的方式。

*   *清理和混合*——虽然原始的随机性可能质量很差(有些位可能会有偏差)，但操作系统会清理并混合许多来源，以便产生一个好的随机数。

*   *PRNGs* —因为的前两步很慢，所以可以使用一个单一的、均匀随机的值来播种一个可以快速产生随机数的 PRNG。

在这一部分，我将解释系统如何将这三个概念捆绑在一起，为开发者提供简化的界面。操作系统公开的这些函数通常允许您通过发出系统调用来生成一个随机数。在这些系统调用的背后，实际上是一个捆绑了噪声源、混合算法和 PRNG 的系统(如图 8.4 所示)。

![](img/08_04.png)

图 8.4 在一个系统上生成随机数通常意味着熵从不同的噪声源混合在一起，并用于播种长期 PRNG。

根据操作系统和可用的硬件，这三个概念可能会以不同的方式实现。2021 年，Linux 使用基于 ChaCha20 流密码的 PRNG，而 macOS 使用基于 SHA-1 哈希函数的 PRNG。此外，根据操作系统的不同，向开发人员公开的随机数生成器接口也会有所不同。在 Windows 上，`BCryptGenRandom`系统调用可以用于产生随机数，而在其他平台上，一个特殊的文件(通常称为/dev/urandom)被暴露，可以被读取以提供随机性。例如，在 Linux 或 macOS 上，可以使用`dd`命令行工具从终端读取 16 个字节:

```
$ dd if=/dev/urandom bs=16 count=1 2> /dev/null | xxd -p
40b1654b12320e2e0105f0b1d61e77b1
```

/dev/urandom 的一个问题是，如果在设备启动后过早使用，它可能无法提供足够的熵(它的数字不够随机)。像 Linux 和 FreeBSD 这样的操作系统提供了一个叫做`getrandom`的解决方案，也就是一个系统调用，它提供了与从/dev/urandom 读取几乎相同的功能。在极少数情况下，当没有足够的熵来初始化它的 PRNG 时，`getrandom`将阻塞程序的继续运行，并等待直到被正确播种。出于这个原因，我建议您使用`getrandom`，如果它在您的系统上可用的话。下面的清单展示了如何在 C #中安全地使用`getrandom`:

清单 8.1 在 C 语言中获取随机数

```
#include <sys/random.h>

uint8_t secret[16];                                ❶
int len = getrandom(secret, sizeof(secret), 0);    ❷

if (len != sizeof(secret)) {
    abort();                                       ❸

}
```

❶ 用随机字节填充缓冲区(注意 getrandom 每次调用最多 256 字节)。

❷默认标志(0)是不阻塞的，除非正确播种。

❸ 函数可能会失败，或者返回的随机字节数少于预期值。如果是这种情况，系统已经损坏，中止可能是最好的办法。

记住这个例子，指出许多编程语言都有提供更好抽象的标准库和加密库也是有好处的。例如，可能很容易忘记`getrandom`每次调用最多只返回 256 字节。出于这个原因，您应该总是尝试通过您正在使用的编程语言的标准库来生成随机数。

警告 注意，很多编程语言都公开了产生可预测随机数的函数和库。这些不适合加密使用！确保你使用的随机库能够生成加密性很强的随机数。通常库的名字会有所帮助(例如，你大概能猜出你应该在 Golang 的`math/rand`和`crypto/rand`包之间使用哪个)，但是没有什么能代替阅读手册！

清单 8.2 展示了如何使用 PHP 7 生成一些随机字节。任何加密算法都可以使用这些随机字节。例如，作为机密密钥来使用认证加密算法进行加密。每种编程语言做事情的方式都不一样，所以一定要查阅编程语言的文档，以便找到获得用于加密目的的随机数的标准方法。

清单 8.2 在 PHP 中获取随机数

```
<?php
$bad_random_number = rand(0, 10);    ❶

$secret_key = random_bytes(16);      ❷
?>
```

❶ 产生一个 0 到 10 之间的随机整数。虽然速度很快，但 rand 不能产生加密安全的随机数，因此它不适用于加密算法和协议。

❷ random_bytes 用 16 个随机字节创建并填充一个缓冲区。该结果适用于密码算法和协议。

既然你已经知道了如何在你的程序中获得密码安全的随机性，让我们来考虑一下当你生成随机性时你需要记住的安全注意事项。

## 8.4 随机性产生和安全性考虑

在这一点上，最好记住，任何基于密码学的有用协议都需要良好的随机性，而一个被破坏的 PRNG 可能会导致整个密码协议或算法不安全。您应该清楚 MAC 的安全性取决于与之一起使用的密钥，或者最轻微的可预测性通常会破坏 ECDSA 等签名方案。

到目前为止，这一章听起来好像产生随机性应该是应用密码学的一个简单的部分，但实际上并不是。由于各种各样的问题，随机性实际上是现实世界密码学中许多许多错误的来源:使用非加密 PRNG，错误地播种 PRNG(例如，使用可预测的当前时间)，等等。

一个例子包括使用*用户域 prng*的程序，而不是系统调用背后的*内核 prng*。用户土地规划通常会增加不必要的摩擦，如果滥用，在最坏的情况下，会破坏整个系统。OpenSSL 库提供的 PRNG 就是一个明显的例子，该库在 2006 年被修补到一些操作系统中，无意中影响了所有使用易受攻击的 PRNG 的 SSL 和 SSH 生成的密钥。

*删除这段代码的副作用是削弱了 OpenSSL PRNG 的播种过程。不是混合随机数据作为初始种子，而是使用当前进程 ID 作为唯一的随机值。在 Linux 平台上，默认的最大进程 ID 是 32，768，这导致所有 PRNG 操作使用的种子值非常少*。

H. D .摩尔(“Debian OpenSSL 可预测的 PRNG 玩具”，2008 年)

由于这个原因和其他原因，我将在本章后面提到，避免用户 PRNG 和坚持操作系统提供的随机性是明智的。在大多数情况下，坚持使用编程语言的标准库或好的加密库就足够了。

我们不能在“最佳实践”之后继续添加“最佳实践”到开发人员在编写日常代码时需要记住的东西中。

—Martin bolet(“OpenSSL PRNG(真的)不安全”，2013 年)

不幸的是，再多的建议也不能让你对获得良好随机性的许多陷阱有所准备。因为随机性是每个加密算法的核心，所以犯一点小错误都会导致灾难性的后果。如果您遇到以下边缘情况，最好记住它们:

*   *分叉进程*—当使用一个 PRNG 用户时(一些对性能要求极高的应用程序可能别无选择)，重要的是要记住，一个分叉的程序将产生一个新的子进程，该子进程将具有与其父进程相同的 PRNG 状态。因此，从那时起，两个 PRNGs 将产生相同的随机数序列。出于这个原因，如果你真的想使用 PRNG 用户，你必须小心让分叉使用不同的种子。

*   *【虚拟机】*—PRNG 状态的克隆在使用操作系统 PRNG 时也会出现问题。想想虚拟机。如果保存虚拟机的整个状态，然后从现在开始启动几次，每个实例可能会产生完全相同的随机数序列。这有时可以通过虚拟机管理程序和操作系统来解决，但在运行请求虚拟机中随机数的应用程序之前，最好先了解一下您正在使用的虚拟机管理程序在做什么。

*   *早期启动熵* —虽然由于用户与设备交互产生的噪音，操作系统应该在用户操作的设备中收集熵没有问题，但嵌入式设备和无头系统需要克服更多挑战，以便在启动时产生良好的熵。历史表明，一些设备往往以类似的方式启动，并最终从系统中积累相同的初始噪声，导致相同的种子用于其内部 PRNGs，并产生相同的随机数序列。

有一个易受攻击的窗口——一个启动时熵漏洞——在此期间，Linux 的灾难可能是完全可预测的，至少对于单核系统来说是这样。[.。。]当我们禁用了在无头设备或嵌入式设备上可能不可用的熵源时，Linux RNG 在每次启动时都会产生相同的可预测流。

—Heninger 等人(挖掘您的 Ps 和 Qs:检测网络设备中广泛存在的弱密钥，2012 年)

在这些罕见的情况下，你真的真的需要在引导早期获得随机数，你可以通过提供从另一台机器的良好播种的`getrandom`或/dev/urandom 生成的一些初始熵来帮助系统。不同的操作系统可能提供这个特性，如果你发现自己处于这种情况，你应该查阅他们的手册(像往常一样)。

如果可以的话，TRNG 提供了一个简单的问题解决方案。例如，现代英特尔 CPU 嵌入了一种特殊的硬件芯片，可以从热噪声中提取随机性。这种随机性可以通过一个叫做`RDRAND`的指令获得。

`RDRAND`论战

有趣的是，由于担心后门，英特尔的`RDRAND`一直备受争议。大多数集成了`RDRAND`作为熵源的操作系统以*贡献*的方式将其与其他熵源混合。贡献在这里意味着熵的一个来源不能强迫随机性产生的结果。

运动

想象一下，把不同来源的熵简单地异或在一起就能混合起来。你能看出这怎么可能没有帮助吗？

最后，让我提一下，避免随机性陷阱的一个解决方案是使用较少依赖随机性的算法。例如，你在第 7 章中看到 ECDSA 要求你每次签名时生成一个随机随机数，而 EdDSA 不要求。你在第四章看到的另一个例子是 AES-GCM-SIV，如果你碰巧重复使用同一个随机数两次，它不会灾难性地崩溃，与 AES-GCM 相反，它会泄漏认证密钥，然后失去密文的完整性。

## 8.5 公共随机性

到目前为止，我主要谈论了*私有随机性*，那种你可能需要用于你的私有密钥的。有时候，不需要隐私和*需要公开随机性*。在这一节中，我简要地调查了获得这种公共随机性的一些方法。我区分了两种情况:

*   *一对多*——你要为别人产生随机性。

*   *多对多*——一组参与者想要一起产生随机性。

首先，让我们假设你想以一种许多参与者都可以验证的方式产生一个随机流。换句话说，从你的角度来看，这种趋势应该是不可预测的，但不可能改变。现在假设您有一个基于密钥对和消息提供唯一签名的签名方案。在这样的签名方案中，存在一种称为*可验证随机函数* (VRF)的构造，以可验证的方式获得随机数(图 8.5 说明了这个概念)。下面显示了这是如何工作的:

1.  您生成一个密钥对并发布验证密钥。您还发布了一个公共种子。

2.  要生成随机数，您需要签署公共种子并哈希签名。摘要是你的随机数，签名也是作为证明公布的。

3.  为了验证随机数，任何人都可以哈希签名以检查它是否与随机数匹配，并使用公共种子和验证密钥来验证签名是否正确。

![](img/08_05.png)

图 8.5 可验证随机函数(VRF)通过公钥加密产生可验证的随机性。要生成随机数，只需使用生成唯一签名的签名方案(如 BLS)来签署一个种子，然后对签名进行哈希运算以生成公共随机数。要验证结果的随机性，请确保签名的哈希确实是随机数，并在种子上验证签名。

通过像计数器一样使用公共种子，可以扩展这种结构来产生许多随机数。因为签名是唯一的，并且公共种子是固定的，所以签名者无法生成不同的随机数。

运动

像 BLS(图 8.5 和第 7 章中提到的)这样的签名方案产生唯一的签名，但是对于 ECDSA 和 EdDSA 来说，这是不正确的。你知道为什么吗？

为了解决这个问题，互联网草案(一个旨在成为 RFC 的文档)规定了如何使用 ECDSA 实现 VRF。在某些情况下(例如，彩票游戏)，几个参与者可能想要随机决定一个赢家。我们称它们为*分散随机性信标*，因为它们的角色是产生相同的可验证的随机性，即使一些参与者决定不参与该协议。一种常见的解决方案是使用之前讨论的 VRFs，不是使用单个密钥，而是使用*阈值分发密钥*，该密钥在许多参与者之间分割，并且仅在阈值参与者已经对消息签名之后才产生给定消息的唯一有效签名。这听起来可能有点混乱，因为这是我第一次谈论分布式密钥。要知道，在本章的后面，你会学到更多关于这些的知识。

一个受欢迎的分散随机信标叫做 T2，由几个组织和大学联合运作。在 https://leagueofentropy.com 的 T5 有售。

*生成良好随机性的主要挑战是，参与随机性生成过程的任何一方都不能预测或偏向最终输出。一个 drand 网络不受其任何成员的控制。没有单点故障，没有一个 drand 服务器运营商能够偏向网络*产生的随机性。

——[https://drand . love](https://drand.love)(《drand 如何运作》2021)

既然我已经广泛地讨论了随机性以及当今程序是如何获得随机性的，让我们将讨论转移到机密在密码学中的作用以及如何管理它们。

## 8.6 用 HKDF 导出密钥

prng 并不是唯一可以用来从一个机密推导出更多机密的结构(换句话说，就是延伸一个密钥)。从一个机密导出几个机密实际上是密码学中如此频繁的模式，以至于这个概念有了自己的名字:*密钥导出*。让我们看看这是怎么回事。

一个*密钥派生函数* (KDF)在很多方面都像一个 PRNG ，除了下面列出的一些细微之处。图 8.6 总结了这些差异。

*   *一个 KDF 不一定期望一个均匀随机的机密(只要它有足够的熵)。*这使得 KDF 对于从密钥交换输出中导出机密是有用的，密钥交换输出产生高熵但有偏见的结果(见第五章)。由此产生的机密依次是一致随机的，因此您可以在期望一致随机密钥的构造中使用它们。

*   *KDF 一般用在需要参与者多次重新驱动相同密钥的协议中。*在这个意义上，KDF 被认为是确定性的，而 PRNGs 有时通过频繁地重新播种更多的熵来提供向后保密。

*   *一个 KDF 通常不是设计来产生大量随机数的。*取而代之的是，它通常用于导出有限数量的密钥。

![](img/08_06.png)

图 8.6 一个密钥衍生函数(KDF)和一个 PRNG 是两个相似的构造。主要区别在于，KDF 不期望完全均匀随机的机密作为输入(只要它有足够的熵),并且通常不用于产生太多的输出。

最流行的 KDF 是*基于 HMAC 的密钥派生函数* (HKDF)。你在第三章中学习了关于 HMAC(一种基于哈希函数的 MAC)。HKDF 是建立在 HMAC 之上的轻型 KDF，在 RFC 5869 中定义。因此，可以将 HKDF 与不同的哈希函数一起使用，尽管它最常用于 SHA-2。HKDF 被指定为两个不同的函数:

*   *——HKDF 提取*——从机密输入中去除偏见，产生均匀随机的机密。

*   *——HKDF 扩展*——产生一个任意长度和均匀随机输出。像 PRNGs 一样，*期望一个均匀随机的机密作为输入*，因此，通常在 HKDF 提取之后运行。

![](img/08_07.png)

图 8.7 HKDF 展开是 HKDF 指定的第二个函数。它需要一个可选的`info`字节字符串和一个需要均匀随机的输入机密。使用具有相同输入密码的不同`info`字节字符串会产生不同的输出。输出的长度由一个`length`参数控制。

让我们先来看看 HKDF 摘录，我在图 8.7 中做了说明。从技术上讲，一个哈希函数足以使输入字节串的随机性一致化(记住，哈希函数的输出被认为是无法与随机区分的)，但是 HKDF 更进一步，接受了一个额外的输入:一个 *salt* 。关于密码哈希，一个 salt 区分了 HKDF-Extract 在同一个协议中的不同用法。虽然这个 salt 是可选的，如果不使用，它将被设置为全零字节字符串，但是我们建议您使用它。此外，HKDF 不期望盐是一个机密；每个人都可能知道，包括对手。HKDF-Extract 没有使用哈希函数，而是使用了 MAC(特别是 HMAC ),碰巧它有一个接受两个参数的接口。

现在让我们看看 HKDF 扩展，如图 8.8 所示。如果你的输入机密已经是均匀随机的，你可以跳过 HKDF 提取，使用 HKDF 扩展。

![](img/08_08.png)

图 8.8 HKDF 提取是 HKDF 规定的第一个函数。它采用一个可选的 salt 作为 HMAC 中的密钥，并且输入机密可能是非均匀随机的。使用具有相同输入机密的不同盐会产生不同的输出。

与 HKDF-Extract 类似，HKDF-Expand 也接受一个额外的可选定制参数`info`。虽然 salt 旨在为 HKDF(或 HKDF-Extract)的同一协议内的调用提供一些域分隔，但`info`旨在用于将您的 HKDF(或 HKDF-Expand)版本与其他协议区分开来。你也可以指定你想要多少输出，但是请记住，HKDF 不是 PRNG，也不是为了获取大量机密而设计的。HKDF 受到您使用的哈希函数大小的限制；更准确地说，如果您将 SHA-512(它产生 512 位的输出)与 HKDF 一起使用，那么对于一个给定的键和一个`info`字节字符串，您只能得到 512 × 255 位= 16，320 字节的输出。

使用相同的参数(除了输出长度)多次调用 HKDF 或 HKDF-Expand，产生的相同输出被截断成不同的请求长度(见图 8.9)。这个属性被称为*相关输出*，在极少数情况下，会让协议设计者感到惊讶。记住这一点是有好处的。

![](img/08_09.png)

图 8.9 HKDF 和 HKDF 展开提供了相关的输出，这意味着用不同的输出长度调用函数会将相同的结果截断到所要求的长度。

大多数密码库将 HKDF 提取和 HKDF 扩展组合成一个调用，如图 8.10 所示。像往常一样，在使用 HKDF 之前，确保阅读手册(在这种情况下，RFC 5869)。

![](img/08_10.png)

图 8.10 HKDF 通常被实现为一个单一的函数调用，结合了 HKDF 提取(从输入键中提取均匀的随机性)和 HKDF 扩展(生成任意长度的输出)。

HKDF 并不是从一个机密推导出多个机密的唯一方法。一个更简单的方法是使用*哈希函数*。由于 hash 函数不期望均匀随机的输入并产生均匀随机的输出，所以它们适合这个任务。然而，哈希函数并不完美，因为它们的接口没有考虑到账户*域分隔*(没有定制字符串参数)，并且它们的输出长度是固定的。最佳实践是在可以使用 KDF 的情况下避免使用哈希函数。尽管如此，一些广为接受的算法确实为此使用了哈希函数。例如，你在第 7 章中学习了 Ed25519 签名方案，它用 SHA-512 哈希一个 256 位密钥来产生两个 256 位密钥。

这些函数真的会产生随机输出吗？

理论上，哈希函数的属性并没有说输出是一致随机的；这些属性仅规定哈希函数应该是抗冲突的、抗前映像的和抗第二前映像的。然而，在现实世界中，我们到处使用哈希函数来实现随机预言(正如你在第 2 章中所学的)，因此，我们假设它们的输出是一致随机的。这与 MAC 是一样的，理论上，不期望 MAC 产生均匀随机输出(不像第 3 章中看到的 PRF)，但实际上，在大多数情况下是这样的。这就是 HKDF 使用 HMAC 的原因。在本书的其余部分，我将假设流行的哈希函数(如 SHA-2 和 SHA-3)和流行的 MAC(如 HMAC 和 KMAC)产生随机输出。

我们在第 2 章(SHAKE 和 cSHAKE)中看到的扩展输出函数(xof)也可以用作 KDF！记住，XOF

*   不期望均匀随机输入

*   可以产生几乎无限大的均匀随机输出

此外，KMAC(第三章中提到的 MAC)没有我之前提到的相关输出问题。事实上，KMAC 的长度参数使算法的输出随机化，实际上就像一个额外的定制字符串。

最后，对于具有低熵的输入，存在边缘情况。例如，考虑一下密码，与 128 位的密钥相比，它相对来说是可以猜测的。用于哈希密码的基于密码的密钥派生函数(在第 2 章中介绍)也可以用于派生密钥。

## 8.7 管理密钥和机密

好了，都好了，我们知道如何生成加密随机数，我们知道如何在不同类型的情况下导出机密。但是我们还没有脱离险境。

既然我们使用了所有这些加密算法，我们最终不得不维护大量的密钥。我们如何存放这些钥匙？我们如何防止这些极其敏感的机密被泄露？如果机密泄露了我们该怎么办？这个问题通常被称为*密钥管理*。

Crypto 是一种工具，可以将一系列问题转化为密钥管理问题。

——阅读 Kissner (2019 年，[http://mng . BZ/emrj](http://mng.bz/eMrJ)

虽然许多系统选择将密钥放在使用它们的应用程序附近，但这并不一定意味着当坏事情发生时应用程序没有追索权。为了防范可能泄露密钥的最终漏洞或错误，大多数严肃的应用程序都采用两种深度防御技术:

*   *密钥轮换* —通过将到期日期与密钥(通常是公钥)相关联，并定期用新密钥替换您的密钥，您可以从最终的危害中“痊愈”。到期日期和轮换频率越短，就可以越快地替换攻击者可能知道的密钥。

*   *密钥撤销* —密钥轮换并不总是足够的，当你听到一个密钥已经被泄露时，你可能想要取消它。出于这个原因，一些系统允许您在使用密钥之前询问它是否已经被撤销。(在下一章“安全传输”中，你会学到更多。)

自动化往往是成功运用这些技术不可或缺的，因为一台运转良好的机器在危机时刻更容易正确工作。此外，您还可以将一个特定的角色与一个键相关联，以限制危害的后果。例如，您可以在一些虚构的应用程序中将两个公钥区分为公钥 1 和公钥 2，前者仅用于签署事务，后者仅用于进行密钥交换。这使得与公钥 2 相关联的私钥的泄露不会影响交易签名。

如果不想将密钥留在设备存储介质上，存在旨在防止密钥被提取的硬件解决方案。你将在第 13 章硬件加密学中了解更多。

最后，应用程序可以通过多种方式来委托密钥管理。在移动操作系统上经常会出现这种情况，即提供*密钥库*或*密钥链*，它们会为你保存密钥，甚至会执行加密操作！

位于云中的应用程序有时可以访问云密钥管理服务。这些服务允许应用程序委托密钥和加密操作的创建，并避免考虑攻击它们的许多方法。尽管如此，与硬件解决方案一样，如果应用程序受到威胁，它仍然能够向委托服务发出任何类型的请求。

注意 没有灵丹妙药，你仍然应该考虑你能做些什么来检测和应对妥协。

密钥管理是一个难题，超出了本书的范围，所以我不会过多地讨论这个话题。在下一节中，我将介绍试图避免密钥管理问题的加密技术。

## 8.8 使用门限加密技术分散信任

密钥管理是一个很大的研究领域，投资起来可能很烦人，因为用户并不总是有资源来实施最佳实践，也没有该领域中可用的工具。幸运的是，对于那些想减轻密钥管理负担的人来说，密码学有其可取之处。我要说的第一个是*机密分享*(或者说*机密分裂*)。机密分割允许您将一个机密分成多个部分，这些部分可以在一组参与者之间共享。在这里，机密可以是您想要的任何东西:对称密钥、签名私钥等等。

典型的情况是，一个叫做*经销商*的人生成机密，然后在删除机密之前，将它分割并在所有参与者之间分享不同的部分。最著名的机密分裂方案是由阿迪·萨莫尔(RSA 的共同发明人之一)发明的，被称为*沙米尔的机密共享* (SSS)的。我在图 8.11 中说明了这个过程。

![](img/08_11.png)

图 8.11 给定一个密钥和若干份额 *n* ，沙米尔的机密共享方案创建 *n* 个与原密钥大小相同的部分密钥。

当需要机密来执行一些密码操作(加密、签名等)时，所有的份额所有者需要将他们的私有份额归还给负责重构原始机密的经销商。这种方案防止攻击者针对单个用户，因为每个共享本身是无用的，相反，迫使攻击者在利用密钥之前危害所有的参与者！我在图 8.12 中对此进行了说明。

![](img/08_12.png)

图 8.12 sha mir 的机密共享方案用于在 *n* 部分密钥中分裂机密，需要所有的 *n* 部分密钥来重构原始密钥。

该方案算法背后的数学原理其实并不难理解！因此，让我在这里抽出几个段落来给你一个简化的计划的想法。

想象一条二维空间上的随机直线，假设它的方程——*y*=*ax*+*b*——就是机密。通过让两个参与者拿着线上的两个随机点，他们可以合作恢复线方程。该方案推广到任何次数的多项式，因此，可以用于将机密分成任意数量的部分。这如图 8.13 所示。

![](img/08_13.png)

图 the Shamir 机密共享方案背后的思想是将定义一条曲线的多项式视为机密，将曲线上的随机点视为部分密钥。为了恢复定义一条曲线的次数为 *n* 的多项式，需要知道曲线上的 *n* + 1 个点。比如*f*(*x*)= 3*x*+5 是 1 次，那么你需要任意两点( *x* ， *f* ( *x* ))来恢复多项式，*f*(*x*)= 5*x*<sup class="fm-superscript">2</sup>+2

 *由于其简单性，机密分割是一种经常被采用的技术。然而，为了有用，密钥部分必须被收集到一个地方，以便每次在加密操作中使用时重新创建密钥。这创造了一个机会之窗，在这个机会之窗中，机密变得容易被窃取或意外泄露，实际上让我们回到了*单点故障*模型。为了避免这种单点故障问题，存在几种在不同场景中有用的加密技术。

例如，想象一个协议，该协议只接受已经由爱丽丝签名的金融交易。这给 Alice 带来了很大的负担，她可能害怕成为攻击者的目标。为了减少攻击对 Alice 的影响，我们可以改为(在同一事务中)接受来自 *n* 不同公钥的 *n* 个签名，包括 Alice 的。攻击者将不得不损害所有的 *n* 签名来伪造一个有效的交易！这种系统被称为多重签名，在加密货币领域被广泛采用。

然而，天真的多重签名方案会增加一些烦人的开销。事实上，在我们的示例中，事务的大小随着所需签名的数量而线性增长。为了解决这个问题，一些签名方案(如 BLS 签名方案)可以将几个签名压缩成一个。这就是所谓的*签名聚合*。一些多重签名方案在压缩方面走得更远，允许将 *n* 个公钥聚合成一个公钥。这种技术被称为*分布式密钥生成* (DKG)，是被称为*安全多方计算*的密码学领域的的一部分，我将在第 15 章中介绍。

DKG 让 *n* 个参与者合作计算一个公钥，而在这个过程中没有相关的私钥(不像 SSS，没有分发者)。如果参与者想要签署消息，他们可以使用每个参与者的私有份额协作创建签名，可以使用他们之前创建的公钥来验证该签名。同样，私钥实际上从不存在，防止了 SSS 的单点故障问题。因为你在第七章看到了施诺尔签名，图 8.14 显示了简化的施诺尔 DKG 方案背后的直觉。

![](img/08_14.png)

图 8.14 schn orr 签名方案可以分散成分布式密钥生成方案。

最后，注意

*   我提到的每一个方案都可以在只有 n 个参与者中的一个阈值 *m* 参与协议时生效。这一点非常重要，因为大多数现实世界的系统都必须容忍大量恶意或不活跃的参与者。

*   这些类型的方案可以与其他非对称加密算法一起工作。例如，使用门限加密，一组参与者可以合作对消息进行非对称解密。

我在图 8.15 中回顾了所有这些例子。

![](img/08_15.png)

图 8.15 概述了将我们对一个参与者的信任分成几个参与者的现有技术。

门限方案是密钥管理领域中一个重要的新范例，跟踪它们的发展是一个好主意。NIST 目前有一个门限密码组，该组组织研讨会，并打算长期标准化原语和协议。

## 总结

*   从一个集合中均匀随机地抽取一个数，如果它与该集合中的所有其他数相比以相等的概率被抽取。

*   熵是表示一个字节串有多少随机性的度量。高熵指的是均匀随机的字节串，而低熵指的是容易猜测或预测的字节串。

*   伪随机数发生器(PRNGs)是一种算法，它采用均匀随机的种子，并且(在实践中)生成几乎无限量的随机性，如果种子足够大，这些随机性可用于加密目的(例如，作为加密密钥)。

*   要获得随机数，应该依靠编程语言的标准库或众所周知的密码库。如果这些都不可用，操作系统通常会提供接口来获取随机数:

    *   Windows 提供了`BCryptGenRandom`系统调用。
    *   Linux 和 FreeBSD 提供了`getrandom`系统调用。
    *   其他类似 Unix 的操作系统通常有一个名为/dev/ urandom 的特殊文件，它表现出随机性。
*   密钥导出函数(KDF)在想要从有偏差但高熵的机密中导出机密的场景中是有用的。

*   HKDF(基于 HMAC 的密钥派生函数)是使用最广泛的 KDF，它基于 HMAC。

*   密钥管理是保密领域，嗯，保密。它主要包括查找存储机密的位置、主动终止和轮换机密、确定机密泄露时该做什么等等。

*   为了减轻密钥管理的负担，可以将一个参与者的信任分成多个参与者。**