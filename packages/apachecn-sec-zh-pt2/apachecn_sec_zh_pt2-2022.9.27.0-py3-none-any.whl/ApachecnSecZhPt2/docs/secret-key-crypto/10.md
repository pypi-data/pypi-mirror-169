# 十、变长分段

本章 涵盖

*   基于莫尔斯电码的密码
*   混合字母和双字母
*   可变长度二进制代码字
*   基于文本压缩的密码

本章涵盖了大范围的分级密码，其中明文组和/或密文组具有可变长度。这些包括单名-双名(第 10.2 节)、霍夫曼替换(第 10.4 节)和后标签系统(第 10.5 节)。

在第 4.4 节中，我通过描述 M. E. Ohaver 的分段莫尔斯密码的两个版本说明了分段的概念。分段莫尔斯是可变长度分段的一个例子，因为它使用 1、3 和 4 符号莫尔斯组。让我用一种不同形式的莫尔斯分法来开始变长分法的更广泛的讨论，这种分法类似于 9.9 节中描述的三分密码。让我们称之为 Morse3。

## 10.1 摩尔斯 3

*Morse3* 是一个分 4 步操作的密码。(1)用莫尔斯电码组代替电文的字母。你可以使用标准的莫尔斯电码，或者像 4.4 节中那样的混合莫尔斯字母表。(2)使用 **/** 符号将莫尔斯分组分开。使用双/**/**/来分隔单词并标记消息的结束。(3)将符号分成 3 组。如果需要，添加一个额外的  或  来完成最后一组 3 个符号。收件人将忽略最后一个//后面的这些多余的点。(4)使用第二个混合字母表为每组 3 个符号替换一个字母。

为了举例说明，我将使用 4.4 节中的混合莫尔斯字母表(显示在左边)来组成莫尔斯组。这仅使用 1、3 和 4 个符号的组，但是也可以使用 2 个符号的组，可能作为零符号或同音词。从莫尔斯符号到字母的替换使用类似于三分密码 的混合字母表，除了使用莫尔斯符号 **- /** 而不是数字 0 1 2。注意 **///** 永远不会出现，所以没有必要为它提供一个字母替代。因此只需要 26 个替代品。

![10-unnumb-1](img/10-unnumb-1.png)

让我们加密发送弹药的样本信息。

![10-unnumb-2](img/10-unnumb-2.png)

如果两个替换步骤都使用混合良好的键控字母，则该密码被评为五级。Morse3 的一个缺点是密文比明文长。在这个例子中，8 个字母的明文变成了 11 个字母的 密文。

## 10.2 Monom-Binom

*Monom-Binom*，或*monol-Binom*， 是一类密码，其中每个字母由一个或一对数字代替。这些密码中最著名的是大约 1920 年至 1960 年间俄罗斯间谍使用的*维克* 密码。这个名字来源于 FBI 给克格勃间谍 Reino hayhnen 起的代号 VICTOR 。VIC 密码从未被破解，直到 1957 年海宁叛逃到美国并透露了其细节。

VIC 密码有两部分，单项式二项式 代换，以及随机数字序列的模 10 加法。让我们从单名-双名替换开始。字母表中的每个字母由 1 或 2 个十进制数字代替。为了让预期的接收者丽娃阅读该消息，选择两个数字作为所有 2-数字对的第一个数字。假设发送者桑德拉选择了 2 和 5。所有 2 位数的替代数字将以 2 或 5 开始，所有其他数字将是 1 位数的替代数字。每当消息中的下一个数字是 2 或 5 时，读者知道它是 2 位数字替代的开始，否则它是一位数字替代。这种替代可以用一个 3 行图来表示，这个图有一个特殊的名字*横跨棋盘* 。这个名字不太合适，因为这个图不是正方形的，不是 8×8 的，也没有黑白正方形交替的图案。哦，它不是用来玩跳棋的。除此之外，这是一个完美的名字。这里有一个例子:

![10-unnumb-3](img/10-unnumb-3.png)

8 个 1 位替代在最上面一行，以 2 和 5 开头的 20 个 2 位替代在第二和第三行。数字 2 和 5 不能用作 1 位数字的替代，因此这些空格在顶行被涂黑。例如，S 的替代是 4，U 的替代是 24，Y 的替代是 54。

由于英文字母表有 28 个方框，只有 26 个字母，所以我用*和#表示了 2 个额外的字符。例如，通常使用*作为通用的 标点符号。？，”或其他任何可以使信息更容易阅读的内容。#用于在字母和数字之间来回切换。今天 600 辆坦克于 18:00 到达的消息将作为# 600 # TANKSARRIVE # 1800 #发送，并将被加密为**57600 57730 21438 86251 57180 05779 58354**。

这种类型的替换的一个明显的弱点是，超过 1/3 的替换(实际上是 28 个中的 10 个，或 35.7%)以 2 开始，同样的百分比以 5 开始，所以 2 个选择的数字比其他 8 个数字中的任何一个都更频繁。他们会像华尔兹比赛中的大象一样脱颖而出。为了帮助缓解这个问题，8 个最常用的字母被放在最上面一行。这些是洋葱。为了帮助记忆，你可以使用助记符号，即去掉重复的 R 的锯齿符号。或者，你可以用我最喜欢的，老鼠噪音。用一位数代替最常用的字母也有助于减少密文的长度。

单独使用，跨骑棋盘等级为三级。

然而，维克 的密码增加了第二步。(在最复杂的形式中，它还会调换数字。)单项式-双项式 替换的结果被视为中间密文。对于中间文本中的每个数字，一个关键数字以 10 为模相加，也就是说，在没有进位的情况下相加。这有两种味道。您可以简单地添加一个重复的数字键，如 2793。工作原理是这样的:

![10-unnumb-4](img/10-unnumb-4.png)

这种形式的维克 密码被评为五级。

*****VIC 密码的一种更强形式是使用由随机数生成器产生的不重复的数字键。为此，俄罗斯人使用了所谓的*滞后斐波那契发生器* 。您可能已经熟悉斐波那契数列，它是一个整数序列，其中每一项都是前面两项之和。该序列从 x <sub class="fm-subscript">0</sub> = 0 和 x <sub class="fm-subscript">1</sub> = 1 开始。该序列的附加项由以下数学公式生成:

![10-unnumb-4-equation-10-1](img/10-unnumb-4-equation-10-1.png)

即 n 项是 n-1 项和 n-2 项之和。对于 VIC 密码，只有低阶数字是相关的。这可以写成

![10-unnumb-4-equation-10-2](img/10-unnumb-4-equation-10-2.png)

一个滞后的斐波那契生成器可以用三种不同的方式来概括这一点。首先，它可以添加后两个术语之外的术语，例如

![10-unnumb-4-equation-10-3](img/10-unnumb-4-equation-10-3.png)

注意，第 4.5.1 节中描述的链式数字发生器具有这种形式，j = 1，k = 7。

其次，可以用不同的模数生成数字。最常见的模数是素数 p 的幂 p<sup class="fm-superscript">e</sup>:

![10-unnumb-4-equation-10-4](img/10-unnumb-4-equation-10-4.png)

第三，可以使用除加法之外的二元运算符来组合这两个术语。常见的选择有减法、乘法和异或。这个可以写

![10-unnumb-4-equation-10-5](img/10-unnumb-4-equation-10-5.png)

其中 ● 可以表示+ - × ⊕ 或其他二元运算符。(除法也可以。它与乘以第二个操作数的乘法逆运算相同。参见第 3.6 节。)实际上，加法最常用，因为加法生成器生成的周期最长。

使用这种形式的伪随机数发生器，单项式 被评为 七。 ******

## 10.3 周期长度

一个 实现可变长度加密的简单方法是使用多个替换表，每个表对应一个期望的块长度。如果这些是字母块，替换表将很快变得巨大。相反，我们将使用位。让消息被表示为一个位串。通过将消息分成短的比特块，并用替换表替换相同长度的比特块，对消息进行加密。块的长度可以是周期性的，使用重复的数字键，或者它们可以由随机数发生器产生。

让我用一个小例子来演示一下。对于 2、3 和 4 比特的块，有 3 个替换表。在实际的密码中，我会使用 3、4、5 和 6 位的块，但如果有存储空间，你可以使用 16 位或更长。

在这个简单的演示中，我使用了一个标准字母表，通过从键盘最上面一行从左向右取符号来填充 32 个字符。

![10-unnumb-5](img/10-unnumb-5.png)

3 个替换表是

![10-unnumb-6](img/10-unnumb-6.png)

以下是使用重复密钥 3，2，2，4，2 的加密示例:

![10-unnumb-7](img/10-unnumb-7.png)

这个版本，我称之为标准字母表的*位块 SA* ，有适度的力量。有一个键用于混合每个替换表，还有一个额外的键用于块大小的序列。当只有几个替换表，块大小都很小，并且块大小序列很小时，位块 SA 被评定为三。否则就是评四级。

增强这种密码的一种方法是使用混合良好的键控字母，将字母转换成位，再将位转换回字母。姑且称混合字母版本*位块马* 。它被评为 七级。

## 10.4 霍夫曼替换

第 4.2 节 描述了如何使用霍夫曼码进行文本压缩。*霍夫曼替换* 是一种可以使用霍夫曼码进行加密的方式。霍夫曼替换使用两组代码。第二组中的代码替换第一组中的代码。这些可能是同一组代码，但顺序不同。

消息被表示为一串比特，例如通过使用一种标准的计算机表示，如 UTF-8 或 Unicode。这个位串从第一组霍夫曼代码中分离成一串代码，然后这些代码被第二组代码替换。霍夫曼替换不会压缩消息，尽管如果第一组中的代码与第二组中的代码具有不同的长度，则以比特为单位测量的消息长度会改变。

回想一下，一组霍夫曼码必须具有前缀属性。也就是说，一个集合中任何霍夫曼代码都不能以同一集合中的另一个霍夫曼代码开始。例如，您不能同时拥有 **1101** 和**1101****1**因为，如果您解码的字符串以 **11011** 开始，您将不会知道第一个代码是 4 位还是 5 位。有了前缀属性，就不需要像莫尔斯电码分组那样在代码之间有分隔符。

我们来看看如何用前缀属性构造一组霍夫曼码。首先按任意顺序列出单个位，即 0，1 或 1，0。举个例子，

![10-unnumb-8](img/10-unnumb-8.png)

对于此列表中的每一项，要么将其作为一个完整的代码接受，要么通过将 0 附加到一个副本并将 1 附加到另一个副本来扩展它以形成两个更长的代码，同样以任一顺序。例如，我们可以接受完整的代码 1，并扩展代码 0 以生成两个代码 00 和 01，如下所示:

![10-unnumb-9](img/10-unnumb-9.png)

这个过程可以根据需要重复多次。例如，我们可以接受完整的代码 01，但是将代码 00 再扩展一步，使代码 000 和 001。

![10-unnumb-10](img/10-unnumb-10.png)

这个过程可以继续下去，直到你有了想要的码数，或者想要的码长范围。然而，对于这个例子，4 个代码就足够了。我们将接受 000 和 001 作为完整的代码，形成一个完整的 4 个代码集。

***** 我们可以估计用这些码加密一个位串时平均码会有多长。字符串有 1/2 的机会以 1 开始，因此代码有 1/2 的机会为 1 位长。字符串有 1/8 的机会以 000 开始，有 1/8 的机会以 001 开始。在任一情况下，代码都是 3 位长。有 1/4 的机会，字符串将从 01 开始，代码将是 2 位长。这是一套完整的代码，所以没有其他的可能性。将它们组合起来得到预期的码长 1/2+3/8+3/8+2/4 = 14/8 = 1.75 比特。

第一个代码被替换后，下一个代码的概率是相同的，所以所有代码的预期长度是 1.75 比特。这小于代码的平均长度，即 2.25 位。 ******

下面是霍夫曼替换 的例子。有两套霍夫曼码。左栏中的代码被右栏中的代码替换。两组代码都具有前缀属性。明文是用标准的 5 位表示自由编码的，A = 00000，B = 000001，C = 00010，.。。，Z = 11001。

![10-unnumb-11](img/10-unnumb-11.png)

![10-unnumb-12](img/10-unnumb-12.png)

5 位组的第一行是以标准方式编码的单词 LIBERTY，A = 00000，B = 00001，依此类推。二进制的第二行是相同的位串，但是从 Set1 分成霍夫曼码。带下划线的数字 1 是填充最后一个霍夫曼代码所需的填充。二进制的第三行用集合 2 中的相应代码替换集合 1 中的每个代码，也就是说，第三行是替换步骤的结果。二进制的第四行与第三行是相同的位串，但是被分成 5 位组。请注意，第 4 行比第 1 行长 4 位。最后一行是密文，使用与字母表相同的标准 5 位表示法。密文的最后一个字母可以是 I 或 J，因为最后一个二进制组只有 4 位。

***** 如果你是用计算机做这个，就没有必要把比特串的前端和每个霍夫曼码依次进行比较。假设最长的码有 6 位。您可以创建一个包含所有 64 种可能的 6 位组合的表格。表格中的每一项都以比特表示代码的长度，并给出它的替代。每次执行替换时，使用字符串的前 6 位直接在表中查找。

比如假设第一个霍夫曼码是 00000，它的替代品是 0110。以该代码开头的字符串的前 6 位的可能值是 000000 和 000001。因此，表中的条目 000000 和 000001 都将给出代码长度为 5，该代码的替代代码为 0110。为了执行替换，您将删除字符串的前 5 位，并将 0110 附加到结果 字符串。 ******

## 10.5 张贴标签系统

数学家 1920 年，纽约大学库朗学院的埃米尔·莱昂·波斯特发明了*邮政标签系统*。基本思想很简单。你从一串比特开始。然后你从字符串的前面取一些位，用一组不同的位替换它们，并把它们放在字符串的末尾。你一直这样。三种情况中的一种会发生:要么字符串收缩到你不能再这样做，要么你进入一个无休止的重复循环，要么字符串永远增长。

抛开历史不谈

Post 并没有创造出用于加密的 Post 标签。波斯特证明了标准数学无法回答弦是增长、收缩还是重复的问题，然后他用这个事实证明了库尔特·哥德尔著名的不完全性定理。我认为这是一个比艾伦·图灵使用写在无限长的磁带上的符号的证明更简单和更优雅的证明，尽管波斯特的位串和图灵的磁带之间的相似性是惊人的。

这个*后替换* 类似于霍夫曼替换 ，只不过你把替换移到了位串的末尾。这个系统的优点是，你可以在替换了整个字符串之后继续。也就是说，你可以多次遍历字符串。这消除了霍夫曼码之间的分歧。

你从琴弦前面拿走的那片叫做*标签* 。必须选择该组标签，以便在每个步骤中最多可以取一个标签。也就是说，替换过程是*确定性的*。这要求标签集具有前缀属性。这将允许您使用标签集来加密以位串表示的消息。前缀属性将在 4.2.1 节结合霍夫曼码进行讨论。简而言之，任何标签都不能以任何其他标签开头。例如，您不能同时拥有 1101 和 1101 1，因为如果字符串以 11011 开始，您将不知道是取前 4 位还是前 5 位。有了前缀属性，标签之间就不需要像莫尔斯码组那样有分隔符了。Huffman 代码和 Post 标签具有相同的形式，但是它们的用法不同。对于初学者来说，Huffman 代码用于缩短位串，而 Post 标签则不是。

第 10.4 节描述了构建一组霍夫曼码的方法。

使用 Post 标签加密时，用另一个标签替换每个标签，并将新标签移动到字符串的末尾。由于丽娃将不得不从右边开始解密消息，替换标签将需要具有*后缀属性* ，即前缀属性的逆属性。后缀标签都不能以另一个后缀标签结尾。例如，如果 1011 是后缀标签之一，那么 0 1011 和 1 1011 都不能是后缀标签。

除了在左侧而不是右侧扩展每个标签之外，您可以用与构建前缀标签集相同的方式构建后缀标签集。如果这令人困惑，您可以构造第二组前缀标签，然后颠倒该组中的位的顺序来获得后缀标签。后缀标签的数量必须至少与前缀标签的数量相同。还可以有更多。多余的标签可以用作同音词。例如，前缀标签 0111 可以被替换为后缀标签 110 或 10101。

当后缀的预期长度小于前缀的预期长度时，字符串可能会收缩。也就是说，很可能有一些初始字符串会变得更短。相反，如果后缀比前缀长，很可能某些初始字符串会增长。当使用同音字时，通常是这样。预期长度的差异越大，初始字符串将收缩或增长得越多。然而，“可能”并不能保证。可以构造具有相反行为的前缀/后缀集。

要使用 Post 标签进行加密，首先将消息表示为一串位，然后执行几次标签替换。如果你是手工加密，你要把这些位变回字符。如果你是用计算机加密，这最后一步可能是不必要的；您只需传输产生的位串。

### 10.5.1 等长标签

一个 上一节描述的密码的问题是，丽娃不知道如何将她接收到的消息分成块。您可能需要为每个块设置一个单独的长度字段，或者将整个消息视为一个单独的块。当消息很长时，这可能会很难处理。这个问题的一个解决方案是用相同长度的后缀标签替换每个前缀标签。这样，块在整个过程中保持相同的长度，并且在划分块的末端时没有问题。典型的块大小为 32 位或 64 位。

我建议对每个区块进行固定数量的替换。您可以根据标签的最短长度和预期长度来确定合适的数量。假设块是 32 位，最短的标签是 3 位，预期的标签长度是 4.3 位。使用最短长度，如果您执行至少 32/3 = 10.67 次替换，那么您可以保证块中的每个位至少被替换一次。四舍五入到 11。使用预期长度，平均需要 32/4.3 = 7.44 次替换，以便每个比特都被替换。

一个好的安全裕度是平均每个比特被替换两次。加倍 7.44 并向上取整得到 15 个替换步骤。这大于 11，因此可以确定每个位至少被替换一次。平均来说，每一位被替换两次。大约一半的时间，一些位被替换 3 次。最重要的是，Emily 不知道任何给定的位被替换了多少次。

你可能已经注意到了，我一直在说“每个*位* 被替换”而不是“每个*标签*被替换”这可能会令人困惑。第一次通过该块时，每个标签都被一个具有相同长度的新标签所替换。所以，在第一轮，标签被替换。但是当第二轮替换开始时，它可能不会在偶数标签边界上开始。也就是说，下一个标签可以跨越第一轮中的两个或更多标签。

这里有一个小例子，用一个 12 位模块来说明这一点。块的第一位是阴影的，前缀标签是下划线的。

![10-unnumb-13](img/10-unnumb-13.png)

经过四次替换后，第一位现在位于第二个位置，正好在下一个前缀标签 011 的中央。

对于手动使用，我建议将字母表的字母编码为 5 位或 6 位组，使用 20 至 30 对 3 至 6 位的标签、32 位块和 16 个替换步骤，也就是说，通过块大约 2 次。使用 4 位组将产生的位串转换回字符，以某种混合顺序表示字母 A 到 P。这样的密码将被定为 6 级。

对于计算机使用，我建议使用标准的 8 位表示法，如 UTF-8 来表示信息中的字母、数字和特殊字符。使用 40 到 80 对 4 到 8 位的标签、64 位块和 32 个替换步骤。使用 32 个台阶足以通过该块 3 次。在进行 Post 标记替换之前，对字符执行混合良好的键控替换，在完成 Post 标记替换之后，对结果字节执行第二次独立的键控替换。这个被称为*post 64*T5】的密码将被定级为 10。它有 4 个独立的键，用于混合初始替换、最终替换、Post 标签和它们的替换。

使用后置标签替换的另一种方法是使用短的重叠块。从消息的前 4 个字节开始，执行 2 次后置替换 。假设每个标签是 4 到 8 位，这足以确保第一个字节中的所有位都已被替换。然后向右移动 1 个字节。消息的下一个 4 字节块是字节 2、3、4 和 5。再次，在该程序块上执行 2 次后置替换。继续这种方式，直到消息的最后一个 4 字节块。最后 3 个块将环绕到消息的前面。此法名为 *PostOv* ，额定 六。

### 10.5.2 不同长度标签

当 每个标签的替换长度不同时，你会陷入各种各样的复杂情况，每个块的长度会改变，并且这些块可能不会在字节边界上对齐。例如，32 位块可以变成 35 位块。这意味着丽娃将需要一种方法来分离区块。最简单的方法是传输每个块的长度。

简单地在一个块上执行后标签替换，直到它的长度再次变成 8 位的倍数，这似乎是可行的。不幸的是，这可能需要数千甚至数百万个替换步骤——或者可能永远不会发生。

最简单的解决方案是将整个消息作为一个单独的块进行加密。消息的长度告诉丽娃块中的字节数。桑德拉只需要添加一个 3 位字段来告诉丽娃最后一个字节有多少位，范围从 1 到 8 位。这可以放在消息的开头，也可以是最后一个字节的最后 3 位。长度字段可能需要一个额外的字节。

这里是一个不同长度的 Post 标签加密的例子。每个前缀标签及其产生的后缀标签都有匹配的下划线。

![10-unnumb-14](img/10-unnumb-14.png)

***** 每次标签从前面移除时，看起来你都需要移动整个信息。通过保持指针指向消息的第一位和最后一位，可以消除这些移位。每个指针只是一个整数，给出每个端点的位置。指针的低阶 3 位将给出字节内的位位置，高阶位将给出字节位置。分配 4 倍于消息长度的空间。将信息放在这个空格的开头，其余的用零填充。

要删除字符串前面的标签，只需将前面的指针增加前缀标签的长度。要将标签附加到末尾，只需将标签移动到所需的位位置，并将其与字符串的最后 2 个字节或，然后递增结束指针。继续这个过程，直到你到达空间的尽头。这意味着帖子替换 步骤的数量取决于消息本身。

最后只剩下一次移位来将位串移动到一个偶字节边界上。然而，这种长位移也可以通过告诉你的通信者在信息的第一个和最后一个字节的开始和结束比特位置来消除。这仅需要 6 位，可以打包成一个字节，放在消息的开头。我建议用一个简单的替换来加密这个字节，这样就不会给 Emily 起始和结束位置。此外，一定要用随机位填充消息的第一个和最后一个字节中未使用的部分。

还有一个问题:既然丽娃不知道消息的原始长度，因此也不知道加密空间的原始大小，她怎么知道何时停止解密呢？丽娃不知道进行了多少替换步骤，她不能简单地分配 4 倍于所接收消息长度的空间，因为这可能与所发送消息的长度不同。

下面是方法。丽娃知道三件事:明文消息开始于字节边界，消息结束于字节边界，加密空间是原始消息长度的 4 倍。丽娃可以从将接收到的消息放在一个 5 倍于密文消息长度的空格的末尾开始。这应该足够了。丽娃向后工作，直到满足三个条件，特别是直到从部分解密的消息的开始到解密空间的结束的距离正好是消息长度的 4 倍。这只能发生一次。 ******

我建议你使用 50 到 80 对标签，每个标签 4 到 8 位长。原始标签的预期长度在数值上应该接近替换标签的预期长度。大约替换标签的 1/3 应该更短，1/3 应该相同大小，1/3 应该比原标签更长。不要坚持让每个标签的长度都和它的替代标签不同。消息字符应该用混合字母表中的 8 位字节表示。如果标签的预期长度是 T 比特，消息的长度是 L 比特，那么至少应该进行 3L/T 替换步骤。也就是说，你要把整个信息看 3 遍或更多遍。最后的位串，包括长度指示符，应该使用第二个独立的键控简单替换转换回字符。如果所有这些建议都被采纳，那么这个名为*PostDL*T5】的密码被评为十级。

当你读到第 12.6 节时，你会看到 PostDL 密码并不满足保证不可破解密码的所有标准。它得到 10 分的原因是 Emily 不知道任何给定的明文比特将在密文中的何处结束。每个街区的位置都不同。所以艾米丽不能建立明文比特和密文比特之间的对应关系，因此不能建立将密文比特与明文和密钥 T5】比特相关联的等式。

### 10.5.3 多个字母

你可以做几件事来加强 Post 标签密码或 Huffman 替代密码 。我们已经看到了多轮替换。另一个技巧是使用多个字母。每个字母表将由一组具有前缀属性的标签和相应的一组替换标签组成，替换标签必须具有后缀属性。您可以简单地轮流使用多个字母，或者您可以使用关键字在它们之间进行选择。如果你是手工操作，你不会想要超过 2 个，或者最多 3 个这样的字母，所以我建议使用数字键，比如 01101011。

这些密码可能被称为 *PolyPost* 和 *PolyHuff* ，根据回合数、字母数和密钥 长度被分为四到八个等级。

### 10.5.4 短距离和长距离移动

所以 到目前为止我们已经假设当一个 Post 标签有 B 位时，这 B 位被移动到块的末尾。然而，移动少于 B 位或多于 B 位是可能的。例如，您可以移动 B-1 位，留下 1 位作为下一个标签的一部分再次被替换。这使得标签重叠。优点是它隐藏了标签之间的边界。缺点是每轮需要更多的替换步骤，使得加密速度变慢。

相反，当 Post 标签有 B 位时，你可以将 B+1 位移动到块的末尾。这使得一个位保持不变，并且该位始终是块中的最后一位。如果密码有多轮，这不是一个严重的问题，因此未改变的位可能会在其他轮中被替换。仍然有机会让一些位元完整无缺地通过这个密码。如果 Emily 不能确定哪些是未改变的位，这并不是一个严重的缺点。位匿名。没有任何关于任何位的说明，“这个位来自明文中的字节 5，位位置 2。”

最后，可以使移动的位数与标签的长度无关。你可以有一个表格，告诉移动的位数。这可以小于、大于或等于标签的长度。你可以每样吃几个。

当移动的位数与标签的长度不同时，后缀属性不再适用于替代标签集。相反，实际移动的那组位串必须具有后缀属性。例如，如果标签 0110 被替换为 1101，但是移动了 5 位，那么后缀字符串集必须包括**1101**0T5】和 T7】T8】11011。

## 10.6 其他基础中的分段

所以至此，本章已经讨论了以 5 为基数的 monom-binom ，以 2 为基数的 Huffman 和 Post substitution 。也可以在其他碱基中进行变长替换。对于手工加密，在基数 3 或基数 4 中进行霍夫曼替换和后置替换比在二进制中更容易。然而，可变长度替换可以在任何碱基中进行，甚至是像 11 或 13 这样的奇数碱基。这可以给你额外的替代品，可用于同音字或编码二元。

以 13 为基数工作时，可以用 16 位十六进制中的任意 13 位进行替换，剩下的 3 位为空。如果做得好，所有 16 位数字具有大致相等的频率和分布，Emily 将无法从空值中分辨出有效数字。

## 10.7 文本压缩

第 4.2.1 节 讨论了使用霍夫曼码压缩文本。几种强大的加密方案都可以基于文本压缩。在这一节中，我将介绍几种更高级的文本压缩方案和一些基于霍夫曼码的加密方案。第 10 章的其余部分是可选的。如果在任何一点上数学变得太令人生畏，直接跳到下一章。

![10-unnumb-15](img/10-unnumb-15.png)

### 10.7.1 Lempel-Ziv

*伦佩尔-齐夫*文本压缩方案是由以色列计算机科学家亚伯拉罕·伦佩尔和雅各布·齐夫于 1977 年开发的，名为 *LZ77* ，1978 年有了改进版本，名为 *LZ78* 。它基于与霍夫曼编码相同的基本概念，即字母和字母组合由二进制代码表示，即由比特组表示。然而，伦佩尔-齐夫对此采取了相反的方法。霍夫曼使用较短的代码，以节省空间。伦佩尔-齐夫公司使用长度大致相同的代码，但为了节省空间，有些代码代表更长的字母组合。

霍夫曼和伦佩尔-齐夫在另一种意义上也是对立的。Huffman 将代码的长度建立在一个固定的字母频率表的基础上。莱姆佩尔-齐夫在对文本进行编码时，会动态地确定最常见的字母组合。这就是所谓的*自适应编码*T3。霍夫曼编码只适用于单一语言的文本。不同的语言会有不同的字母频率。即使从大写字母转换成大小写混合的文本，也需要一组不同的霍夫曼代码。相比之下，伦佩尔-齐夫可用于任何类型的计算机文件、任何语言或混合语言的文本、计算机代码、图像、遥测技术、音乐视频等。

伦佩尔-齐夫有几个版本。我在这里介绍的版本，叫做*伦佩尔-齐夫-韦尔奇* ，或者 *LZW* ，是由斯佩里研究公司的特里·韦尔奇在 1984 年开发的。LZW 有固定宽度和可变宽度版本。我现在展示的是可变宽度版本，它很容易适应加密应用。

所有版本的伦佩尔-齐夫都使用一个由字母和字母组合组成的列表，称为*字典* 。字典是随着算法在文件中的进展而动态构建的。在 LZ77 和 LZ78 版本中，字典开始是空的。任何给定字母组合的代码都是它在字典中的位置。

LZW 首先给文件中的每个字符分配一个代码。LZW 码都有相同的位数。例如，如果文件是一条英文消息，全部大写，没有 标点符号或单词分割，那么您将需要 26 个代码，因此您可以使用 5 位代码。更常见的是从 256 个代码开始，一个 8 位字节的 256 个可能值中的一个。

随着算法在文件中前进，它寻找字典中没有的字母组合。当它找到一个时，它会将该组合添加到字典中。例如，假设算法在文件中找到了，并且已经在字典中。假设文件中的下一个字母是 M，而它们不在字典中。它输出的代码后跟 M 的代码，并将它们添加到字典中。它们的代码是字典中的下一个可用位置，比如 248。

由于已经在字典中，该算法不会查找以 HE 或 e 开头的组合。它将从 M 开始查找另一个不在字典中的组合。如果该组合是 MOR，则 MOR 被放入字典条目 249 中，并具有代码 249。下次算法在文件中找到它们时，它将被编码为 248，而 MOR 的下一次出现将被编码为 249。

当算法填满 8 位代码的所有 256 个字典条目时，下一个分配的代码将需要有 9 位。此时，算法将从 8 位代码切换到 9 位代码。它们仍然具有代码 248，但是它将是 9 位代码 011111000，而不是 8 位代码 11111000。当算法填满 9 位代码的所有 512 个字典槽时，它们的代码变成 10 位代码 0011111000，仍然是 248。请注意这些操作的顺序。当前字母组合的代码首先以旧尺寸输出，然后新的组合被添加到字典中，并且代码尺寸增加。桑德拉和丽娃必须使用相同的顺序，否则邮件将无法正确解压缩。扩大代码通常在 12 位停止。将代码大小从 12 位增加到 13 位通常不会改善压缩，甚至可能会使其恶化。

让我们来看一个例子。让我们用这个算法对 TETE-TETE 这个词进行编码。假设字典从单个字母 A、E 和 T 开始，使用 2 位代码。让我们随着字典的建立而变化。在每个阶段，左边的位串显示编码的字，而右边的字母显示字的剩余部分。

![10-unnumb-16](img/10-unnumb-16.png)

当丽娃解压缩信息时，字典必须以完全相同的方式建立。注意，位串**10****01****011****000****011****011**本身不足以让丽娃对消息进行解压缩。她还需要知道代码 **00** 、 **01** 、 **10** 分别代表 A、E、t 三个字符。

好的。这就是伦佩尔-齐夫压缩法。这是一本关于密码学的书。如何将伦佩尔-齐夫压缩用于加密？

在建立字典的过程中，伦佩尔-齐夫按顺序分配代码。第 43 个字母或字母组合将获得代码 42(而不是 43，因为代码从 0 开始)。要使用此方案进行加密，请向字典中添加第二列。第一列包含字母组合，第二列包含相应的代码。不使用字典中的位置作为每个字母组合的代码，而是使用字典第二列中的数字。

假设字典以 256 个单字节字符开始。第一列将包含字符。在第二列中，将数字从 0 到 255 按某种顺序排列。它们可以通过第 5.2 节中描述的任何方法混合。桑德拉和丽娃必须使用相同的顺序，这可以通过关键字或随机数生成器的种子来确定。当需要第一个 9 位代码时，接下来的 256 个字典条目将以加扰的顺序从 256 到 511 获得代码。同样，当您从 9 位代码移动到 10 位代码时，将同时分配下 512 个代码。批量分配代码比一次分配一个代码更有效。

批量分配代码的另一种方法是使用关键字或随机数序列只分配前 256 个代码。此后，通过将 256 加到先前的代码 256 条目来计算每个新代码。即 X(N) = X(N-256)+256。

这个密码，我称之为*伦佩尔-齐夫替换* ，被评为三级。评级如此之低是因为消息的前几个字符基本上是用简单的替换加密的。每个代码代表一个字符，直到第一个重复的二元模型出现。这可能不会发生，直到 30，40 或更多的字符已被编码。即使在这之后，大多数 9 位代码将代表单个字母。这些代码很容易区分，因为它们是唯一以 0 开头的 9 位代码。艾米丽将有大量的机会使用信件频率和联系频率来破解信息。

为了使伦佩尔-齐夫替换 更强，你可以增加第二个替换步骤。这种替换不应该在字节边界上。我建议用 7 位组。这些组将不会与代码组一致，直到代码达到 14 位。这可能永远不会发生，因为代码通常限于 12 位。伦佩尔-齐夫替换后接 7 位替换被评定为 6。这两种替换都可以在一次从左到右的 传递中完成。

### 10.7.2 算术编码

*算术编码* (读作“a-rith-MET-ic”)是我在 70 年代发明的一种文本压缩方法(使用固定精度寄存器的算术流编码， *IEEE Trans。关于信息。理论*第 25 卷(1979 年 11 月)，第 675—672 页)。它基于麻省理工学院的彼得·埃利亚斯的一个聪明的想法。

Elias 的想法是将每个字符串编码成一个分数。想象一下从. 0 到. 999 所有可能的分数...省略号...意味着这个分数以一个无限的 9 序列结束。现在根据字符串的第一个字符划分这个范围。为了简单起见，让我们假设字母表中有 25 个字符，就像波利比乌斯正方形字母表一样。每个字母会得到全音域的 1/25。那些以 A 开头的字符串得到范围的前 1/25，即 4%，即. 0 到. 04。以 B 开头的字符串得到范围的下一个 1/25，即. 04 到. 08。以 Z 开头的字符串得到. 96 到. 999 范围的最后 1/25...。(为了便于阅读，我用十进制符号给出了这个例子。在计算机中，会用到二进制分数。)

对于第二个字符，你再次划分这个范围。以 AA 开头的字符串的范围是. 0 到. 0016。以 AB 开头的字符串的范围是. 0016 到. 0032。以 BA 开头的字符串的范围是. 0400 到. 0416。诸如此类。以 ZZ 开头的字符串将得到从. 9984 到. 9999 的范围...。

为了形象化这一点，让我们用一个小型的 5 个字母的字母表，其中 A 从. 0 到. 2，B 从. 2 到. 4，C 从. 4 到. 6，D 从. 6 到. 8，E 从. 8 到. 999。...。使用这个字母表，让我们给单词 BED 编码。

![10-unnumb-17](img/10-unnumb-17.png)

BED 可以编码为任意分数 f，其中. 384 ≤ f < .392。随着更多字符的添加，这个间隔将继续缩短。

就是这个概念。然而，这种将字符串编码成分数的方式并没有带来任何压缩。还需要一个想法来获得压缩。不要给字母表中的每个字母相同的分数，而是让分数与该字母的频率成比例。a 会得到 8.12%，B 会得到 1.49%，通过 Z，会得到 0.07%。A 的范围是. 0 到. 0812。B 的范围是. 0812 到. 0961。Z 的范围是. 9993 到. 9999...。

理论上，这将基于单个字母的频率给出最佳压缩。不幸的是，有一个实际问题。该方法产生的分数可能需要数千甚至数百万位数字。这样的分数如何在计算机中表示出来？你如何对它们进行算术运算？

所以，这个方法在理论上很棒，但在实践中似乎不可行。它似乎需要无限精确的分数。长分数(无论是十进制还是二进制)的加法和乘法所需的时间随着它们的长度而增加，所以即使有一种好的方法来表示这些分数，这种方法也是不切实际的慢。

我找到的解决方案是使用一个移动窗口，所有的运算都在这里完成。允许你使用普通的 32 位整数。不需要浮点运算。为了将整数保持在 32 位的范围内，字母频率被近似为 15 位整数，即 N/2 <sup class="fm-superscript">15</sup> 或 N/32768 的一部分。例如，字母 A 的频率是 8.12%。这可以表示为 2660/32768，或者 665/8192。这种近似被发现不会引起可检测的压缩程度的降低。

这里有一个十进制的例子来说明一个字母是如何编码的，以及移动窗口是如何工作的。假设前几个字符已经编码，现在的范围是. 784627 到. 784632。范围开始和结束的前 4 位数字相同，即. 7846。这 4 个数字将被输出，并且窗口将被向右移动 4 个数字以显示范围. 2700 到. 3200。

![10-unnumb-18](img/10-unnumb-18.png)

这个范围的宽度是. 0500。假设消息中的下一个字符的频率是. 0300，其范围是. 4050 到. 4350。该字符通过选择当前范围. 2700 到. 3200 的一部分来进行编码。它的宽度是. 0500×.0300，也就是. 0015。它将从 0.2700+. 0500×0.4050 运行到 0.2700+. 0500×0.4350，即 0.29025 到 0.29175。请注意，这个范围的宽度是. 0015，与预期的一样。

![10-unnumb-19](img/10-unnumb-19.png)

由于该范围的起点和终点都以数字. 29 开始，所以这些数字可以输出。现在已经输出的数字是 784629。窗口现在可以再向右移动 2 位数，使当前范围为. 0250 到. 1750。

算术编码非常适合加密，因为每个字母或字母组合不再有离散的代码。没有边界可以将比特流分成单独的代码。相反，每个字母的代码影响所有后续字母的表示方式。

既然我们已经了解了算术编码方法的工作原理，下一步就是看看如何使用它进行加密。我们不想改变分配给每个字符的范围的百分比，因为那样会失去压缩。相反，我们可以改变字符的顺序，使每个字符的范围落在整个范围中不可预测的部分。也就是说，艾米莉无法预料。例如，仅使用字母 A、B、C、D、E，范围可能是:

![10-unnumb-20](img/10-unnumb-20.png)

这些间隔可以用来对信息的字母进行编码。姑且称这种方法为*算术加密* 。因为 Emily 不知道任何范围的起点或终点，所以没有攻击的机会。的确，Emily 知道第一个范围从. 0 开始，最后一个范围在. 999 结束...，但是 Emily 不知道这些范围代表哪些字符。

算术编码有一个尚未讨论的困难。使用正常的字母表，丽娃不知道消息在哪里结束。代表圆形的相同代码也可以代表圆形、圆形、圆形、无限，假设 A 的范围从 0 开始。对于传统的算术编码，这个问题可以通过使用各种方式对消息长度进行编码并将该长度代码附加到密文上，或者通过将特殊的消息结束字符添加到字母表上来解决。之前没有讨论这一点，因为算术加密不需要它。

有了算术加密，你所需要做的就是将一个罕见的字符，或任何在信息末尾很少出现的字符，分配给第一个范围，即从. 0000 开始的范围。然后当丽娃看到圆圆时...或圆形###...消息在哪里结束是显而易见的。

如本文所述，算术加密使用 26 个字母的字母表被评为 5 级，使用 256 个字符的字母表被评为 6 级。所有常用的伎俩都可以在这里使用，null，同音字和双字母。使用空值会降低或破坏压缩，所以我不建议这样做。使用同音词的效果是将一个字母的音域分成两个或多个独立的音域。这使得字母的范围更加均匀，相当于使字母频率变平。这可以在不影响压缩程度的情况下提高安全性。使用二元模型，甚至三元模型，有时可以提高压缩级别，同时提高安全性。使用同音字和双字母，算术加密被评为八级。

因为算术加密本身就很强大，所以只需要很少的额外工作就可以把它提升到 10 级。我建议使用周期为 4 的通用多字母密码，也就是说，用四个独立的混合良好的字母轮流替换。周期为 4 或更高的普通多字母加密后的算术加密被评为 10 级。它让对手一无所获，没有字母频率，没有接触频率，也没有办法利用可能的 单词。

### 10.7.3 自适应算术编码

伦佩尔-齐夫 对任何类型的文件都能给出像样的压缩，因为它是自适应的。Huffman 编码和算术编码给出了更好的压缩，但是只针对字符频率与底层频率表匹配的文件。有几种方法可以使霍夫曼编码和算术编码自适应，并且它们都使相应的加密方法更强。所有这些方法都包括在编码时对文件中的字符进行计数。

字符数与文件中的字符频率越匹配，压缩效果就越好。您可能会认为您可以计算文件中的所有字符，然后使用实际的计数。问题是丽娃无法计算文件中的字符数。丽娃必须使用和桑德拉相同的频率，否则她无法破译文件。解决这个难题的方法是，桑德拉在加密时计算字符数，丽娃在解密时计算字符数，这样他们在所有阶段的计数都相同。

所有字符数从 1 开始。如果您事先知道字符的频率，即使它们只是粗略的估计，您也可以为更频繁的字符增加计数。例如，如果您使用 256 个字符的字符集，并且您希望消息包含大约 1%的大写 E 和大约 10%的小写 E，那么您可以将 E 的字符数增加 2，将 E 的字符数增加 25，也就是 256 的大约 10%。每个字符的初始范围与其初始计数成比例。例如，如果 256 个字符的总计数为 500，小写 e 的初始计数为 25，那么 e 将得到一个 25/500 的范围，即. 05。

有两种调整代码的基本方法，字符模式和批量模式。字符模式仅适用于算术编码。在字符模式下，每次在文件中找到一个字符，它的范围和两个相邻的范围都会被调整。(当字符有第一个或最后一个范围时，是一个相邻的范围。对于表示 A 或 z 的 26 个字母的标准字母表)

这里有一个例子。假设已经遇到了字母 T，并且相邻的范围属于字母 S 和 u。(对于算术加密 ，这可能不是这种情况)。混合字母表可能不会按顺序连续包含 S、T、U。)假设 S、T 和 U 的字符数分别为 15、20 和 5，那么它们总计为 40。假设 S、T 和 U 的范围是. 062、. 074 和. 024，那么它们的总和是. 160。这一合并范围以 15:20:5 的比例重新分配。s 得到. 160×15/40，即. 060。t 得到. 160×20/40，或. 080。u 得到. 160×5/40，或. 020。随着时间的推移，字符的范围将收敛到正确的宽度。

字符模式对 26 个字母的字母表相当有效。对于 256 个字符的字母表，它的效果很差。256 个字符中的大部分不会与任何高频字符相邻，因此它们的频率将保持不变。对于所有字母都聚集在一起的标准 ASCII 表示来说尤其如此。

批处理模式对算术编码和霍夫曼编码都有效。在批处理模式下，整套范围在编码过程中的特定点进行调整。例如，可以在编码 64 个字符之后、128 个字符之后、256 个字符之后等等调整范围。在这些点中的每一个点上，整个范围将根据当前的字符计数被重新分配。这比字符模式收敛得更快，但是在重新分配之间，您使用的是旧的、未调整的频率。

在批处理模式下，可以计算二元模型甚至三元模型的频率。出现不止一次的二元模型或三元模型可以被赋予它们自己的霍夫曼代码或算术代码范围。通过这种改进，算术编码几乎总能比伦佩尔-齐夫算法提供更好的压缩效果。

计算二元模型和三元模型的频率有一个问题，即存储。256 个字符的字母表有 65，536 个不同的二元模型和 16，777，216 个不同的三元模型。如果存储空间充足，这可能不是问题。如果存储空间有限，一个解决方案是只计算包含最频繁字母的二元模型和三元模型。例如，如果二元模型和三元模型被限制为 20 个最常见的字符，那么将只有 400 个二元模型和 8，000 个三元模型要计数。为了确定最频繁的字符，二元模型和三元模型频率的计数可以被推迟，直到某个固定数量的单个字符被编码，比如 256 或 1024 个字符。

完成这些受限计数的一种方法是只对第一批中的单个字符进行计数，以建立最频繁出现的字符。使用那些高频字符在第二批中计算二元模型。仅使用一个高频二元模型加上一个高频字母来计算第三批中的三元模型。一旦选择了高频二元模型和三元模型，它们就会被赋予自己的霍夫曼代码或算术范围。换句话说，它们被视为单个字符。

对于算术编码，字符模式和批处理模式并不互斥。您可以在遇到每个字符时立即平衡其范围，并在每个批次结束时平衡扩展的字符集以及二元模型和三元模型。

进行霍夫曼加密或算术加密 时，在每批结束时，在代码被替换或范围被重新平衡之前，字母应该被重新洗牌。如果二元模型或三元模型被添加或删除，这是特别需要的。这意味着在密码改变之前，艾米丽只有有限的材料可以攻击。对于加密来说，使用不规则的长度可能更好，比如在 217 个字符之后，然后在 503 个字符之后，等等，这样艾米丽就不知道代码何时改变。

自适应编码的另一个改进是在范围被重新平衡后将所有计数除以 2。这使得代码适应字符频率变化的情况。旧频率对范围的影响较小，新频率的影响较大。例如，假设文本是不同作者的一本故事书。每个作者可能有不同的词汇或不同的主题，甚至用不同的语言写作。

当然，桑德拉和丽娃必须事先就这一切达成一致，以便丽娃能够正确地破译和解压缩消息 。