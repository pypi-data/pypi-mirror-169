# 十二、安全加密原则

本章涵盖

*   安全加密的五大原则
*   大块长键
*   混乱，或非线性
*   扩散和饱和

让我们把我们在第 11 章中学到的所有东西集中起来。在 12.1 至 12.5 节中，我们将提炼出使分组密码安全的 5 个基本原则。安全块密码的一个特点是，改变密钥中的任何一位或明文中的任何一位，都会导致密文块中大约 50%的位发生变化，最好是随机变化。更改任何其他位也会导致密文块中约 50%的位发生变化，但模式不同。让我们称之为*五五开*财产。本章将描述如何实现这一点。

## 12.1 大块

我们 已经看到，通过编译二元组频率和联系频率，二元组密码可以像简单的替换密码一样被求解。这也可以用于三元组和四元组，尽管需要大量的密文。对于手工完成的块密码，应该考虑的最小块大小是 5 个字符。对于计算机密码，最小的块大小是 8 字节。大块大小的一个目的是防止 Emily 像解代码一样解密码。也就是说，Emily 会找到重复的密文块，并从它们的频率和它们在消息中的位置推断出它们的含义。举一个极端的例子，如果块大小是 1 个字符，那么无论密钥有多大，使用了多少加密步骤，密码仍然只是简单的替换。

英语中有许多 8 个字符的序列，它们在一条长消息中反复出现。这里有十几个例子，用了省略号...来表示空白空间。

![12-unnumb-1](img/12-unnumb-1.png)

今天的标准块大小是 16 字节。没有那么长的高频英语短语。可能有一些长的上下文短语，如美国政府、执行委员会、国际水域等等。然而，为了产生重复的密文块，这些明文重复必须以同样的方式与块边界对齐。例如，16 字节的明文块统一了 **...** 州 **...****...**状态状态状态**...使用强分组密码时，GOV 不会产生可识别的密文重复。**

使用分组链接(第 11.9 节)时，重复密文分组的问题消失了。通过块链接，任何 8 字节或更长的块都可以被 使用。

## 12.2 长按键

我们 知道一个安全的密码必须有一个大的密钥来防止暴力攻击。目前的标准是 128 位密钥。如果你需要你的信息保持 20 年或更长时间的机密，我推荐最少 160 位。这相当于大约 48 个十进制数字、40 个十六进制数字或 34 个单字母。

如果你是手动输入，我建议你用统一的方式来组织你的按键。将密钥分成大小相等、格式一致的块。这里有两种统一结构的键。在第一种风格中，每个块中的所有字符都是相同的类型，大写字母、小写字母或数字。在第二种样式中，块具有相同的格式，2 个大写字母和 3 个数字。

![12-unnumb-2](img/12-unnumb-2.png)

这两个密钥的第一个大约相当于 191 位，第二个大约相当于 174 位。对于像这样的长键，你必须能够在打字的时候看到字符，这样你就可以在需要的时候检查和修改。当密钥完成时，应用程序应该显示一个校验和，这样您就可以验证密钥是否正确。

这种规律性的一个优点是它可以防止把字母 O 误认为数字 0，或者把字母 I 误认为数字 1。我不建议随意混用人物，像**$ v94H；t}=Nd^8** ，因为它导致错误。如果您有一个使用密钥 **$v94H 加密的数据文件；t}=Nd^8** 你用密钥 **$V94H 解密；t}=Nd^8** ，数据文件现在可能无法恢复。你可能永远也不会知道哪里出了问题，如何解决。在您的密钥中使用统一的块有助于防止此类灾难。

另一种有助于防止打字错误的方式是人工单词。编造你自己的发音字母组合，像这样:

![12-unnumb-3](img/12-unnumb-3.png)

尽量避免模式，比如使用相同的元音组合，**palek mafner vadel glabet**等等，所有的单词都使用 A-E 元音模式。

这些字母数字键可以通过软件转换成二进制形式。**马德**波纹密码 (第 11.8 节)非常适合这项任务。

为每个加密的消息或数据文件键入关键字的另一种方法是使用*关键字管理器* 来生成关键字，并将它们与消息或文件相关联。关键字管理器可以安装在桑德拉和丽娃都可以访问的网站上。本书不涉及这个话题。注意，关键字管理器不同于密码管理器，因为在不同计算机上工作的桑德拉和丽娃必须对每个文件使用相同的关键字。

### 12.2.1 冗余键

在 中，在某些情况下，艾米丽有可能设计出将密文与明文和密钥联系起来的方程。如果 Emily 知道或者能够猜出一些明文，这些等式可能使她能够确定密钥。例如，她可能知道一些信息以全大写字母 ATTENTION 开始。当使用 8 字节的块大小时，这可能足以让她解决 64 位的密钥。

挫败这种潜在攻击的一种方法是扩大密钥。例如，如果块的大小是 64 位，但密钥大 32 位，即 96 位，那么平均来说，您会期望有大约 2 个 <sup class="fm-superscript">32 个</sup>可能的密钥将已知的明文转换成密文。艾蜜莉需要从这些 T4 的解决方案中筛选出正确的一个。这可能是一项艰巨的任务，因为超过 4，000，000，000 种可能性中的许多可能看起来像似是而非的文本。

扩大密钥会使 Emily 的任务更加困难，但不一定不可能。如果她有两倍多的已知明文，那么两个密码块的方程可以用来求解密钥。然而，有这么多已知的明文的情况要少得多，而且解两倍的方程可能要比仅仅解两倍的方程花费更长的时间。根据 Emily 使用的方程类型，求解一组 64 个方程可能可行，但求解一组 128 个方程则不可行。

如果 Emily 没有可解的方程，那么多余的密钥会使暴力攻击变得更加困难和昂贵。不管怎样，多余的钥匙让艾米丽 更难工作 。

## 12.3 困惑

在 1945 年信息论的创始人 Claude Shannon 描述了一个强密码必须具备的两个特性。他把这些*混乱* 和*扩散* 。香农所说的混淆是指明文和密文之间不应该有很强的相关性。同样，密钥和密文之间也不应该有很强的相关性。香农所说的*扩散* 是指密文的每一部分都应该依赖于明文的每一部分和密钥的每一部分。

除了香农的两个特性之外，我还要增加第三个特性。我称这个属性为*饱和度*。其思想是测量密文的每个比特或字节对明文和密钥的每个比特或字节的依赖程度。饱和度越大，密码越强。本节和下面两节将详细讨论这三个属性:混淆、扩散和饱和。

分组密码中使用两种类型的替换，固定的和键控的。键控替代是可变的，可以针对每个消息甚至每个块进行更改。第 11.6 节讨论了这些方法的利弊。如果你决定使用键控替代，或者如果你觉得这一节的数学很难，那么你可以跳到第 12.4 节。您可以使用 5.2 节和 12.3.7 节中描述的 SkipMix 算法构建混合字母表或 tableau，并使用伪随机数发生器选择跳过的顺序。

从香农的角度来看，混乱基本上是线性与非线性的问题。如果你的分组密码使用固定的字母表或表格，线性是最重要的。线性代数的整个领域是基于线性的概念。术语*线性*T3 来自解析几何。直线的方程式是 ax+by = c，其中 a、b 和 c 是常数，变量 x 和 y 代表直线上一点的笛卡尔坐标。如果直线不平行于 y 轴，方程可以表示为 y = ax+b。ax+by = c 和 y = ax+b 都是线性方程或线性关系的例子。

凯撒密码 (第 4.2 节)是线性密码的一个例子。凯撒密码可以看作是将密钥加到明文上得到密文，c = p+k .这里 c 是密文字母，p 是明文字母，k 是密钥。关键是字母表移动了多少。朱利叶斯·凯撒使用了 3 个位置的移位，这意味着字母表中的每个字母都被 3 个位置之后的字母取代，c = p+3，靠近字母表末尾的字母绕到前面。

顺便说一句，凯撒的方法远没有听起来那么弱，因为凯撒用希腊字母用希腊语写下了他的信息。在凯撒的时代，受过良好教育的罗马上层阶级，像凯撒和他的将军们一样，都懂希腊语，就像 19 世纪英国上层阶级学习拉丁语，俄罗斯贵族讲法语一样。

在包括替换步骤和转置步骤的分组密码中，如果单独的替换是非线性的，则密码整体上是非线性的。事实上，如果分组密码具有多轮替换，如果只有一个早期的轮是非线性的，则密码整体上是非线性的，只要该轮涉及块中的所有单元。一旦失去线性，就无法在下一轮中恢复。让每一轮都是非线性的会强得多，但即使只有一轮非线性也比一轮都没有强，尤其是在接近开始的时候。

有线性和非线性之分。替代可以是高度线性的、弱线性的、弱非线性的或高度非线性的。每一种都举一个例子来说明这一点。我在每个字母在明文字母表中的位置和它在密文字母表中的位置之间画了一条线。你可以马上看到，随着替换变得更加非线性，字母表的混合变得更好。

![12-unnumb-4](img/12-unnumb-4.png)

在下面的讨论中，我把 S 盒的输入称为明文和密钥，把输出称为密文。这些术语指的是单个 S 盒的明文和密文，而不一定是整个多轮分组密码的明文和密文。在一些分组密码中，S 盒没有密钥，它们仅仅执行简单的替换。在这种情况下，您可以想象 S-box 有一个常数值为 0 的密钥，或者 S-box 密钥的长度为 0 位。

这里假设 Emily 能够测试 S 盒的线性度，因为密码已经公开，或者她已经获得了设备的副本。如果 Emily 所能得到的只是第一轮的输入和最后一轮的输出，那么线性测试可能是不可行的。

### 12.3.1 相关系数

There 是一种公认的统计方法，用于检验两个数值变量之间的相关性。例如，您可以测试以摄氏度为单位的每日温度和以小时为单位的日照之间的相关性。温度和小时是数字变量。你可以做多次试验，在一天中的某个固定时间测量温度，并记录当天的日照时间。这会给你两个数字列表，一个是温度列表，另一个是日照时间列表。该统计测量这两个数字列表之间的相关性。

在我们的例子中，两个变量是明文字母和密文字母。“试验”是字母表中的位置。例如，第一次试验可能是“A”，最后一次试验可能是“Z”。字母表中的字母需要以某种方式编号。编号将取决于字母表的大小。例如，一个 27 个字母的字母表可以用 3 个三进制数字来编号，就像我们在 9.9 节中对三裂密码所做的那样。相关可以在明文字母的任何三进制数字和密文字母的任何三进制数字之间。在接下来的两节中，我将详细讨论 26 个字母的字母表和 256 个字符的字母表。

通过计算两个变量之间的相关性来测量线性度。到目前为止，最广泛使用的相关性度量是皮尔逊积矩相关系数，它是由生物统计学的创始人、英国数学家卡尔·皮尔逊开发的，并于 189 年 5 发表，尽管该公式本身是由法国物理学家奥古斯特·布拉维于 1844 年发表的，他因在结晶学方面的工作而闻名。相关系数的目的是用一个单一的数字来表示两个变量的相关程度，这个数字具有相同的意义，不管测量单位或涉及的数字大小如何。

如果两个变量有线性关系相关性为 1。如果变量之间没有任何相关性，则相关性为 0。如果两者成反比，则相关性为-1。例如，一枚硬币抛 20 次，正面的数量与反面的数量成反比。0.8 的相关性表示强线性关系，而 0.2 的相关性表示该关系高度非线性。

和大多数教科书一样，我不是仅仅介绍这个公式，而是要解释它是如何工作的以及为什么工作。了解它的工作原理将有助于你恰当、正确地使用它。

这里的目标是比较两个变量。这是通过比较一组试验的值序列来完成的。例如，我们可能想要比较波斯伊斯法罕的 Qeisarieh 集市上出售的魔毯的价格和尺寸。影响魔毯价格的因素有很多，包括纱线的种类、结的密度、设计的复杂程度，当然还有空速。

居中

比较变量的第一步是把它们并排放在一起，就像你用肉眼比较它们一样。换句话说，您希望消除线性关系 P = mA+x 中的+x 项，其中 P 是价格，A 是面积。看起来你可以得到 P <sub class="fm-subscript">i</sub> -A <sub class="fm-subscript">i</sub> 的差，然后从 P 中减去平均差。然而，这没有意义，因为 P 和 A 使用不同的单位。地毯面积 A 以平方*阿尔萨尼*(大约一米)计量，而集市上的地毯价格 P 以*托曼*(波斯货币)计价。

你需要分别调整面积数字和价格数字，因为它们是不同的单位。诀窍是取平均价格，然后从所有价格数字中减去它，得到新的调整后的价格数字 P’。你通过将地毯价格相加并除以地毯数量来计算平均价格μ <sub class="fm-subscript">P</sub> 。例如，如果价格是 1000、1200 和 1700，你可以将这三个价格相加 1000+1200+1700，然后除以 3，得到 1300 的平均价格。你可以从每个价格中减去 1300，得到调整后的价格-300，-100 和 400。如您所见，调整后的价格 P '合计为 0。从某种意义上说，调整后的价格是以 0 为中心的。

面积数字以同样的方式居中。你把面积加起来，除以地毯的数量，就得到平均面积。例如，如果面积是 10、12 和 17 平方阿尔萨尼，你可以将 3 个面积 10+12+17 相加，然后除以 3，得到 13 的平均面积。然后从每个区域中减去 13，得到调整后的区域-3，-1 和 4。调整后的面积 A’也等于 0。调整后的面积和调整后的价格现在都以 0 为中心。它们并排在一起，准备进行比较。

![12-unnumb-5](img/12-unnumb-5.png)

缩放

下一步是得到相同比例的价格和面积。价格以托曼为单位，面积以阿尔萨尼广场为单位，不存在从托曼到阿尔萨尼广场的转换。这就像从蒲式耳到摄氏度的转换。皮尔森，或者更确切地说是布拉瓦伊斯，使用了一个来自线性代数的概念，叫做*规范化* 。

假设你有一个向量(a，b)，你想找一个方向相同，但长度为 1 的向量。向量(a，b)的任何倍数，比如(ma，mb)，都会指向同一个方向。乘以一个向量会改变它的长度，但不会改变它的方向。如果将向量除以其长度，新向量(a/L，b/L)的长度将为 1，方向与原始向量相同。这也扫清了 的兵种。想象一下，向量的长度是用英尺来度量的。如果你把向量除以它的长度，那么你就有英尺除以英尺。结果只是一个数字，没有单位。它是无量纲的。当矢量以托曼或平方阿尔萨尼为单位测量时，情况也是如此。

利用勾股定理、*L*=√(*a*<sup class="fm-superscript">2</sup>+*b*<sup class="fm-superscript">2</sup>)可以很容易地求出向量的长度。这可以扩展到任意多个维度，*L*=√(*a*<sup class="fm-superscript">2</sup>+*b*<sup class="fm-superscript">2</sup>+*c*<sup class="fm-superscript">2</sup>+...)。让我们尝试一个例子，看看这是否可行。试试向量(3，4)。这个向量的长度是√( 3<sup class="fm-superscript">2</sup>+4<sup class="fm-superscript">2</sup>)= √( 9+16)=√25 = 5。归一化向量为(3/5，4/5)。因此√((3/5)<sup class="fm-superscript">2</sup>+(4/5)<sup class="fm-superscript">2</sup>)= √( 9/25+16/25)=√25/25 = 1 就是规格化向量的长度，和预期的一样。成功了。

P，A，P’和 A’都是数字的列表，所以是向量。它们的长度和任何向量一样，可以像任何向量一样归一化。在几何中，向量通过除以其长度来归一化。任何规范化向量的长度总是 1。

要归一化 P '你只需对所有调整后的价格求平方，将这些平方相加，然后取总和的平方根。这就给出了 P '的长度。将调整后的价格 P '除以长度，得到归一化价格 P ' '。要标准化所有调整区域的平方，将这些平方相加，并取和的平方根。这样就得到了 A '的长度。将所有调整后的面积 A’除以长度，得到归一化面积 A”。

![12-unnumb-6](img/12-unnumb-6.png)

概括来说，(1)通过减去平均值将价格和面积居中，然后(2)通过除以长度将价格和面积标准化。结果是一个标准化的价格列表和一个标准化的区域列表，其中每个列表中术语的总和为 0，每个列表中术语的平方和为 1。

现在我们已经为公式做好了准备。将标准化价格列表中的每一项乘以标准化区域列表中的相应项，因此 P'' <sub class="fm-subscript">i</sub> ×A'' <sub class="fm-subscript">i</sub> 。把那些产品加起来。那就是相关系数。(在线性代数中，这被称为标准化价格向量和标准化面积向量的*内积* ，或*点积* 。)

让我们来验证一下。假设我们正在测试摄氏温度和华氏温度之间的相关性。我们知道这些通过线性公式 F = 1.8C+32 相关，所以相关系数应该是 1。假设我们在上午 11 点、下午 3 点、下午 7 点和晚上 11 点测量温度，发现摄氏温度为(14，24，6，0)，华氏温度为(57.2，75.2，42.8，32)。平均摄氏温度为(14+24+6+0)/4 = 11，所以调整后的摄氏温度 C '为(3，13，-5，-11)，对应的调整后的华氏温度 F '为(5.4，23.4，-9，-19.8)。摄氏 C '向量的长度是 18。将 C '除以 18，得到 C ' '，标准化的摄氏温度(3/18，13/18，-5/18，-11/18)。调整后的华氏向量 F’的长度是 32.4，归一化的华氏向量 F”是(3/18，13/18，-5/18，-11/18) 。

我们逐个元素地将 C ' '乘以 F ' '并将 4 个乘积相加以获得相关系数。这个和是(3/18)<sup class="fm-superscript">2</sup>+(13/18)<sup class="fm-superscript">2</sup>+(-5/18)<sup class="fm-superscript">2</sup>+(-11/18)<sup class="fm-superscript">2</sup>。所有加起来是 1。这支持了之前描述的过程，即通过减去平均值居中，通过除以长度归一化，然后逐项相乘并求和，确实产生了有效的相关系数。

概括一下:通过计算相关系数来测试线性。本节已经向您展示了如何计算相关系数。计算得出一个介于-1 和+1 之间的数字。下面是一个图表，用于解释相关系数 。

![12-unnumb-7](img/12-unnumb-7.png)

### 12.3.2 基数为 26 的线性度

让我们 开始研究基于 26 字符字母表的替换的线性度。如果你正在设计一个机械或机电密码设备，或者如果你正在模拟一个，这可能是有价值的。这种机器中的每个转子执行一个 26 字符字母表的替换。首先考虑一个没有密钥的 S 盒。26 个字母的字母表有多种线性形式，具体取决于字母的编号方式。查看字母表有三种方式:将字母表视为 26 个字母的单个序列，将其视为 2×13 字母数组，或将其视为 13×2 字母数组。这导致了三种不同的字符编号方式:N1，N2 和 N3，如图所示。对这 3 种编号方案的讨论使用了模运算。如果你想在这个时候复习模运算，请参见第 3.6 节。

![12-unnumb-8](img/12-unnumb-8.png)

N2 和 N3 遵循通常的惯例，用字母 A、B 和 C 来表示超过 9 的数字。也就是说，它们使用 16 个十六进制数字中的前 13 个。在最简单的线性加密中(T2 贝拉索密码 T3)，密钥只是被添加到明文中。当密钥被加到明文字符上时，在 N1 编码方案中，它使用传统的模 26 加法。在 N2 编码方案中，当密钥被加到明文字符上时，第一个数字以模 2 相加，第二个数字以模 13 相加。相反，在 N3 编码方案中，当密钥被加到明文字符上时，第一个数字以模 13 相加，第二个数字以模 2 相加。下面的例子展示了在这三种方案中，如何通过添加密钥 J 来加密单词。

![12-unnumb-9](img/12-unnumb-9.png)

如果明文、密钥和密文字母都使用 N1 方案进行编号，那么线性替换或线性变换将采用明文字符 p，并使用密钥 k 将其变换为密文字符 c = mp+f(k)，其中 m 是必须与 26 互质的乘数，f(k)是任何整数值函数，算术运算以 26 为模。例如，如果 m = 5，p = 10，k = 3，f(k) = k <sup class="fm-superscript">2</sup> +6，那么 c = 13，因为 5×10+3 <sup class="fm-superscript">2</sup> +6 = 65≡13 (mod 26)。常数 m 和函数 f(k)可以内置到替换表中。

如果明文、密钥和密文字母都使用 N2 或 2×13 编号方案进行编号，则第一个数字或第二个数字或两个数字都可以是线性的。假设两个数字都是线性的。然后，使用密钥 k 将明文字符 p = a，b 变换成密文字符 c = ma+f(k)，nb+g(k)，其中 m 必须与 2 互质，这意味着 m = 1，n 必须与 13 互质，f(k)和 g(k)可以是任何整数值函数。算术分别以模 2 和模 13 完成。常数 m 和 n 以及函数 f(k)和 g(k)可以被构建到替换表中。

如果明文、密钥和密文字母都使用 N3 或 13×2 编号方案进行编号，则第一个数字或第二个数字或两个数字都可以是线性的。假设两个数字都是线性的。然后，使用密钥 k 将明文字符 p = a，b 转换成密文字符 c = ma+f(k)，nb+g(k)，其中 m 必须与 13 互质，n 必须与 2 互质，这意味着 n = 1，f(k)和 g(k)可以是任何整数值函数。算术分别以 13 和 2 为模。常数 m 和 n 以及函数 f(k)和 g(k)可以被构建到替换表中。

不要求明文和密文以相同的方式编号。在任何编号中，明文的任何数字和密文的任何数字之间可以存在相关性。Emily 可能会测试这些组合中的任何一个或全部，寻找可利用的弱点。因此，密码的设计者必须测试所有可能的数字和相关性，以验证不存在这样的弱点，或者了解必须采取什么对策来防止艾米丽利用这样的弱点。例如，您可以在分组密码的交替循环中使用具有不同弱点的替换。在大多数情况下，每次替换都会削弱对方的弱点。当然，您应该通过寻找明文和最后一轮产生的最终密文之间的线性关系来测试这一点。

如果您希望测试替代的线性，您不能直接应用相关系数。这是因为所有这些替换都是使用模运算完成的。考虑使用 N1 编号方案的替换:

![12-unnumb-10](img/12-unnumb-10.png)

这几乎正好是 c = 2p，所以是高度线性的。然而，使用这种编号方案的明文和密文字母之间的相关系数是. 55556，表明替换只是弱线性的。相关系数应使用以下分布计算，相当于模 26。

![12-unnumb-11](img/12-unnumb-11.png)

使用这种编号的相关系数是. 99987，正确地显示出非常强的线性。

这说明了在密码学中使用相关系数的困难。你总是对字母表的大小取模。为了找到正确的相关性，您需要为 N1 编号加上 26，然后 52，78 等等，或者 13，26，39，...N2 和 N3 的号码。在前一个例子中，你需要开始增加 26 的地方是显而易见的。这就是密文编号的去向 **22 24 1 3** 。从 24 降到 1 就很明显了。

当密文字母表的线性度较低时，当它跳跃一点时，可能更难被发现。例如，这种替代具有 0.3265 的相关性，中度非线性。

![12-unnumb-12](img/12-unnumb-12.png)

像这样加上 26 的倍数来调整时

![12-unnumb-13](img/12-unnumb-13.png)

相关性变成. 9944，高度线性。我使用了单个、双和![bold](img/bold.png)   下划线来分别表示  26  、  52  和 ![78](img/78.png)已经添加到密文字符的位置。这里需要注意的一个重要特性是，26 被添加到密文字符 2，对应于明文 5，但不对应于后面的密文字符 21 和 25。同样，52 被加到密文字符 1 上，对应于明文 14，但不加到后面的密文字符 24 上。

当密文字母表接近线性时，确定要添加 26 的哪个倍数是相当容易的。当密文字母表表现不好时，它会变得更加困难。但是...那不重要。当替代是非线性的，这就是你需要知道的。相关系数是. 01 还是. 35 没什么区别。在这两种情况下，艾米丽都没有足够的相关性来利用。不要浪费时间去计算确切的价值。

没有钥匙也能处理案件。现在假设有一把钥匙。如果替换是线性的，那么它将具有 d(p)+f(k)的形式，其中 p 是明文，k 是密钥，d 和 f 是整数值函数。可以在 N1、N2 或 N3 这三种编号方案中的任何一种中进行添加。在这种情况下，按键在测试线性度时不起作用。f(k)只是加在密文上的一个常数。添加一个常数对相关系数没有影响，因为当您从每个值列表中减去平均值时，它会被减去(居中操作)。很容易检验代换 S(k，p)是否采取 d(p)+f(k)的形式。只需选择两个键 k <sub xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" class="fm-subscript">1</sub> 和 k <sub xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" class="fm-subscript">2</sub> 取差值 S(k <sub xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" class="fm-subscript">1 【T7，0】-S(k<sub xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" class="fm-subscript">2【T9，0)，S(k <sub xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" class="fm-subscript">1 【T11，1)-S(k <sub xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" class="fm-subscript">2 【T13，1】，S(k <sub xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" class="fm-subscript">1 【T15，2】-S(k<sub xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" class="fm-subscript">2【T17，2】)...如果 S 盒具有 d(p)+f(k)的形式，那么所有这些差都是相等的。如果对所有可能的键重复上述步骤，则可以确定 S(k，p)具有所需的形式，并且可以在不考虑 键的情况下测试线性度。</sub></sub></sub></sub></sub></sub>

### 12.3.3 基数-256 线性

这个 对以 26 为基数的线性度的分析只是以 256 为基数的线性度的热身，因为以 256 为基数的线性度有两种不同的形式。姑且称之为*连载*和*浓缩*。在串行线性中，每组位代表一个整数。例如，3 比特组 000、001、010，...111 代表数字 0，1，2，..., 7.这两种形式的线性可以组合成一种混合 形式的线性。这将在第 12.3.6 节中讨论。

串行线性是我们在 base 26 中看到的。在以 26 为基数的情况下，N1、N2 和 N3 的数字之间可能存在任何组合和任何顺序的相关性，因此有许多配对必须进行线性测试。在 base 256 中，有更多的可能性。在明文字母表中的任何比特组和/或密钥与密文字母表中的任何比特组之间可能存在串行线性。这些位组不需要具有相同的大小。从明文中取出的覆盖范围从 0 到 15 的 4 比特组可能与覆盖范围从 0 到 7 的 3 比特密文组高度相关，因此可能配对的数量要大得多。

更糟糕的是，4 位组中的 4 位可以是明文字节中的任何位。按此顺序排列的位 7、2、5、1 与位 1、2、3、4 一样有效。线性替换可能将这 4 个比特添加到密钥字节的 4 个不同比特的模 16 中。可能的组合数量变得巨大。概括地说，明文字符加密钥字符中任何顺序的任何比特组都可以与密文字符中任何顺序的任何比特组线性相关。这是一大堆要测试的相关性。

在你喝 Excedrin 或龙舌兰酒之前，这里有一些好消息。你可能不需要测试它们中的任何一个。除非密码是专门设计来完整传递这些值的，否则这些相关性无关紧要。它们会在每一轮中被削弱，以至于通过最后一轮的分组 密码，它们将无法从初始明文中被检测出来。

### 12.3.4 添加后门

各位 可能注意到我说的“大概”例外情况是，当你怀疑一个密码可能有一个后门，也就是说，它已被故意设计，以便知道机密的人可以在不知道密钥的情况下阅读消息。例如，一个国家间谍机构可能为其代理人提供一个带有后门的密码，以便该机构可以监控他们的消息并发现叛徒。

讲到这里，我们换帽子吧。假设你是 Z，负责设计这个密码的间谍头子。您需要构建一个外观和行为都像强大的分组密码的密码，这样用户就不会怀疑任何事情。例如，您可能希望您的密码具有对半属性，其中仅更改密钥或明文中的一个位就会导致大约一半的密文位以看起来随机的模式发生变化。如果你的分组密码中的替换不都是线性的，这将是一个强分组密码的可靠标志。你想让你的假密码模仿那个属性。

这里有一种方法可以用来在密码中隐藏后门。它是基于序列线性的，所以姑且称之为*后门* *序列*方法构造密码，姑且称这种方法构造的密码为*后门* *序列*密码。z 可以在不需要知道密钥的情况下读取使用后门序列密码发送的消息，但是对于任何不知道后门如何工作的人来说，它们看起来像是强大、安全的块密码。该方法有三个部分:*伪装* 、*隐蔽* 和*伪装*。

伪装

后门序列密码将对十六进制数字使用线性替换。明文和密钥的每个块都被视为一个 4 位十六进制数字序列。加密操作是对消息块和密钥的十六进制数字进行模 16 加法运算。假设一个字节中的两位十六进制数字是 p <sub class="fm-subscript">1</sub> 和 p <sub class="fm-subscript">2</sub> ，用来加密它们的密钥的十六进制数字是 k <sub class="fm-subscript">1</sub> 和 k <sub class="fm-subscript">2</sub> 。线性替换将 p <sub class="fm-subscript">1</sub> 和 p <sub class="fm-subscript">2</sub> 替换为

![12-unnumb-13-equation-12-5](img/12-unnumb-13-equation-12-5.png)

系数 a，b，c，d，e，f，g，h，I，j 可以是 0 到 15 的任意整数，ag-fb 必须是奇数。如果您的密码有多轮，这 10 个值可能每轮都不同。

这种线性替换很容易被艾米丽察觉。特别是，每个十六进制数字的低阶位是纯线性的，因此简单的逐位线性测试就能找到它。为了避免被发现，我们可以伪装十六进制数字。首先，按一定的顺序列出十六进制数字，如下所示:

![12-unnumb-14](img/12-unnumb-14.png)

要添加两个伪装的十六进制数字，您需要将它们在加扰列表中的位置相加，以获得总和在加扰列表中的位置。比如要加**1**+**2**，你发现数字 **1** 在位置 9，数字 **2** 在位置 F，于是你加 9+F mod 16 得到 8。总和在列表的第 8 位。8 位的数字是 **D** ，所以**1**+**2**=**D**。

同样，要将两个伪装的十六进制数字相乘，您需要将它们在加扰列表中的位置相乘，以获得乘积在加扰列表中的位置。例如，要将**2**×**3**相乘，您会注意到数字 **2** 在位置 F，数字 **3** 在位置 2，因此您将 F×2 mod 16 相乘得到 E。乘积在列表中的位置 E。位置 E 的数字是 **7** ，所以**2**×**3**=**7**。

本质上，伪装是对十六进制数字的简单替换。如果替换是非线性的，那么在明文和密文之间没有一个比特具有线性关系。这种伪装的线性对于 Emily 来说更难检测，但是要真正混淆 Emily，您可以隐藏伪装的十六进制数字。

隐蔽

如果十六进制数字总是块和密钥的每个字节的第 1-4 位和第 5-8 位，那么 Emily 仍然有机会发现线性。要真正使 Emily 的任务变得非常困难，您可以隐藏每个字节中的位。您可以从明文的位(2，7，4，1)和密钥的位(4，8，3，5)中依次取出十六进制数字，然后将得到的和放入密文字节的位(8，6，1，7)，而不是使用明文的位(1，2，3，4)和密钥的位(1，2，3，4)并将得到的和放入密文字节的位(1，2，3，4)。只要每个字节中的 2 个十六进制数字各使用一次所有的 8 位，您就可以以任何顺序使用您选择的任何 4 位组合。

澄清一下，我们不是说 Sandra 从每个字节中提取这些位，解密伪装的线性替换，执行算术运算，然后以不同的顺序重新打包结果位。那太慢了，艾米丽会确切地知道发生了什么。相反，桑德拉在搭建替换场景时这么做了。要加密，她只需使用密钥字节选择表中的一行，然后对明文字节进行替换。所有的伪装和隐藏都被构建到替换画面中。

迷彩

到目前为止所描述的密码仅仅是一个非常复杂的多字母密码。Emily 可以使用第 5.8.3 节的技术来解析消息。为了使后门串行密码看起来像一个强大的分组密码，你需要一些伪装来隐藏其核心的多字母密码。

一种方法是使用 位转置，该位转置在每一轮之后应用于块。这将使密码看起来像一个置换网络(11.1 节)。为了保持隐藏的线性，组成每个十六进制数字的 4 位必须以单个字节结束。它们不需要在该字节中的相同位位置，也不需要相邻，但它们必须在一个字节中。换句话说，输入的每个字节被分成两个十六进制数字，这两个数字在下一轮以某种转置顺序被送入另外两个字节。不幸的是，如果 Emily 能够获得后门串行密码的公开规格，她很可能会发现这种伪装。

让我们来看看第二种伪装形式，对艾米丽来说，这种伪装要难得多。这种方法借鉴了数据加密标准(DES)(11.2 节)的思想。每个密码块被分成两半。在每一轮中，首先用左半部分作为加密右半部分的密钥，然后用右半部分作为加密左半部分的密钥。我们已经看到线性如何在替换表中被伪装和隐藏，所以让我们利用这一点来创造一个强大的分组密码 的假象。

每一轮密码将由四个步骤组成。(1)左半部分的每个字节使用密钥的一个字节进行加密。(2)使用左半部分的一个字节作为密钥对右半部分的每个字节进行加密。(3)右半部分的每个字节用密钥的一个字节加密。(4)使用右半部分的一个字节作为密钥对左半部分的每个字节进行加密。

为了使这看起来非常强大，在每一轮中，应该使用密钥的不同字节对块的每个字节进行加密，并且在每一轮中，应该使用与另一半不同的字节对块的一半的每个字节进行加密。您可以通过在每一轮中打乱块中的字节和密钥中的字节来想象这一点。你可以把钥匙做得比木块大，以表现出更大的力量。然而，密码仍然是线性的，因为在每一轮的每一步中都保持了线性。

储存

让我们来看看后门串行密码的机制。在密钥的每个字节中，明文和密文都有两个十六进制数字。每一个都可以以任何顺序占据字节的任何 4 位。让我们把 4 位的有序集合称为十六进制数字的*位配置*，把一个字节中 2 个十六进制数字的组合称为*字节配置* 。密钥通常不会改变配置，但是明文和密文的字节配置可以在加密的任何阶段改变。

对于每个替换，有 6 个比特配置，2 个用于密钥，2 个用于明文，2 个用于密文。对于每个十六进制数字，16 个十六进制值的排列(加扰顺序)也可以不同，因此对于每次替换，十六进制值也有 6 个排列，2 个用于密钥，2 个用于明文，2 个用于密文。这 6 种配置和 6 种排列的组合决定了替换表。对于比特配置和排列的每个不同组合，需要单独的替换表。

每个 tableau 使用 65，536 字节，因此存储可能是个问题。如果这是一个问题，我建议使用最多 2 个字节的配置，每个位配置最多使用 2 种不同的排列，也许从一轮到下一轮交替。为了进一步减少所需的存储量，您可以考虑在每次使用任何给定的位 配置时使用相同的排列。

### 12.3.5 浓缩线性

在 大多数情况下，你不会在你的密码中建立一个后门，你也不会关心序列的线性度。让我们把注意力转向第二种线性，即压缩线性。在这种线性形式中，通过对一组比特进行异或运算，可以将它们压缩成一个比特。因此，000、011、101 或 110 将被浓缩为 0，而 001、010、100 或 111 将被浓缩为 1。对于每个 S 盒，来自明文和/或密钥的任何比特组都可能与来自密文的任何比特组相关。如果分组密码使用异或将 S 盒的输出与分组的其余部分组合，那么这种线性可以从一轮传递到另一轮，并且在原始的第一轮明文和最终的最后一轮密文之间将存在线性关系。密码的设计者必须避免使用异或这种方式，或者必须进行彻底的检查，以确保 S 盒不包含任何这样的线性。

假设 S 盒取一个 8 位明文，产生一个 8 位密文。有 255 种不同的方式可以从明文中选择一组比特，同样也有 255 种方式可以从密文中选择一组比特。(位的顺序无关紧要，因为 a ⊕ b = b ⊕ a .)使得 255 <sup class="fm-superscript">2</sup> = 65，025 个不同的组配对被测试。每个测试都是 256 个明文值和 256 个密文值之间的关联。这很容易做到，即使在个人电脑上。

如果 S 盒采用 8 比特明文加 8 比特密钥，并产生 8 比特密文，那么有 65，535 种不同的方式可以从明文加密钥中选择一组比特，同样有 255 种方式可以从密文中选择一组比特。这使得 65，535×255 = 16，711，425 个不同的配对需要测试。这在 PC 上需要很长时间，因为每个关联涉及所有 65，536 个明文和密钥组合。超过 10 个 <sup class="fm-superscript">12</sup> 值需要居中、缩放和求和。

这是谈论如何有效进行这些测试的理想时机。有一些技巧可以大大加快这个过程。(1)要选择位的组合，请使用从每个字节中选择这些位的掩码。例如，如果您想要位 2、4 和 7，请使用掩码 01010010，它的位位置 2、4 和 7 为 1。和每个明文字节的掩码来选择所需的位。(2)要尝试所有可能的位组合，不要一次构造一个掩码，只需通过所有值 1 到 255 步进掩码。(3)压缩比特，不要每次都用移位和异或。这样做一次，并建立一个压缩值表。那么位组合可以通过查表来压缩。如果有密钥位和明文位的组合，这些可以一起进行异或运算，结果可以使用表来压缩，因此您将需要一个表查找，而不是两个 。

### 12.3.6 混合线性

对于 为了完整起见，我将提到一种混合形式的线性，它结合了串行和压缩线性。假设您将每个 8 位字节分成四个 2 位组。这些 2 比特组在模 4 加法下可以是串行线性的。你可以通过模 4 相加来压缩两个或更多这样的组。用模 8 的 3 比特组或模 16 的 4 比特组也可以做到这一点。

让我们坚持使用 2 位组。每组可以由取自字节中任何位置的 2 位组成。例如，一个字节可以分解成 4 组，比特(6，1)、(4，8)、(2，5)和(7，3)。您可以将几个 2 位组压缩成一个 2 位组，方法是将它们以 4 为模相加，或者以 4 为模进行任何线性组合。例如，如果 2 位组是 A、B、C 和 D，您可以将它们组合成新的 2 位组 pA+qB+rC+sD+t (mod 4)，其中 p、q、r、s 和 t 是 0 到 3 范围内的固定整数，p、q、r 和 s 中至少有一个是奇数。

这些类型的压缩组可以与密文中类似的混合比特组相关，或者与来自密文的常规比特组或压缩比特组相关。如果你想绝对彻底，那么所有线性群、凝聚群和混合群的可能配对都需要进行 相关性测试。

### 12.3.7 构建一个 S 盒

这里的 是构造具有良好非线性特性的 S 盒的三种方法:时钟方法*、 *SkipMix* 和 *Meld8* *方法* 。*

 *时钟法

在一张纸上，像钟面上的数字一样，将字母表中的字母顺时针等间距排列成一个大圆。选择第一个字母和第二个字母，从第一个字母到第二个字母画一条直线。然后选择第三个字母，从第二个字母到第三个字母画一条直线，依此类推。将每行的*跨度*定义为从一个字母到下一个字母顺时针方向移动的字母位置数。例如，使用 26 个字母的字母表，从 C 到 D 的跨度是 1，从 D 到 C 的跨度是 25。为了使替换尽可能非线性，使每个跨度具有不同的长度。

下面是如何做到的。对于字母表中的每个字母，列出所有可能跟在它后面的字母。当您开始时，每个字母的列表将包含所有其他字母，因此您将有 26 个列表，每个列表包含 25 个字母。每次你选择一个字母并将其添加到混合字母表中时，从所有列表中删除该字母。如果从前一个字母到那个字母的跨度是 s，那么也从所有列表中删除跨度为 s 的任何其他字母。例如，假设您已经将 P 和 R 添加到字母表中。从 P 到 R 的跨度是 2 个位置，PQR。因此，在 A 列表中你会删除 C，在 B 列表中你会删除 D，在 C 列表中你会删除 E，依此类推。

最终，一些列表会变成空的。如果列表中只有一个字母是空的，那么这个字母将是混合字母表中的最后一个字母。如果有两个列表是空的，那么你就走进了死胡同。重新开始，或者退回去再试一次。每次你选择要添加到字母表中的下一个字母时，选择一个有短列表的字母，而不是有空列表的字母，除非那是剩下的最后一个字母。

抛开历史不谈

这种启发法被称为 H. C .冯·沃恩斯多夫的沃恩斯多夫法则，他在 1823 年用它来构建棋盘上的骑士巡游。加州大学圣克鲁斯分校的 Ira Pohl 在大约 1965 年给出了一个看起来超前了两步的改进版本。

下面是一个用时钟方法构建的字母表的例子:

![12-unnumb-15](img/12-unnumb-15.png)

需要测试 5 种不同的编号来检查该字母表的线性:N1 编号、N2 编号的第一和第二位数字以及 N3 编号的第一和第二位数字。这些中的每一个都必须与标准拉丁字母的相同的 5 个数字相关，总共 25 个相关。你希望所有的相关性都在-.5 和+.5 之间。更好的是，它们都在-.333 和+.333 之间。

下面是这些测试的结果，25 个相关系数。

![12-unnumb-16](img/12-unnumb-16.png)

如你所见，所有的相关性都在-.226 和+.288 之间，其中有 6 个在-.1 和+.1 之间，因此时钟法是一种构建非线性替换 的极好方法。

不能保证你每次都能得到这么好的结果。你仍然需要测试线性度。

SkipMix

在本节(12.3)的前面，我提到可以使用 SkipMix 算法(5.2 节)和伪随机数发生器构建字母表。一般来说，随机选择一个字母表不会产生良好的非线性特性，所以让我更详细地描述一下使用 SkipMix 的最佳方式。这次我将用一个 256 个字符的字母表来说明。

像往常一样，首先列出 256 个可用字符。生成一个 1 到 256 之间的随机数来选择第一个字符。假设这是字母表中的第 54 位。提取该字符，然后将其从列表中删除。现在还剩 255 个字符。生成一个 1 到 255 之间的随机数。假设这个数字是 231。下一个位置是 54+231 = 285。因为它大于 255，所以减去 255 得到 30。从位置 30 取出下一个字符，并将其从列表中删除。您现在已经取了 2 个字符，还剩下 254 个字符，所以您生成一个范围在 1 到 254 之间的随机数。诸如此类。

生成的字母表具有良好的非线性特性，因为您每次都在不同的范围内生成随机数。这大致类似于在时钟方法中使所有的跨度不同。这里有一个由这个版本的 SkipMix 生成的 26 个字母的字母表的例子。

![12-unnumb-17](img/12-unnumb-17.png)

这可以用测试时钟字母表的方法来测试。结果是

![12-unnumb-18](img/12-unnumb-18.png)

这些结果是好的。所有相关性都在-.127 和+.344 之间，其中有 5 个相关性在-.1 和+.1 之间，但是，它们不如时钟方法的结果好。

Meld8 方法

这种方法基本上是一种专用的伪随机数发生器。我将假设您使用的计算机语言能够处理 64 位整数。根据大整数的表示方式，您可能能够处理多达 2 个 <sup class="fm-superscript">62</sup> 或 2 个 <sup class="fm-superscript">63</sup> 的整数。谨慎起见，我假设 2 <sup class="fm-superscript">62</sup> 。第一步是选择两个数，24 到 26 位的乘数 m，35 到 37 位的模数 N。模数必须是质数。如果 m 是 N 的本原根是最好的，但是，因为我还没有解释那是什么，只要使 m 和 N 都是质数。

通过将 m 和 N 相乘来测试你的选择。如果结果大于 2 <sup class="fm-superscript">62</sup> ，或大约 4.611×10 <sup class="fm-superscript">18</sup> ，则使 m 或 N 变小。

要生成随机数，从 2 到 N-1 之间的任意整数 s 开始作为种子。将种子乘以 m，并以 N 为模进行约简，得到第一个伪随机数。将第一个随机数乘以 m，然后以 N 为模进行缩减，得到第二个随机数，依此类推。这给了你一个从 1 到 N-1 的随机数序列。你将使用这些随机数来生成字母表。

假设 N 有 36 位。从高位开始，从 1 到 36 对 N 的位进行编号。取每个随机数的前 8 位，位 1 到位 8。从高阶端删除它们，并将其与接下来的 8 位(第 9 位到第 16 位)进行异或运算。这是 Meld8 操作。它的目的是使字符序列非线性。这里有一个例子:

![12-unnumb-19](img/12-unnumb-19.png)

下一步是使用 28 位随机数生成一个字符。这取决于您构建的是 26 个字符还是 256 个字符的字母表。对于一个 26 字符的字母表，将这个数字乘以 26，再除以 2 <sup class="fm-superscript">28</sup> (或者右移 28 位)得到下一个字符。对于一个 256 个字符的字母表，只需除以 2 <sup class="fm-superscript">20</sup> ，或者右移 20 位就可以得到下一个字符。

从一个空字母表开始，一次添加一个字符。如果这是一个新字符，你把它附加到字母表上。如果这是一个副本，你丢弃它。因为你不需要连续的随机数，这也使得字母表是非线性的。以下是用模数 N = 90392754973、乘数 m = 23165801 和种子 s = 217934 生成的这种字母表的例子:

![12-unnumb-20](img/12-unnumb-20.png)

得到的相关系数为

![12-unnumb-21](img/12-unnumb-21.png)

相关性范围从-.170 到+0 . 267，其中 11 个在-.1 到+0 . 1 之间。这是三个示例中最好的一个，但是，根据每种技术的一个示例就得出 Meld8 是最佳方法的结论是愚蠢的。总 测试。

### 12.3.8 带钥匙的 S 盒

在 第 12.3.7 节中，我们处理了没有密钥的 S 盒。他们进行了简单的替换。当使用一个键时，S 盒执行一个通用的多字母替换(第 5.8.3 节)。S 盒可以被认为是一个 tableau，每一行都是一个混合字母表。S-box 可以通过使用 clock 方法、SkipMix 或 Meld8 或任何方法的组合来构造这些混合字母表中的每一个来生成。

如果使用时钟方法或 SkipMix，每次使用不同的随机种子。如果使用 Meld8，每次使用相同的模数是可以接受的，但是使用不同的种子和不同的乘数。一如既往，测试，测试，测试。你的目标是避免密钥和明文的组合与密文之间的任何线性关系。如果结果是不合格的，这意味着许多相关系数在-.35 到+.35 的范围之外，那么可能只需要替换表中的一行或交换两行就可以解决问题。

## 12.4 扩散

香氏 第二个属性是*扩散* 。其思想是密文的每一位或每一字节都应该依赖于明文和密钥的每一位或每一字节。

为了说明这一点，让我们回到 9.6 节中描述的 Delastelle 的双歧密码。提醒你一下，bifid 是一种基于波利比乌斯方的分组密码。如果块大小为 S，则消息的每个字母由两个基数为 5 的数字代替，这些数字被垂直写入 2×S 的网格中，并被水平读出。然后使用相同或不同的波利比乌斯方块将数字对转换回字母。

设块大小为 7，称明文块中的字母为 A、B、C、D、E、F、g，设代表这些字母的位数为 aa、bb、cc、dd、ee、ff、gg。我省略了下标，因为在这里哪个数字是第一个和哪个数字是第二个并不重要。该块将被

![12-unnumb-22](img/12-unnumb-22.png)

当字母从方块中水平读出时，你得到 ab，cd，ef，ga，bc，de，fg。请注意，密文的每个字母依赖于明文的两个字母。第一个密文字母取决于 A 和 B，第二个字母取决于 C 和 D，依此类推。

在这一点上，我需要引入一种特殊的符号来表示每个密文字母依赖于哪些明文字母。如果一个密文字母依赖于明文字母 P，Q 和 R，它被命名为 pqr。使用这种符号，如果你第二次加密字母 A、B、C、D、E、F、G，块看起来会像这样:

![12-unnumb-23](img/12-unnumb-23.png)

横向读出这些字母，你得到 abcd，efga，bcde，fgab，cdef，gabc，defg。由于数字的顺序无关紧要，因此也可以给出 abcd、aefg、bcde、abfg、cdef、abcg、defg。经过两次加密，每个密文字母依赖于四个明文字母。

如果你使用双歧密码第三次加密这个块，每个密文字母将依赖于所有 7 个明文字符。对于块大小为 7 的 bifid 密码，需要三轮加密才能得到完全扩散。如果块大小是 9、11、13 或 15，则需要四轮加密。(回想一下，双歧密码中的块大小应该总是奇数。)

一般来说，为了测试扩散，你从每个纯文本字符或比特开始，只依赖于它自己。如果密码运算的是整个字节或字符，那么你是在字节的基础上追踪扩散。如果它对十六进制数字、其他基数的数字或单个比特进行运算，你就可以在这些单位的基础上追踪扩散。对于双歧密码，单位是波利比乌斯平方坐标，或基数为 5 的数字。

为了跟踪扩散，你需要一种方法来表示明文单元和密钥单元的集合，因为它们通过分组密码的轮次。当只有几个明文单元时，就像 bifid 的例子一样，只列出它们就可以了。当明文、密钥和密文单元的数量较大时，可能需要更紧凑的表示。一个好的策略是为每个密文单元创建一个二进制向量。姑且称之为*依赖向量* 。依赖向量的每个元素将对应于一个输入，或者是明文或者是密钥单元。如果密文单元依赖于该输入单元，则依赖元素的值为 1，否则为 0。

当两个或多个输入单元被组合以形成一个输出单元时，它们的相关性向量被或在一起以形成输出单元的相关性向量。为了说明这是如何工作的，让我们用这种符号再看一遍 bifid 的例子。最初，每个角色只依赖于它自己。这由矢量表示

![12-unnumb-24](img/12-unnumb-24.png)

在第一次应用 bifid 密码后，每个结果字母取决于两个明文字母。第一个 round 1 输出字节依赖于前两个 round 1 输入字节，所以你把它们的依赖向量**∨**0100000**加在一起得到**1100000。第二个输出字母依赖于第三个和第四个明文字母，所以你或者它们的依赖向量一起**0010000**∨**0001000**得到 **0011000** ，以此类推。第一轮的输出由向量表示****

 ****![12-unnumb-25](img/12-unnumb-25.png)

第二轮分叉后，第一个输出字母依赖于第一轮的第一个和第二个输出，所以你或者它们的依赖向量一起**1100000**T5】∨**0011000**得到 **1111000** 。第二个输出字母依赖于第一轮的第三和第四个输出，所以你或者它们的依赖向量一起**0000110**∨T22】1000001 得到 **1000111** ，以此类推。经过两轮分裂后，每个字母依赖于四个明文字母，表示为

![12-unnumb-26](img/12-unnumb-26.png)

第三轮双歧后，每个输出字母依赖于第一轮所有 7 个明文字母，例如，**1111000**T5】∨**1000111**是**11111111**。第三轮的输出表示为

![12-unnumb-27](img/12-unnumb-27.png)

任何时候遇到 S 盒，输出单元的依赖向量都是通过对有助于该输出的每个输入的向量进行或运算而形成的。让我们看看分组密码中可能出现的其他一些情况。

如果两个单元被异或在一起，输出单元的依赖向量通过对每个输入的向量进行或运算而形成。当使用任何组合函数组合几个单元时，如**sxor**T3】或 **madd** ，也是如此。

当一个块的单元使用一个键进行转置时，每个输出单元都依赖于该键的所有单元，因此该键的向量与每个输出单元的向量进行或运算。

假设一个 S 盒是通过用一个键混合它的字母表而创建的。如果 S 盒是固定的或静态的，比方说通过将其嵌入硬件中，则不再涉及混合键。如果 S 盒是可变的，可能使用不同的密钥对每个加密进行混合，那么该 S 盒的输出单元依赖于该密钥的所有单元。键的向量与每个输出单元的向量进行“或”运算。

扩散可以用一个数字来表示。从所有输出单元的相关性向量形成矩阵。矩阵中的每一行将代表分组密码的最后一轮的一个输出单元。矩阵中的每一列代表一个输入单元，或者是密钥，或者是明文。扩散的度量，或*扩散指数*，是矩阵中这些元素为 1 的部分。如果矩阵元素都是 1，那么存在完全扩散，扩散指数是 1。如果 S 盒是非线性的并且密钥是长的，这表明分组密码是强的。

扩散并不是故事的全部。存在有效的密码设计，其中扩散指数可能小于 1，然而密码是强的。一个例子是分组密码，其中每一轮有一个单独的密钥。来自早期回合的密钥可以实现完全扩散，但是来自后期回合的密钥，尤其是来自最后回合的密钥，可能不会。然而，如果完全分散的密钥包含您的目标位数，那么密码很可能是安全的，而部分分散的密钥只是保险。

这里有一个例子，可以帮助说明即使在不完全扩散的情况下，密码也可以很强。考虑一个有 12 轮的密码，其中每轮有一个独立的 24 位密钥。在该密码中，需要 6 轮来实现完全扩散，因此在 6 轮之后，明文和第一轮密钥被完全扩散。在 7 轮之后，明文以及第一轮和第二轮密钥被完全扩散。诸如此类。在 12 轮之后，明文和前 7 轮的密钥被完全扩散。对于 24 位轮密钥，即 168 位全扩散密钥。如果你的目标强度是 128 关键位，那么你已经超越了你的目标。从第 8 轮到第 12 轮部分扩散的钥匙是一个 奖励。

## 12.5 饱和度

混乱 和扩散是安全框架的两大支柱。为了确保分组密码有一个坚实的基础，我提议增加第三个支柱，我称之为*饱和*。扩散仅仅表明一个给定的输出单位是否依赖于一个给定的输入单位。饱和度衡量给定的输出单位对给定的输入单位的依赖程度。我展示了如何计算一个类似于前一部分的扩散指数的饱和指数。饱和度本质上是扩散的一个更精确的版本。对于扩散，依赖性可以只有 0 或 1 的值，但是对于饱和，依赖性可以有任何非负值。

这里是饱和度的快速解释。假设分组密码 X 由几轮替换组成。在每一轮中，消息的每个字节与密钥的一个字节进行异或运算，然后对结果进行简单的替换。假设密钥的不同字节在每一轮中被使用，因此密钥的每个字节对于块的每个字节被使用一次。密码 X 几乎没有饱和，因为密文的每个字节只依赖密钥的每个字节一次。为了获得更高的饱和度，每个输出字节需要多次依赖于每个输入字节。

另一个例子可能有助于说明这一点。想象一个在 48 位块上操作的密码，被视为 6 个 8 位字节。该密码的每一轮由两个步骤组成:(1)该块向左循环一个比特位置，因此最左边的比特移动到最右边的位置，然后(2)对 8 个字节中的每一个执行简单的替换 S。第一轮后，第一个输出字节 **C1** 取决于第一个明文字节的后 7 位和第二个明文字节的第一位，像这样:

![12-unnumb-28](img/12-unnumb-28.png)

密文字符 **C1** 依赖于明文字节 **P1** 和明文字节 **P2** 的 1 位。有道理说**C1**7/8 靠**P1**1/8 靠 **P2** 。

再来看第二轮。召唤第二轮输出 **D1** ...**。**

 **![12-unnumb-29](img/12-unnumb-29.png)

密文字符**D1**7/8 靠**C1**1/8 靠 **C2** 。这里**C1**7/8 靠**P1**1/8 靠 **P2** 而**C2**7/8 靠**1/8 靠 **P3** 。 **P1** 对**唯一的贡献就是出自**【C1】**。既然**D1**7/8 取决于 **C1** 和**C1**7/8 取决于 **P1** ，那么有理由说**D1**49/64 取决于**P1****同理 **D1** 的 1/64 取决于 **P3** 。姑且把这些数字叫做*饱和系数*和，而把这种计算，当存在单一依赖关系时，叫做 *S1 计算* 。******

 **图表可能会使配置更加清晰。

![12-unnumb-30](img/12-unnumb-30.png)

那么 **P2** 呢？**通过**【C1****C2**从 **P2** 处获得投稿。说**D1**7/8 依赖 **C1** ，其中 1/8 依赖**，1/8 依赖**，其中 7/8 依赖**，并得出结论**这是一个合理的计算，它导致了一个更复杂的扩散版本。但是，使用这种计算方法，对任何给定单元的总贡献将始终为 1。总数永远不会增长。如果多次重复这种计算，所有这些扩散数字都会收敛到 1/48。这不是饱和的概念试图抓住的。每当一个单元接收到来自几个不同来源的贡献时，饱和度应该增加。**********

 ******当一个单元得到多个贡献时，使用不同的计算来确定饱和系数。假设两个源有饱和系数 a 和 b，a ≥ b，那么组合的饱和系数为 a+b/2。如果有三个贡献饱和系数 a、b 和 c，其中 a ≥ b ≥ c，则组合饱和系数为 a+b/2+c/4。在每种情况下，分量饱和系数按降序排列，a≥b≥c≥d≥e...。概括地说，当多个饱和系数结合时，结果如下:

![12-unnumb-30-equation-12-6](img/12-unnumb-30-equation-12-6.png)

姑且称这种计算，当有多个依赖关系时， *S2 计算*T3。对单个源使用 S1 计算，对多个源使用 S2 计算。

S2 的计算可能看起来特别，甚至古怪，但是它正好具有饱和度计算的性质。首先，当一个单元依赖于一个以上的前任时，它总是增加。这是因为 a+b/2 永远大于 a，第二，它没有增加太快。从一轮到下一轮，饱和系数最多可以翻倍。这是因为 a+a/2+a/4+...+a/2<sup class="fm-superscript">n</sup>T3】2a 对于任意 n .例如:1+1/2+1/4+1/8 = 15/8 = 1.875。

本例中，**依**，贡献系数为 7/8 和 1/8，所以组合系数为 7/8+(1/8)/2 = 15/16。输出单元的饱和系数可以形成一个向量，就像扩散数一样。因此， **D1** 的最终饱和度矢量为(49/64，15/16，1/64，0，0，0)。然后这些向量可以形成一个饱和矩阵。饱和指数是饱和矩阵中最小的系数。****

 ****让我们来看一个更现实的密码，一个已经在文献中提出并可能已经在实践中使用的密码。我就称之为 *SFlip* ，简称*替代和翻转* 。它是 11.7.5 节中的聚三翻 的表弟。如果你不记得翻转矩阵是什么意思，看看 11.7 节。SFlip 密码在一个 8 字节的块上工作，由几轮加一个结束步骤组成。每一轮有两个步骤。(1)简单替换应用于八个 8 位字节。(2)翻转 8×8 比特矩阵。最后一步是替换每个 8 位字节。

8×8 比特矩阵需要 64×64 的依赖矩阵。这太大了，无法清晰显示，所以我将显示密码的缩影。让我们使用一个 3×3 的比特矩阵，它有一个 9×9 的依赖矩阵。这个密码将被分析两次，一次使用扩散，一次使用饱和。先扩散。让我们从标记文本块和依赖矩阵中的位开始，就像这样:

![12-unnumb-31](img/12-unnumb-31.png)

在第一轮之前，每个比特只依赖于它自己，所以依赖矩阵看起来像(1)。在第一轮替换之后，每一位都依赖于其字符中的所有 3 位，因此依赖矩阵看起来像(2)。在第一轮翻转之后，依赖矩阵看起来像(3)。第二轮替换后，依赖矩阵看起来像(4)。

![12-unnumb-32](img/12-unnumb-32.png)

换句话说，在这一点上，密文的每一位都依赖于明文的每一位。这将在第二轮翻转和最后一次替换后保持不变。因此，如果我们只依赖于依赖性计算，我们会得出结论，这个密码在两轮后是安全的。这是不真实的。阿迪·萨莫尔已经表明，两轮是不够的。

现在让我们用饱和度指数来分析 SFlip 密码 。在第一轮替换之后，密文的每一位取决于 3 个对应明文位中的每一位的 1/3。饱和矩阵将看起来像(5)。在第一轮翻转之后，饱和度矩阵将看起来像(6)。

![12-unnumb-33](img/12-unnumb-33.png)

第二轮替换使得输出的每个比特依赖于第一轮明文的所有 9 个比特。饱和系数为 1/3+(1/3)/2+(1/3)/4 = 1/3+1/6+1/12 = 7/12，约为. 583。饱和矩阵中的每个元素都有这个值，所以饱和指数是 7/12。饱和度指数的目标值是 1，但是如果您想要更大的确定性，可以将它设置得更高。这是几个回合后的饱和指数。

![12-unnumb-34](img/12-unnumb-34.png)

因此，3 轮对于 3×3 密码是足够的，但是 5 轮对于 8×8 密码是必要的。

现在让我们来看看输出单元依赖于一个或多个输入单元的其他情况。

当一个 S 盒既有明文又有密钥输入时，比方说 p 个明文单元和 k 个密钥单元，其每个输出单元的依赖性将是 1/(p+k)。例如，如果输入是 6 个密钥位和 4 个明文位，则每个输出位的相关性将是 1/10。如果 S-box 的输入本身依赖于先前的输入，则应酌情使用 S1 或 S2 计算来计算饱和指数。

类似地，如果两个或多个单元使用异或或一些其他组合功能组合，则对于 n 个总输入，相关性为 1/n。饱和指数的计算与具有相同输入的 S 盒相同。

当 k 比特的密钥用于转置时，转置的每个输出单元对每个密钥比特具有 1/k 的依赖性，并且对明文输入具有 1 的依赖性。假设一个明文字符 p 通过换位从位置 a 移动到位置 b。除了对应于转置键的位的那些列之外，转置之后的 p 的饱和向量将与转置之前的 p 的饱和向量相同。在这些列中，饱和系数将由 S1 或 S2 计算确定。

这里有一个例子。假设 t 是变调密钥的一个比特。如果 p 在转置之前不依赖于 t，即其饱和向量的 t 列中有一个 0，那么转置之后 t 列中的值将是 1/k。另一方面，如果 p 已经依赖于密钥位 t，那么饱和系数将由 S2 计算确定。如果 t 列中的系数是 x，那么在转置之后，如果 x ≥ 1/k，则 t 列中的饱和系数将是 x+1/2k，或者如果 x < 1/k ，则是 1/k+x/2。

当 k 比特的密钥被用于混合替换步骤的字母表或表时，混合的字母表或表对该密钥的每个比特具有 1/k 的依赖性。每次使用该字母表替换一个字符时，输出字符都会对密钥的每一位产生额外的 1/k 依赖性。这与使用 S1 或 S2 计算的输入字符(和替换键，如果有的话)的依赖性相结合，以获得输出 字符的饱和系数。

## 总结

分组密码在实践中是不可破解的，如果它遵守*所有这些*规则:

1.  它有足够大的块大小。目前的标准是 16 个字符或 128 位。

2.  它有一个足够大的密钥。目前的标准是 128 到 256 位。密钥必须至少与块一样大，最好更大。

3.  它要么使用强非线性的固定 S 盒，要么使用使用大密钥混合的可变替换表。

4.  饱和指数至少为 1。

一如既往的保守。给自己建立一个安全的误差范围。由于计算机速度越来越快，新的攻击不断被发现，所以要使密钥更长，并使用比所需更多的轮次。特别是，你可以将你的目标设定为高于 1 的饱和指数，也许是 2，3，甚至是 5。*******************