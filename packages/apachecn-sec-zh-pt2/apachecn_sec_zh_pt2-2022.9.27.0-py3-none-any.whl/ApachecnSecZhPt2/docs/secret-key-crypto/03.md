# 三、初步概念

本章 涵盖

*   比特和字节
*   函数和布尔运算符
*   素数和模运算

在我们进入正题之前，让我们先来看一些初步的概念。我很快地浏览了这些话题，因为现在学校里，甚至是低年级都在教授这些观点。根据需要，本书后面会给出更多的基本思想。

## 3.1 位和字节

数据 以*位*的形式存储在计算机中，是*二进制数字*的简写。一个位只是一个数值，它的值可以是 0 或 1。一个比特可以用几种方式存储在计算机中。开关可以打开或关闭。磁铁的北极可以朝上也可以朝下。光可以顺时针或逆时针偏振。电脉冲可以有小振幅，也可以有大振幅。

这些二进制数字可以用来组成二进制数。以下是三位二进制数及其十进制等效值。这些 3 位数字被称为*八进制*数字 ，意思是它们是以 8 为基数的数字:

![3-unnumb-1](img/3-unnumb-1.png)

位在计算机逻辑中也用来表示*逻辑值* 或*真值* 。0 代表逻辑值*假*，1 代表逻辑值*真*。

一个字符，比如一个字母或者一个数字，可以用一个 8 位二进制数来表示，这个 8 位二进制数叫做一个*字节*。术语*字节*是由 IBM 的沃纳布赫霍尔茨在 1954 年创造的。由于每个位有 2 个可能的值，所以 8 位可以表示 2 个 <sup class="fm-superscript">8 个</sup>不同的字符:也就是 2 的 8 次方，也就是 256。这对于 26 个小写字母、26 个大写字母、10 个十进制数字、33 个标点符号如=和$加上一些控制字符如制表符和换行符就足够了。

有几种方案允许表示额外的字符，例如西里尔ж语、阿拉伯语 س语，甚至中文是，每个语标最多使用 4 个字节。这些都与我们无关。密码可以处理字符串，而不考虑它们的含义。被加密的字节可能是代表一些中文语标的 4 个字节中的第三个字节，这是无关紧要的。

为了我们的目的，一个字节有 3 个身份:(1)它是一个由 8 个逻辑真/假值组成的字符串；(2)它是 8 位二进制数，因此是 0 到 255 之间的整数，包括 0 和 255，以及(3)它是某些字符的表示，例如字母、数字、标点符号，或者是 语标的一部分。

## 3.2 函数和运算符

数学 函数现在在学校的小学年级都有教，所以我确定我不需要解释这个概念，但是建立一些符号和术语是有帮助的。函数接受一个或多个值，并产生另一个值作为结果。取的值称为函数的*输入* 或*参数* ，返回的值称为*输出* 或*结果* 。我们说你*将函数*应用于参数以产生结果。

一个函数可以用一个符号来表示，比如+,也可以用一个字母来表示。当一个符号被使用时，它被称为一个*运算符*，所以+和×是运算符，自变量被称为*操作数*。当函数有一个参数时，符号可以放在参数的前面，如-5 或 √ 9，或者放在参数的后面，如 5 ！(5 阶乘，即 1×2×3×4×5 = 120)。如果有两个参数，则符号放在它们之间，如 3+4 或 6×7。当符号是字母时，参数被括在括号中，如 f(x)。函数用 f 表示，参数用 x 表示。如果有多个参数，则用逗号分隔，如 f(a，b，c)。一些关于计算机语言的书区分了变量和参数，但这在这里并不重要。

## 3.3 布尔运算符

只是 作为加、减、乘以及类似的函数，对数字进行运算，还有几个函数在表示真值时对比特进行运算。为了纪念英国数学家乔治·布尔，这些函数被称为*逻辑运算符* ，或者*布尔运算符*。

如果 A 和 B 为真值，那么逻辑函数**非** 、**与** 、**或** 与**异或** 定义如下:

**非** A 为假则 A 为真，A 为真则 A 为假。

A **和** B 如果 A 和 B 都为真，则为真，否则为假。

如果 A 或 B 或两者都为真，则 A **或** B 为真，否则为假。

如果 A 或 B 中恰好有一个为真，则 A **xor** B 为真，否则为假。

换句话说，如果 A 为真，B 为假，或者 B 为真，A 为假，A **xor** B 为真。**异或**被称为*异或*运算符 。它通常用符号⊕t11】来表示，一个里面带+的圆。****或**运算符通常用符号 ∧ 和 ∨ 表示。很容易记住哪个是哪个，因为代表**和**的符号 ∧ 看起来像没有横杠的大写字母 A。**

 **以下是表格形式的四个布尔函数的值:

![3-unnumb-2](img/3-unnumb-2.png)

通过对相应的比特对进行运算，这四个运算符可以从单个比特扩展为比特串。如果 A 是 0011，表示逻辑值假、假、真、真的四位串，并且如果 B 是 0101，表示逻辑值假、真、假、真，则应用四个布尔运算符给出

![3-unnumb-3](img/3-unnumb-3.png)

异或运算符广泛用于密码学中。例如，一次性密码本(见第 14 章)的一个简单实现是对消息的字节和密钥流的字节进行异或运算，如下所示:

![3-unnumb-4](img/3-unnumb-4.png)

## 3.4 基数

在 普通算术中，数字用十进制记数法表示。这种符号是由印度人和阿拉伯人在 5 世纪和 7 世纪之间的某个时候发明的。因此十进制数字也被称为*阿拉伯数字* 。这个系统是由比萨的莱昂纳多(莱昂纳多 比萨诺)引入欧洲的，在他那个时代被称为斐波那契。

历史花絮

在列奥纳多的时代，大约是 1175-1250 年，滑块拼图风靡一时。(有些人认为这个谜题与 1874 年诺伊斯·查普曼发明的十五个谜题相同。现金奖励的公开竞赛很常见。莱昂纳多是解决这个难题的奇才。他每次都赢。他的竞争对手给了他一个戏谑的名字“斐波那契”，意思是“笨蛋”，列奥纳多欣然接受了这个名字。斐波那契在整个意大利都很出名。当斐波那契在 1202 年写下他的 *Liber Abaci* (计算之书)时，他想让人们知道它的作者是著名的斐波那契。这么直接说是自吹自擂，有失尊严，所以他在扉页上写了 *Filius Bonacci* ，意思可能是“幸运之子”或“Bonacci 之子”。

后来的作者没有领会这个意图，并且拒绝了伟大的莱昂纳多·皮萨诺应该被称为“笨蛋”的想法他们推测达芬奇的姓可能是博纳奇。出于同样的原因，为了提醒他的读者，他是著名的斐波那契，在他的私人作品中，莱昂纳多有时狡猾地称自己为莱昂纳多·博纳契(幸运的莱昂纳多)。

随着时间的推移，人们忘记了菲波纳奇这个谜题天才的名字和名声，直到 1836 年，藏书家、臭名昭著的偷书贼古列尔莫·利布里(Guglielmo Libri)把这些碎片拼凑起来，发现了*菲利斯* + *波纳奇* = *菲波纳奇*。术语*斐波那契数列* 和*斐波那契数列* 大约是由法国数学家爱德华·卢卡斯在 1870 年创造的。

好了，回去工作吧。为了解释十进制数，我们使用*指数符号* 。指数意味着一个数要乘以它自身的特定次数。比如 5 <sup class="fm-superscript">3</sup> 就是 5 乘以自身 3 倍，即 5×5×5，也就是 125。在指数表达式 B <sup class="fm-superscript">E</sup> 中，读作“B 的 E 次方”，或简称为“B 的 E 次方”，B 称为*底数*，E 称为*指数* 。如果 N 是任意数，那么 N <sup class="fm-superscript">1</sup> 就是 N 本身。按照惯例，对于除 0 之外的任何数 N，N <sup class="fm-superscript">0</sup> 都是 1。术语 0 <sup class="fm-superscript">0</sup> 没有定义的值，因为评估 0 <sup class="fm-superscript">0</sup> 的不同方式会导致不同的结果。

当我们写一个十进制数，或以 10 为基数的数，如 3456，它的意思是 3×1000+4×100+5×10+6×1。使用指数表示法，这与 3×10<sup class="fm-superscript">3</sup>+4×10<sup class="fm-superscript">2</sup>+5×10<sup class="fm-superscript">1</sup>+6×10<sup class="fm-superscript">0</sup>相同。从右边开始，低阶数字(在本例中为 6)乘以 1，下一个数字(即 5)乘以 10，下一个数字乘以 10 <sup class="fm-superscript">2</sup> ，然后是 10 <sup class="fm-superscript">3</sup> ，依此类推。如果有 50 位数字，左边的高位数字将乘以 10 <sup class="fm-superscript">49</sup> 。

在其他基数上也是如此。比如二进制用的基数是 2。二进制数 11001 求值为 1×2<sup class="fm-superscript">4</sup>+1×2<sup class="fm-superscript">3</sup>+0×2<sup class="fm-superscript">2</sup>+0×2<sup class="fm-superscript">1</sup>+1×2<sup class="fm-superscript">0</sup>，或者 16+8+0+0+1，也就是 25。计算机工作中常用的一个数基数是*十六进制*或基数 16。以 16 为基数的数字是 0123456789ABCDEF 或 0123456789abcdef。为此，我更喜欢使用大写字母 ABCDEF，因为它使所有的十六进制数字具有相同的高度，这样更容易阅读。十六进制数 9AB 将被计算为 9×16<sup class="fm-superscript">2</sup>+10×16<sup class="fm-superscript">1</sup>+11×16<sup class="fm-superscript">0</sup>，或者 9×256+10×16+11，这是十进制记数法中的 2475。

在密码学中，基数的一个用途是将文本转换成数字。将字母表中的 26 个字母与基数为 26 的数字联系起来是很自然的，就像这样:

![3-unnumb-5](img/3-unnumb-5.png)

单词 WORK 可以表示为一个数字 22×26<sup class="fm-superscript">3</sup>+14×26<sup class="fm-superscript">2</sup>+17×26+10，即 396，588。这个值可以像任何数字一样被操作，例如通过加、减或乘。

大数可以用指数记数法表示，也叫*科学*记数法 ，像这样:1.23×10 <sup class="fm-superscript">7</sup> 。这是 1.23 与 10 个 <sup class="fm-superscript">7</sup> 的乘积，是 1000 万，所以 1.23×10 个 <sup class="fm-superscript">7</sup> 是 1230 万。这和取 1.23，将小数点后 7 位向右移动 是一样的。

## 3.5 质数

数字，特别是大于 1 的整数，被分类为*素数*或*合数*。如果数是两个较小的正整数的乘积，则称之为合数；否则就是质数。前几个合数是 4 = 2×2，6 = 2×3，8 = 2×4，9 = 3×3。前几个质数是 2，3，5，7 和 11。数字 1 既不是质数，也不是合数。

质数的一个重要性质是，任何数都只能用一种方式写成质数的乘积(除了因子的顺序)。比如，由于 30 = 2×3×5，所以除了 2、3、5 之外，没有一个质数能把 30 整除。这里 2、3 和 5 被称为 30 的*质因数* 。任何整数的质因数集都是唯一的。确定一个整数的质因数称为*因式分解* 或*因式分解* 。

如果两个整数 A 和 B 没有共同的质因数，那么称它们为*互质*T3】或*互质* 。比如 20 和 27 互质。如果 N 是整数，那么 N 和 1 总是互质的，而 N 和 0 只有在 N = 1 时才互质。N 和 N+1 总是互质的。

利用正整数，当任意一个数 A 除以另一个数 B，称为*除数* ，结果是一个*商* 和一个*余数* 。称之为商 Q 和余数 R，那么 Q 定义为使 QB 不超过 A 的最大整数，余数表示还剩多少，即 R = A-QB。注意 0 ≤ R < N .比如假设 A 是 40，B 是 11。11 不超过 40 的最大倍数是 33，所以商是 3，因为 3×11 = 33。余数是 7，因为 40-33 是 7。

## 3.6 模运算

对余数的研究叫做*模运算*。哥廷根大学的数学家卡尔·弗里德里希·高斯于 1801 年引入了模运算。在模算术中，商被忽略，除数被称为*模数* ，余数被称为*余数* 。在前面的例子中，模数是 11，余数是 7。如果模数为 N，两个数 X 和 Y 有相同的余，我们说 X 和 Y 是*同余模* *N* ，或者等价地说，X 和 Y 在同一个*余类* 模 N，这就写成 X≡ Y (mod N)。比如 40≡7 (mod 11)，那么 40 和 7 在同一个模 11 的剩余类中。当 X-Y 是 N 的倍数时，或者等价地，当 X = Y+aN 时，对于某个整数 a，X 和 Y 对模 N 是全等的。

剩余类遵循与普通整数相同的算术规则，例如

![3-unnumb-6](img/3-unnumb-6.png)

我们称-a 为 a 的*加逆* ，记数法 a-b 可以认为是 a+(-b)的简写。

情况为*乘逆* 比较复杂。同余 ax≡b (mod N)有 3 种情况需要考虑:(1)当 a 和 N 互质时，(2)当 a 和 N 有一个不整除 b 的公因数 d 时，(3)当 a、b 和 N 都被公因数 d 整除时。

1.  假设 a 和 N 互为质数。然后有一个唯一剩余 a '是模 N 的乘法逆，所以 aa'≡1 (mod N)和 a'a≡1 (mod N)。如果 a '存在，那么同余 ax≡b (mod N)很容易解出为 x≡a'b (mod N)。在 15.3.2 节中，我给出了当 N 很大时计算 a '的有效方法。

2.  如果 a 和 N 有一个公因数 d > 1，那么 a 没有模 N 的乘法逆，不可能有 a’使得 aa’≡1(mod N)。如果 b 不能被 d 整除，那么 ax≡b (mod N)无解。比如 4x≡5 (mod 12)无解。

3.  设 d 是 a 和 N 的最大公约数，记为 gcd (a，N)。即 d 是能把 a 和 N 都整除的最大整数，如果 a，b，N 都可以被 d 整除，那么你就可以把 a，b，N 除以 d 来化简同余，即(a/d)x≡(b/d) (mod N/d)。

让我们来看一个例子。考虑同余式 8x≦4(mod 12)。除以 4 得到简化的同余式 2x≡1 (mod 3)。这个同余式的解是 x≡2 (mod 3)，这意味着 x 可以是 3n+2 形式的任何整数。回到原来的同余式，x 是模 12 的余数，所以 x 必须在 0 到 11 的范围内，包括 0 和 11。落入该范围的 3n+2 型的数目是 2、5、8 和 11。这意味着 x 的值可以是 2、5、8 或 11 中的任何一个。所以同余 8x≡4 (mod 12)有 4 个解。

在本书的后面， **mod** 被用作算术运算符。表达式 x mod y，其中 x 为整数，y 为正整数，表示 x 除以 y 后的余数，因此 27 mod 3 为 0，27 mod 4 为 3，27 mod 5 为 2。**