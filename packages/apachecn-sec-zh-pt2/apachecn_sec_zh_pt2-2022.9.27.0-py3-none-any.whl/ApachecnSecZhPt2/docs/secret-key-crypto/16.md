# 十六、三重传递协议

本章涵盖

*   基于幂运算的三重传递协议
*   基于矩阵乘法的三重传递协议
*   基于双边矩阵乘法的三重传递协议

第 2.2 节 和第 2.3 节描述了现代密码学如何分为 3 个分支，机密密钥、公开密钥和个人密钥。到目前为止，这本书只描述了密钥加密的方法。公钥密码学在很多书中都有描述，这里就不赘述了。本章将讨论个人密钥加密，这是不太为人所知的第三个加密分支。个人密钥加密有时被称为*无密钥*加密，因为双方不需要传输或共享任何密钥。

个人密钥加密的基本概念是两个通信者桑德拉和丽娃都有她自己的个人密钥。这个密钥从不与任何其他人传输或共享，甚至彼此之间也不共享，因此 Emily 不可能通过窃听、截取广播或任何其他形式的窃听得知任何个人密钥。个人密钥加密的最大优点是你不需要预先设置任何东西。交换密钥不需要任何机密、安全的通道。这些信息可以在公共频道上交换。不需要关键服务器或其他基础设施。

个人密钥加密是通过*三次通过协议* 来完成的，该协议是由以色列魏茨曼研究所的阿迪·萨莫尔在大约 1975 年发明的。为了说明这个方法，我设计了一个小故事:

从前有一个国王，他爱上了邻国的王后。为了向王后求爱，国王想送她一颗珍贵的宝石。国王有一个密封的保险箱和一把防盗锁。但是他怎么能把钥匙寄出去呢？如果信差既有钥匙又有保险箱，他就可以打开保险箱偷走宝石。国王可以派第二个信使去送钥匙，但是他担心这两个信使会在路上相遇，一起偷走宝石。女王提出了一个巧妙的解决方案。

国王会把他的锁放在保险箱上，然后把它送给王后。然后，她会添加自己的锁，并将保险箱连同两把锁一起寄回。然后国王会用他的钥匙打开他的锁，把保险箱和皇后的锁一起送回去。然后她可以用自己的钥匙打开盒子，拿到宝石。

这里两把锁是两种加密的替身，两把钥匙代表相应的解密。该消息将用发送者的加密函数加密，发送给接收者，用接收者的加密函数加密，发送回发送者，用发送者的解密函数解密，发送回接收者，用接收者的解密函数解密。这意味着消息被发送 3 次，因此得名*三重通过协议*。

***** 我们来分解一下。设消息是 M，桑德拉的加密和解密函数是 S 和 S’，丽娃的加密和解密函数是 R and R’。在第一次传递中，桑德拉用她的加密函数 S 加密了消息 M，并将消息 M 发送给丽娃。在第二次传递中，丽娃用她自己的加密函数 R 加密消息 SM，并将双重加密的消息 RSM 发送回桑德拉。在第三次传递中，Sandra 将她的解密函数 S '应用于消息 RSM 以获得 S'RSM。这是为了移除 S 加密。只有当 R 和 S 交换，或者 S 和 R 交换时，它才会这样做。这意味着 S'RSM = RS'SM = RM。这让丽娃解除了她的加密，阅读信息。

因此，为了让这种三重方案发挥作用，我们需要找到一个可交换的加密函数，或者两个可以相互交换的加密函数。我能马上想到 3 种交换加密函数:加法、乘法和异或。很容易想象一种加密，其中有一个与消息长度相同的密钥，加密包括将密钥逐字节添加到消息中，或将消息字节乘以密钥字节，或将消息与密钥进行异或运算。这些都是一次性密码本的简单形式。

这些都不安全。如果 Emily 设法获得所有三条加密信息，她就可以轻松地解除加密。如果函数是加法，则 3 条消息是 M+S、M+S+R 和 M+R。如果 Emily 将第一条和第三条消息相加，并减去第二条消息，则她得到(M+S)+(M+R)-(M+S+R) = M。结果正好是 M。当加密函数是乘法时，同样的方法也适用。这 3 个消息是(M×S)、(M×R)和(M×S×R)。再次取(M×S)×(M×R)÷(M×S×R)得到 M。当加密函数是异或时，求 M 甚至更简单，因为异或是它自己的逆。简单地将 3 条加密的消息异或在一起，结果就是原始消息，(m⊕s)⊕(m⊕r)⊕(m⊕s⊕r)= m

互换的两个加密函数是替换和换位。这些也是没有安全感的。由于 Emily 将在换位之前和之后都看到消息，所以她可以很容易地确定换位。

那么，所需要的是一对互换的加密函数 S 和 R，并且使得 Emily 不能确定 M，即使她有 SM、RSM 和 RM。

## 16.1 沙米尔法

Shamir 对这个问题的解决方案是使用幂运算。设 p 是一个大素数，比如在 300 到 600 个十进制数字的范围内。桑德拉将选择一个加密指数 s。对应的解密指数是 s ′,使得 ss′≡1(mod p-1)。这是根据费马小定理得出的，如果 0 < a < p，那么 a <sup class="fm-superscript">p-1</sup> ≡1 (mod p)。14.4.2 节描述了如何选择素数 p，15.4 节描述了如何确定 s’。以同样的方式，丽娃选择她的加密和解密指数，r 和 r’。两次加密互换是因为(M<sup class="fm-superscript">s</sup>)<sup class="fm-superscript">r</sup>= M<sup class="fm-superscript">Sr</sup>= M<sup class="fm-superscript">RS</sup>=(M<sup class="fm-superscript">r</sup>)<sup class="fm-superscript">s</sup>。

桑德拉计算(M <sup class="fm-superscript">s</sup> mod p)并把它发送给丽娃。丽娃计算(M <sup class="fm-superscript">sr</sup> mod p)并将其发送回桑德拉。桑德拉计算(M<sup class="fm-superscript">SRS</sup>' mod p)=(M<sup class="fm-superscript">r</sup>mod p)并将其发送回丽娃，后者最终计算(M <sup class="fm-superscript">rr</sup> ' mod p) = M，这就是原始消息。该方法被认为是安全的，因为确定 s 或 r 需要解决离散对数问题。正如 14.4 节所讨论的，这个问题在计算上是困难的。没有已知的计算上可行的算法。

这个方法非常慢。所有这些大数的指数运算和模约简都需要大量的计算。下一节将描述一个解决方案的尝试。

## 16.2 梅西-大村

*梅西-大村* 法是苏黎世联邦理工学院的詹姆斯·梅西和加州大学洛杉矶分校的吉姆·k·大村于 1982 年发明的。(他的名字在专利上被列为吉米·大村。他是我在麻省理工学院的同学，虽然我不记得他了。)Massey-Omura 系统基本上与 Shamir 系统相同，除了模数是 2 <sup class="fm-superscript">k</sup> 的形式。这意味着余数模 2 <sup class="fm-superscript">k</sup> 可以简单地通过取数的低阶 k 位来计算。这比计算余数模 p 要快得多，余数模 p 基本上是通过使用这些 300 到 600 位数的长除法来完成的。

在计算机械协会(ACM)和电气和电子工程师协会(IEEE )的出版物中，关于哪种方法更快的问题争论了好几年。

## 16.3 离散对数

Diffie-Hellman 密钥交换的 安全性、Shamir 三重通过协议和 Massey-Omura 方法都依赖于解决离散对数问题的难度。这个问题的三种流行算法是穷举算法，好到 10 <sup class="fm-superscript">12</sup> ，丹尼尔·桑克斯的 小步大步算法，好到 10 <sup class="fm-superscript">18</sup> ，约翰·波拉德的 rho 算法，好到 10 <sup class="fm-superscript">22</sup> 。但是，我们需要一个适合 10 <sup class="fm-superscript">300</sup> 的算法。为了让大家感受一下离散对数有多难，让我们来看一个求解它的综合方法。这不是你在家里用电脑就能做到的。它需要一台大容量存储的大型机，或者一个由许多协同工作的 pc 机组成的网络。或者，你可以跳过这一节，直接接受离散对数问题很难的事实。

### 16.3.1 对数

从考虑计算机出现之前人们如何计算普通对数开始 。一种方法是取一个像 b = 1.000001 这样的数，然后费力地取它的连续幂。你会发现 b <sup class="fm-superscript">693148</sup> 是最接近 2 的幂，b <sup class="fm-superscript">2302586</sup> 是最接近 10 的幂。那么你就会知道 log <sub class="fm-subscript">10</sub> (2)非常接近 693148/2302586，也就是. 3010302。正确的值是. 3010300，所以这个方法给出了一个很好的近似值。

你可以在一个环中做同样的事情，比如整数对某个素数 p 取模。假设桑德拉发送消息 6 mod 13，丽娃返回消息 7 mod 13。艾米丽想知道丽娃用什么指数来加密。您将使用模数 13 的原始根，而不是 1.000001 的幂，例如 2。有了这么小的模数，埃米莉可以很容易地计算出 2 的 13 次方。

![16-unnumb-1](img/16-unnumb-1.png)

艾米丽现在知道桑德拉寄出了 2 张 <sup class="fm-superscript">5 张</sup>，丽娃寄回了 2 张 <sup class="fm-superscript">11 张</sup>。所以(2<sup class="fm-superscript">5</sup>)<sup class="fm-superscript">r</sup>≡2<sup class="fm-superscript">5r</sup>≡2<sup class="fm-superscript">11</sup>(mod 13)。这意味着 5r≡11 (mod 12)。你可以用脑子解决这个问题。只要想想 11+12 = 23，23+12 = 35。因为 35 是 5 的倍数，即 5×7，这意味着 r 必须是 7。可以用手摇计算器查一下，6 <sup class="fm-superscript">7</sup> = 279936≡7 (mod 13)。桑德拉寄出了 6 张，丽娃寄回了 7 张，所以这张支票与相符。

### 质数的幂

穷举 枚举给了 Emily 一种搜索方式，但是当 p 很大的时候那就不行了。让我们试试约翰·波拉德的 *rho 算法*中的一个想法。第一步是生成模 p 的多个幂序列，并寻找重复。Emily 可以同时使用几个原始根，每个核心一个根。现在让我们加倍。如果 b 是以 p 为模的本原根，她可以计算出 b <sup class="fm-superscript">2</sup> ，b <sup class="fm-superscript">3</sup> ，b <sup class="fm-superscript">4</sup> ，b <sup class="fm-superscript">5</sup> ，...(mod p)和 b <sup class="fm-superscript">2</sup> ，b <sup class="fm-superscript">4</sup> ，b <sup class="fm-superscript">8</sup> ，b <sup class="fm-superscript">16</sup> ，...(mod p)在另一个处理器上。艾米莉使用的每个原始根都有两套独立的异能序列。

除了原始根，艾米莉还可以直接查。桑德拉发送短信，丽娃回复短信。艾米丽可以生成序列(SM) <sup class="fm-superscript">2</sup> 、(SM) <sup class="fm-superscript">3</sup> 、(SM) <sup class="fm-superscript">4</sup> 、(SM) <sup class="fm-superscript">5</sup> ，...以及(SM) <sup class="fm-superscript">2</sup> 、(SM) <sup class="fm-superscript">4</sup> 、(SM) <sup class="fm-superscript">8</sup> 、(SM) <sup class="fm-superscript">16</sup> 、...，对于 RSM 也是如此。这给了艾米丽四种不同的能力。

除了这些有序的异能序列，她还可以生成一些无序的序列。这些俗称*乱走* 或者*醉走* 。一种方法是将最后产生的功率平方，然后乘以之前的一个功率。艾米莉可以随机选择早期异能，或者她可以使用列表中的中间元素。比如说，假设她已经拥有了异能 x，x <sup class="fm-superscript">2</sup> ，x <sup class="fm-superscript">4</sup> ，x <sup class="fm-superscript">8</sup> 和 x <sup class="fm-superscript">16</sup> 。对于下一次幂，她可以平方 x <sup class="fm-superscript">16</sup> 得到 x <sup class="fm-superscript">32</sup> ，然后乘以比如说 x <sup class="fm-superscript">2</sup> 得到 x <sup class="fm-superscript">34</sup> 。对于下面的幂，她将乘 x <sup class="fm-superscript">34</sup> 得到 x <sup class="fm-superscript">68</sup> ，然后乘以另一个列表元素，比如 x <sup class="fm-superscript">8</sup> ，得到 x <sup class="fm-superscript">76</sup> 。诸如此类。

Emily 可以产生的另一种形式的随机游走使用 2 或 3 个素数。每个基素数应该是一个本原根。从这些素数的乘积开始。为了生成下一个乘积，她会随机选择一个素数，然后乘以它。艾米莉进行的序列越多，她就会越早开始得到 的结果。

### 16.3.3 碰撞

好的 ，现在艾米丽有了所有这些序列。然后呢？她在寻找出现在两个列表中的同一个号码。这叫做*碰撞* ，或者*碰撞* 。假设她找到 3<sup class="fm-superscript">172964</sup>≡103<sup class="fm-superscript">4298755</sup>(mod p)。这让她通过求解同余式 172964r≡4298755 (mod p-1)将 103 表示为 3 的幂(mod p)。第 15.4 节描述了该方法。一旦她积累了足够多的崩溃，她可以建立一个链，例如 RSM≡19 <sup class="fm-superscript">a</sup> ，19≡773 <sup class="fm-superscript">b</sup> ，773≡131 <sup class="fm-superscript">c</sup> ，...，103 <sup class="fm-superscript">y</sup> ≡(SM) <sup class="fm-superscript">z</sup> 。将所有指数乘以模 p-1，她将得到 RSM ≦( SM)<sup class="fm-superscript">r</sup>(mod p)。指数 r 是丽娃的加密函数。艾米丽破解了密码。

那并不像听起来那么简单。当 p 是一个 300 位数的质数时，在她开始看到任何崩溃之前，她需要 10 的 150 次方个 T2。如果艾米丽有 1，000，000 个处理器以每秒 1，000，000 次的速度运行，她每年可能产生 3×10 <sup class="fm-superscript">19</sup> 。这意味着她将需要大约 10 年才能看到任何结果，而在她能够建立这样一个链条之前，时间将会更长。此外，它将占用 10 个 <sup class="fm-superscript">150 个</sup>字节的 存储空间。

### 16.3.4 保理

代替搜索崩溃的 ，每次产生新的电力时，艾米丽可以尝试以 p 为模因式分解它的余数。假设她成功地因式分解 97<sup class="fm-superscript">a</sup>(mod p)的余数，并找到 97<sup class="fm-superscript">a</sup>≡11<sup class="fm-superscript">b</sup>29<sup class="fm-superscript">c</sup>83<sup class="fm-superscript">d</sup>(mod p)。她能解出 97 的同余。设 a 模 p-1 的乘法逆为 a’。把同余提高到 a 的幂。97<sup class="fm-superscript">aa</sup>'≡97≡11<sup class="fm-superscript">b</sup>29<sup class="fm-superscript">c</sup>83<sup class="fm-superscript">d</sup>)<sup class="fm-superscript">a</sup>'(mod p)。在将所有的指数相乘并以 p-1 为模对它们进行归约之后，对于某些值 e、f 和 g，结果是 97≡11<sup class="fm-superscript">e</sup>29<sup class="fm-superscript">f</sup>83<sup class="fm-superscript">g</sup>(mod p)(如果 p 有 300 位，实际值可以达到 300 位)。)一旦她有了一个基本素数的表达式，在这种情况下是 97，她就可以将该值代入所有的因式分解的乘积，既包括她已经有的乘积，也包括她以后将找到的乘积。

艾米莉将无法计算出每种能力的余数。因式分解一个 300 位数非常困难，意味着非常耗时。最好的策略是选择一个固定的素数基集 F(B)，比如所有的素数都达到 B = 10 <sup class="fm-superscript">6</sup> ，或者可能达到 B = 10 <sup class="fm-superscript">7</sup> 。F(B)称为*因子基* 。尝试仅使用因数库中的质数来因数化每个幂。可以这样分解的数字称为 *B-smooth* 。随着数字越来越大，B-smooth 的比例越来越小。在 300 位数中， B 平滑数很少。当艾米丽找到每一个因子时，数字中未被因子化的部分就会缩小。如果她已经尝试了基本集合中的所有素数，并且还剩下一些未因子化的数，她就不应该再尝试因子化它了。更有效的方法是放弃这种能力，转而使用下一种能力。

下面是 Emily 必须做的事情:继续生成乘积并因式分解它们的余数模 p。只保留 B-smooth 数，丢弃其余的。检查 B-smooth 数字中的崩溃。每次发现崩溃时，求解乘积中最大素数的同余，这样就需要越来越少的基素数来表示每个乘积。她可能会保留一个或多个处理器专门用于这个任务。

设 q <sup class="fm-superscript">n</sup> 是一个素数的幂，设其余模 p 为 x，试着用基集合 B 中的素数对 x 进行因子分解，如果 x 不是 B-光滑的，试着对数字 x+p，x+2p，x+3p，...对 301 位或 302 位的数字进行因式分解并不比对 300 位的数字进行因式分解困难多少。为每种残留物设定一个固定的试验次数，比如 10 次试验。

当她产生这些能力时，她需要特别强调 SM 和 RSM。记住，这个练习的目标是找到指数 r，使得(SM) <sup class="fm-superscript">r</sup> ≡RSM (mod p)。在她用基素数的幂表示 SM 和 RSM 之前，她不能这样做。首先，她应该开发 SM 和 RSM 的多个幂序列。一旦她成功地找到了这样一个表达式，她就在这个表达式中寻找那些还没有用较小素数的幂来表示的素数。接下来把重点放在这些质数上。继续，直到 SM 和 RSM 都表示为单个素数的幂。她现在可以使用第 15.3.2 节的 方法找到 r。

### 16.3.5 估算

假设 她用了 10 个 <sup class="fm-superscript">6 个</sup>基素数，也就是直到 B = 15,485,863 的素数。用一个素数来表达所有这些将需要 10 个 <sup class="fm-superscript">6 个</sup>同余式。存储这些需要 10 <sup class="fm-superscript">6</sup> ×10 <sup class="fm-superscript">6</sup> 的指数矩阵。矩阵最初是稀疏的，但随着求解的进行，它会变得密集，因此稀疏矩阵技术不会有好处。每个指数都是一个 300 位数。这需要大约 10 <sup class="fm-superscript">15</sup> 字节或者一*Pb*T16】的存储空间。截至本文撰写之时(2022 年 3 月)，世界上最大的超级计算机是橡树岭国家实验室的峰会计算机，它拥有 2.76 千兆字节的可寻址存储。

运行时间显然取决于找到 B-smooth 数需要多长时间。B-smooth 数的密度由 de Bruijn 函数ψ(p，B)给出，它给出了小于 p 的 B-smooth 整数的个数，它是由荷兰数学家 Nicolaas Govert de Bruijn 研究的。ψ(x，x <sup class="fm-superscript">1/u</sup> 的值由 x ρ (u)近似得出，其中 ρ (u)是精算师卡尔·迪克曼发明的迪克曼函数。迪克曼函数 ρ (u)近似为 u <sup class="fm-superscript">-u</sup> 。在这种情况下，x = 10 <sup class="fm-superscript">300</sup> ，x <sup class="fm-superscript">1/u</sup> = 15，485，863，因此 u = 41.725。因此，将花费大约 41.725<sup class="fm-superscript">41.725</sup>= 4.08×10<sup class="fm-superscript">67</sup>来尝试找到每个 B-smooth 数。

总共需要超过 10 次 <sup class="fm-superscript">73 次</sup>试验才能找到 10 次 <sup class="fm-superscript">6 次</sup> B 级平滑能力。因式分解每一个数字可能会占用多达 10 个 <sup class="fm-superscript">6 个</sup>8 个试分，所以总共有 10 个 <sup class="fm-superscript">79 个</sup>试分。由于数字是 300 位，每个试除法将进行 300 次运算的倍数。总共称之为 10 <sup class="fm-superscript">82</sup> 操作。对于崩溃方法来说，这比 10 <sup class="fm-superscript">150</sup> 是一个巨大的进步，但是对于现在的计算机来说仍然遥不可及。

这表明，在可预见的未来，也许是未来 20 到 30 年，300 位数已经足够了。随着量子计算机的发展，这种情况可能会改变，但目前 300 位数的 T2 T3 T4 T5 是安全的。

## 16.4 矩阵三遍协议

sha mir 和 Massey-Omura 三遍算法的方法都使用取幂运算。三遍算法的另一种方法是使用矩阵。我们以前在希尔密码 15.1 节看到过这种情况。消息被分成多个块。每个块被视为模 256 的整数向量。这个向量乘以一个模 256 的整数的可逆方阵，或者在左边或者在右边。对于三遍版本，桑德拉将具有用于加密的矩阵 S 和用于解密的矩阵 S’，而丽娃将具有加密矩阵 R 和解密矩阵 R’。这些矩阵不是模 256 的整数上的，而是 256 个元素的一个环 ***R*** 上的，报文的字符被当作这个环的元素。设消息块为 M，于是桑德拉将 SM 发送给丽娃，丽娃将 RSM 发回给桑德拉，桑德拉用 S '解密得到 S'RSM = RM。现在丽娃可以用 R '解密，即 R'RM = M

棘手的部分是使 S'RSM = RM。矩阵乘法是不可交换的，所以桑德拉和丽娃需要选择相互交换的特殊矩阵 S 和 R。需要明确的是，S 和 R 不是交换矩阵。如果随机选择一个矩阵 X，几乎可以确定 SX≦XS 和 RX≦XR。这是本质点，所以我再重复一遍，S 和 R 不是交换矩阵。它们不能与大多数其他矩阵互换。他们互相通勤。

### 16.4.1 交换矩阵族

桑德拉、T2 和丽娃需要大量供应这些基质，这样艾米丽就不能简单地全部尝试。这意味着他们需要一个大的交换矩阵家族**来为消息的每个块选择矩阵。**

 **注**ғ**是交换矩阵族，不是交换矩阵族。重要的是要理解是族是可交换的，而不是矩阵本身。几乎所有在ғ中的矩阵都是可交换的。它们会相互交换，但不会与其他矩阵交换。

构造交换族最简单的方法是从任意可逆矩阵，F 开始，取其幂，F <sup class="fm-superscript">0</sup> ，F <sup class="fm-superscript">1</sup> ，F <sup class="fm-superscript">2</sup> ，F <sup class="fm-superscript">3</sup> ，...，其中 F <sup class="fm-superscript">0</sup> 为单位矩阵 I，F <sup class="fm-superscript">1</sup> = F .称 f 为家族**【ғ**的*生成矩阵* 。

桑德拉和丽娃将分别需要为消息的每个块使用不同的矩阵，否则，给定一组足够的具有已知明文的消息块 M <sub class="fm-subscript">i</sub> ，艾米丽可能会解线性方程组 R(SM <sub class="fm-subscript">i</sub> ) = RSM <sub class="fm-subscript">i</sub> 。

### 16.4.2 乘法顺序

到 使族**ғ**大，需要寻找或构造一个高乘法阶的生成矩阵 f。即 F <sup class="fm-superscript">n</sup> = I 的最小整数 n > 0 需要大，至少 10 <sup class="fm-superscript">25</sup> ，但最好大一些。如果矩阵 F 是可逆的，这样的 n 将一直存在，F 的乘法逆 F’是 F <sup class="fm-superscript">n-1</sup> 。15.8 节给出了求可逆矩阵的方法。确定 F 的乘法阶数是有点艺术的，在 F <sup class="fm-superscript">n</sup> = I 之前取连续的幂 F 显然是不可行的，在 n > 10 <sup class="fm-superscript">25</sup> 的时候肯定不行。但这是可以做到的。

求乘法序，从 1×1 矩阵开始，即环元素。看看这些元素的乘法顺序。这些很容易通过枚举找到，因为 n 的最大可能值是 255。可能的值是 2、3、7、15、31、63、127 和 255。较大矩阵的乘法阶数往往是这些值的倍数。

假设环元素的乘法阶数恰好是 2，7，31。当你尝试 2×2 矩阵时，首先将每个矩阵 A 提升到单元素阶的倍数，比如 2 <sup class="fm-superscript">4</sup> 7 <sup class="fm-superscript">2</sup> 31 = 24304。然后列举 B = A <sup class="fm-superscript">24304</sup> 的幂。假设你发现 B <sup class="fm-superscript">52</sup> = I .你现在肯定知道 A 的乘法阶 m 整除 x = 24304×52 = 2<sup class="fm-superscript">6</sup>7<sup class="fm-superscript">2</sup>13×31，并且它是 2 <sup class="fm-superscript">6</sup> 13 的倍数。接下来你应该试试一个 <sup class="fm-superscript">x/7</sup> 和一个 <sup class="fm-superscript">x/31</sup> 看看它们是否是 I。如果一个 <sup class="fm-superscript">x/7</sup> 是 I，你接着试试一个 <sup class="fm-superscript">x/49</sup> 。在这种情况下，最高乘法阶数可能是 2 <sup class="fm-superscript">6</sup> 7×13×31。

你接下来处理 3×3 矩阵。如果除了 2、3、7、13 和 31 之外，没有其他素数因子出现在 2×2 矩阵的乘法阶中，那么好的起始指数可能是 x = 2<sup class="fm-superscript">8</sup>7<sup class="fm-superscript">2</sup>13<sup class="fm-superscript">2</sup>31<sup class="fm-superscript">2</sup>。枚举 B = A <sup class="fm-superscript">x</sup> 的连续幂，并重复缩小指数的过程。随着矩阵变得越来越大，乘法阶数可能会增加一个很大的因子，以至于无法通过枚举来找到。在这种情况下，你需要猜测将要出现的新的质因数。

注意乘法顺序中出现的模式。这需要一些侦查工作。例如，假设出现 2 个 <sup class="fm-superscript">3 个</sup> -1，2 个 <sup class="fm-superscript">6 个</sup> -1，2 个 <sup class="fm-superscript">9 个</sup> -1 和 2 个 <sup class="fm-superscript">12 个</sup> -1。你不会直接看到这些，因为它们并不都是质数。2 <sup class="fm-superscript">6</sup> -1 = 63 = 3 <sup class="fm-superscript">2</sup> 7，2 <sup class="fm-superscript">9</sup> -1 = 511 = 7×73 和 2<sup class="fm-superscript">12</sup>-1 = 4095 = 3<sup class="fm-superscript">2</sup>5×7×13。因此，在质因数中找到 13 是“真实”因数可能是 2 <sup class="fm-superscript">12</sup> -1 的线索，而找到 73 是 2 <sup class="fm-superscript">9</sup> -1 是因数的强烈指示。如果你看到 2 <sup class="fm-superscript">3</sup> -1，2 <sup class="fm-superscript">6</sup> -1，2 <sup class="fm-superscript">9</sup> -1，2 <sup class="fm-superscript">12</sup> -1 都出现了，你应该期待 2 <sup class="fm-superscript">15</sup> -1 很快出现。如果这些都出现的话，它们每一个都是可以被 7 整除的，那么乘法的顺序就会被 7<sup class="fm-superscript">4</sup>T37】整除 T34】。

### 16.4.3 最大订单

桑德拉的 目标是让这个家庭**ғ**尽可能的大，这样她和里瓦就可以对矩阵 s 和 r 有更多的选择。一个有用的技巧是观察因子集差异的乘法顺序。例如，如果 A 的乘法阶数是 19m，B 的乘法阶数是 23m，那么 AB 的乘法阶数可能正好是 19×23m = 437m。如果这不起作用，那么 A'B 或 AB '可能有乘法阶 437m。

如果可能的话，桑德拉应该选择一个生成矩阵 F，它的乘法阶有一个大的质因数，比如说 m > 10 <sup class="fm-superscript">35</sup> ，以防止 Silver-Pohlig-Hellman 攻击(第 14.4 节)。桑德拉将需要对不同的 n 进行 2 <sup class="fm-superscript">n</sup> -1 的因式分解，以找到具有大质因数的 n，然后通过尝试连续更大的 矩阵，找到其乘法阶数可被 2 <sup class="fm-superscript">n</sup> -1 之一整除的生成矩阵。

### 艾米莉袭击事件

假设桑德拉选择了 f 和**ғ**，并且她已经给里瓦发了一条消息。由于桑德拉和里瓦通过公共信道(例如互联网)进行通信，假设艾米丽知道 f、**、SM、RSM 和 RM。她的目标是找到 R 或 S，所以她有两次机会。让我们集中讨论艾米丽可能如何找到 r。艾米丽知道关于 r 的两件事。首先，她知道 SM 和 RSM 的值，所以这给了她在 r 的 n 个 <sup class="fm-superscript">2 个</sup>未知元素中的一组 n 个线性方程。第二，她知道 r 在家族**中，所以它必须与 f 交换，即 RF = FR。如果环 ***R*** 是可换的，那么这就给了她 R 的 n <sup class="fm-superscript">2</sup> 个元素中的 n(n-1)个额外的线性方程组****

 ****这是因为矩阵方程 RF = FR 的左边产生 RF 形式的项的和，其中 R 是 R 的未知元素，f 是 f 的已知元素。右边产生 FR 形式的项。由于环是可换的，左边的 rf 项可以转换成 fr 形式，并与右边的 RF 项组合起来形成线性方程。

有 n 个未知数 n 个线性方程 2 个 T2，n 个未知数 T3 个线性方程 2 个 T4，要解这些线性方程并找到 r 似乎是件轻而易举的事，并不那么容易。回想一下 15.3.1 节，有强同余和弱同余。这同样适用于任何大小不是素数的有限环上的线性方程。环的素数因子越多，弱方程的潜力就越大。在目前的情况下，环的大小是 2 <sup class="fm-superscript">8</sup> ，有 8 个质因数，所以许多线性方程很可能是弱的。如果环 ***R*** 选择得当，矩阵的典型大小可能是 30×30，或者 128×128，或者甚至 256×256，如果环选择不当。即使有一个精心选择的环，即使有一半的方程是强的，你也会期望对 30×30 = 900 的方程组有至少 2 个 <sup class="fm-superscript">450</sup> 解。实际上，解的数量要大得多，因为可能有 4 个、8 个或可能 16 个解的方程。

艾米丽有个好消息。艾米丽可以求解 R '而不是 R，她得到的 2 个 <sup class="fm-superscript">450</sup> 或更多解中的任何一个都将是 R 的有效逆，让她通过 R'RM = M 获得消息

### 16.4.5 非交换环

看来珊卓拉和丽娃沉没了。艾米丽赢得了这场战斗。

对这种攻击的一个可能的回答是桑德拉和丽娃使用一个非交换环。非交换环的两个例子是矩阵和四元数(15.7.2 节)。你可以形成矩阵，它的元素本身是矩阵或四元数，或者相反，四元数的系数是矩阵或四元数。这些都不是好的选择。你需要把它们做得非常大，以产生高乘法阶数的矩阵。

更好的方法是使用第 15.7 节的技术构建自己的环***【N】***。你应该选择一个有许多元素的环，这些元素(1)是可逆的，(2)具有高的乘法阶数，以及(3)是非交换的。找到一枚具备所有这些特征的戒指是一个微妙的平衡。例如，具有最大乘法阶数的元素的环(对于 256 元素的环是 255)不能有任何非交换元素。如果你能找到一个环，其中一半的元素是可逆的，一半的乘法阶数等于环大小的一半，一半是不可交换的， *dayenu* (这就足够了)。你不可能同时实现这三个目标，但是你可以超越其中一些，同时接近其他的。

对于非交换环，矩阵方程 rf = fr 不能再线性化，因为不再确定 RF = FR。相反，矩阵方程导致一组*双线性* 方程。双线性方程中的一般项采用 axb 的形式，其中 a 和 b 是环的元素，x 是要确定其值的变量。虽然线性方程可以使用简单的系统方法求解，即高斯消去法，但双线性方程没有这样的方法。连解 ax+xb = c 这种简单的单变量 x 的方程都没有通用的方法，所以解环上的双线性方程是 “不可能的。”

### 16.4.6 求解双线性方程

那个 说，我现在给你演示如何解双线性方程。诀窍是改变环中元素的表示 ***N*** 。我们已经看到了几个如何做到这一点的例子。在环 ***R13*** 中，元素表示为*a*+*b*√13。高斯整数表示为 a+bi。四元数表示为 a+bi+cj+dk。这里，I，j 和 k 是抽象单位，它们的乘积决定了环的行为，a，b，c 和 d 是环的交换元素。四元数可以不可交换是因为单位的乘法运算不可交换，即 ij≦Ji，ik≦ki 和 JK≦kj。只有一个单位，高斯整数必然是可换的。

诀窍是*通过寻找非交换环 ***N*** 的一个表示来线性化*双线性方程。这很容易做到。首先将 ***N*** 的元素分成 A 和 B 两组，其中 A 包含有表示的元素，B 包含剩余的元素。最初 A 是空的，B 包含环的所有元素。首先取交换元素并把它们移入集合 a。这些环元素将表示它们自己。它们是表示中的“a”项。选择任意剩余的可逆元素作为单元 I .取所有可以表示为 a+bi 的环元素，其中 A 和 B 是环的可交换元素，将它们从集合 B 移到集合 A .到目前为止，A 的所有元素仍然是可交换的.

集合 B 不能为空，因为 ***N*** 不可交换。我们已经注意到只有一个单位的环，像高斯整数，一定是可换的。因此，从集合 B 中取出第二个可逆元素，并将其称为第二个单元 j。这一次，您取出可以表示为 a+bi+cj 的所有元素，并将它们从集合 B 移动到集合 a。集合 B 中可能仍有环形元素。在这种情况下，您将重复这些步骤，但为简单起见，我们假设(1)只需要两个单元；(2)环中的所有元素都可以表示为 a+bi+cj，其中 I 和 j 是抽象单位；以及(3) a，b，c 是环 ***N*** 的交换元。在实践中，您得到的单位数可能取决于您对 I 和 j 的选择，因此您应该进行多次试验以得到最少的单位。这很重要，因为更多的单位意味着线性化时会有更多的方程。由于求解一组线性方程所需的时间与方程数量的立方成正比，因此影响很大。

我们回到矩阵方程 RF = FR，把环元素放成 a+bi+cj 的形式。 ***R*** 的未知元素将具有 x+yi+zj 的形式，其中 x、y 和 z 是未知的交换环元素。现在矩阵乘积 RF 的一项将具有以下形式

![16-unnumb-1-equation-16-2](img/16-unnumb-1-equation-16-2.png)

其中 i <sup class="fm-superscript">2</sup> ，j <sup class="fm-superscript">2</sup> ，ij 和 ji 将进一步展开为 1，I 和 j 的线性组合，如 d+ei+fj。当然，实际的扩展将取决于环的选择以及哪些元素被选作 I 和 j。

矩阵产品 FR 中的术语也必须如此。最后，你得到的不是 900 个方程中的 900 个未知数，而是 2700 个方程中的 2700 个未知数。这使得错误答案的数量从 2 个 <sup class="fm-superscript">450 个</sup>增加到 2 个 <sup class="fm-superscript">1350 个</sup>。这对艾米丽来说是个坏消息。假解不允许她恢复 消息。

### 16.4.7 弱者

家族**ғ**会包括一些弱项，比如对角矩阵和三角矩阵，艾米莉很容易就能求逆。这些弱者不应该被用作钥匙。从**ғ**中选择矩阵时，验证主对角线的上方和下方至少有一个非零元素。为了快速测试，只需验证 X <sub class="fm-subscript">12</sub> ，X <sub class="fm-subscript">13</sub> 和 X <sub class="fm-subscript">23</sub> 中至少有一个非零，X <sub class="fm-subscript">21</sub> ，X <sub class="fm-subscript">31</sub> 和 X <sub class="fm-subscript">32</sub> 中至少有一个非零。否则拒绝 X，重新选择。被拒绝的矩阵百分比 可以忽略不计。

### 16.4.8 快速制作

用矩阵代替幂运算的优势可能还不清楚。从家族**ғ**中选择矩阵 s 或 r 需要取生成矩阵 F 的大幂。这比取大整数的大幂有什么更好或更快的吗？区别在于准备。在沙米尔和梅西-奥姆拉方法中，桑德拉和丽娃必须取各自从对方那里得到的数字，并对其进行大幂运算。因为他们事先不知道那个数，所以他们不能做任何准备来加速幂运算。

然而，利用矩阵方法，生成矩阵 F 是预先已知的。桑德拉和丽娃都可以预先生成一些 F 的幂，然后将这个矩阵幂的基础集合保留在手边，这样他们就可以通过 1 或 2 次矩阵乘法来生成一个新的 F 的幂。首先，他们可以生成一组 16 个矩阵 F，F <sup class="fm-superscript">2</sup> ，F <sup class="fm-superscript">4</sup> ，F <sup class="fm-superscript">8</sup> ，...，F <sup class="fm-superscript">32768</sup> 仅使用 15 次矩阵乘法。

如果他们只做那么多，艾米丽也会做的。她将拥有与桑德拉和丽娃相同的矩阵基集，因此她可以轻松确定她们的加密矩阵 S 和 r。为了防止这种情况，桑德拉和丽娃需要随机化她们的矩阵集。他们通过随机选择两个矩阵并将它们相乘来实现。这个产品将取代基础组中的两个矩阵之一。桑德拉和丽娃独立完成这项工作。谁也不知道另一方选择了 F 的哪个幂。

这种替换操作应该在设置期间重复很多次，比如说 1000 次，以使每一方的矩阵集是完全随机的。如果 1000 看起来太多，请记住，在使用 300 位素数的 Shamir 方法中，每次取幂将需要大约 1000 次乘法和 1000 次模约简。桑德拉和丽娃也需要保持他们矩阵的逆矩阵。每次他们乘以 F 的两个幂，他们需要乘以 F '的相应幂，这样他们就不需要求任何幂的倒数。

在发送第一条消息之前，只需执行一次设置步骤，即生成基本集。当你有了这组扩展的生成矩阵，你就可以用一次矩阵乘法和一次矩阵求逆来生成一个发送消息的矩阵。你从你的基集中随机选择两个不同的矩阵 F <sup class="fm-superscript">a</sup> 和 F <sup class="fm-superscript">b</sup> ，相乘得到 F <sup class="fm-superscript">a+b</sup> ，然后用 F <sup class="fm-superscript">a+b</sup> 代替 F <sup class="fm-superscript">a</sup> 这样你每次都会生成不同的矩阵。

使用这种技术，我发现对于 30×30 矩阵和 1024 位模数，矩阵方法的速度是沙米尔或梅西-奥姆拉 求幂 方法的 2100 倍。

## 16.5 双面三通道协议

前面矩阵方法中的 矩阵乘法可以在左侧或右侧进行，这意味着信息可以被加密为 SM 或 MS，也可以在两侧进行乘法。在这种情况下，消息被拆分成 n 个 <sup xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" class="fm-superscript">2 个</sup>字符的块，并且有两个独立的 n×n 矩阵族，T9】ғ和**ɠ**，生成矩阵 f 和 g。桑德拉将使用来自**ғ**的矩阵 s 和来自**ɠ**的矩阵 t 对消息进行加密，而里瓦将使用

桑德拉给丽娃发了一条加密短信。丽娃超级解密并发回 RSMTQ。桑德拉通过使用逆矩阵 S '和 T '删除她的加密，将 S'RSMTQT' = RMQ 发送回丽娃，后者使用她的逆矩阵 R '和 Q '，将其解密为 R'RMQQ' = M。由于其块大小较大，双面方法对于短消息不实用，但对于长消息，它比单面方法快得多，因为在每个块中得到 n 个 <sup class="fm-superscript">2 个</sup>字符，而不是 n 个字符。对于 30×30 矩阵，它的速度是单侧方法的 15 倍，因此是 Shamir 或 Massey-Omura 方法的 30，000 倍。

艾米莉必须同时求解两个矩阵。设艾米丽截取的 3 个矩阵称为 X，Y，Z，即 X = SMT，Y = RSMTQ，Z = RMQ。艾米莉知道 Y = RXQ，Z = S'YT '。看起来艾米莉将需要求解非交换环 ***N*** 上的一大组二次方程，这比求解线性或双线性方程要困难得多。但是，如果这些方程分别乘以 R’，Q’，S 和 T，就变成 R’y = XQ，YQ’= RX，SZ = YT’，ZT = S’y。这些矩阵方程相乘得到双线性方程。我们在 16.4.6 节看到了如何求解双线性方程。

如果艾米丽能同时找到 R '和 Q '，或者她能同时找到 S '和 T '，她就能恢复 M。她可以选择解这四个方程的前两个或后两个。让我们继续 30×30 矩阵的例子，集中精力求解 R'Y = XQ。R '中有 900 个未知数，q 中还有 900 个未知数，这个矩阵方程在这 1800 个未知数中提供了 900 个双线性方程。艾米莉也知道 r '在**中，q 在**中，所以 R'F = FR '和 QG = GQ。其中每一个都会产生额外的 30×29 = 870 个双线性方程。这给了艾米丽总共 2640 个双线性方程的 1800 个未知数。这些方程可以通过改变环元素的表示来线性化。****

 ****这导致了 5400 个未知数的 7920 个线性方程。当方程比未知数多时，这个系统被称为*超定* 。当 Emily 简化方程组时，多余的方程就消失了。也就是说，7920×5400 矩阵的许多行变成全零。它们可以被移到矩阵的底部并被忽略。最后，出现了与单方面情况相同的困难，即有多种解决方案。由于双侧方程是超定的，它们比单侧方程更强。另一方面，有两倍多的未知数。目前还不清楚哪种方法最终更强。你可能会简单地选择双面方法，因为它要快得多。 ****************