import { S as SvelteComponent, i as init, s as safe_not_equal, e as element, U as set_attributes, d as toggle_class, f as insert, u as update_slot_base, q as get_all_dirty_from_scope, r as get_slot_changes, R as get_spread_update, j as transition_in, k as transition_out, n as detach, A as empty, V as getContext, p as create_slot, P as assign } from './index.8bf4b92e.js';
import { g as get_styles } from './styles.c72835fa.js';

/* home/runner/work/gradio/gradio/ui/packages/atoms/src/Block.svelte generated by Svelte v3.49.0 */

function create_dynamic_element(ctx) {
	let svelte_element;
	let svelte_element_class_value;
	let svelte_element_style_value;
	let current;
	const default_slot_template = /*#slots*/ ctx[17].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[16], null);

	let svelte_element_levels = [
		{ "data-testid": /*test_id*/ ctx[4] },
		{ id: /*elem_id*/ ctx[0] },
		{
			class: svelte_element_class_value = "gr-block gr-box relative w-full overflow-hidden " + /*styles*/ ctx[10][/*variant*/ ctx[1]] + " " + (/*rounded*/ ctx[6]
			? /*styles*/ ctx[10][/*color*/ ctx[2]]
			: '') + " " + /*classes*/ ctx[9] + " " + /*rounded_style*/ ctx[8]
		},
		{
			style: svelte_element_style_value = /*size_style*/ ctx[7] || null
		}
	];

	let svelte_element_data = {};

	for (let i = 0; i < svelte_element_levels.length; i += 1) {
		svelte_element_data = assign(svelte_element_data, svelte_element_levels[i]);
	}

	return {
		c() {
			svelte_element = element(/*tag*/ ctx[11]);
			if (default_slot) default_slot.c();
			set_attributes(svelte_element, svelte_element_data);
			toggle_class(svelte_element, "!hidden", /*visible*/ ctx[5] === false);
			toggle_class(svelte_element, "gr-panel", /*padding*/ ctx[3]);
		},
		m(target, anchor) {
			insert(target, svelte_element, anchor);

			if (default_slot) {
				default_slot.m(svelte_element, null);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 65536)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[16],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[16])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[16], dirty, null),
						null
					);
				}
			}

			set_attributes(svelte_element, svelte_element_data = get_spread_update(svelte_element_levels, [
				(!current || dirty & /*test_id*/ 16) && { "data-testid": /*test_id*/ ctx[4] },
				(!current || dirty & /*elem_id*/ 1) && { id: /*elem_id*/ ctx[0] },
				(!current || dirty & /*variant, rounded, color, classes, rounded_style*/ 838 && svelte_element_class_value !== (svelte_element_class_value = "gr-block gr-box relative w-full overflow-hidden " + /*styles*/ ctx[10][/*variant*/ ctx[1]] + " " + (/*rounded*/ ctx[6]
				? /*styles*/ ctx[10][/*color*/ ctx[2]]
				: '') + " " + /*classes*/ ctx[9] + " " + /*rounded_style*/ ctx[8])) && { class: svelte_element_class_value },
				(!current || dirty & /*size_style*/ 128 && svelte_element_style_value !== (svelte_element_style_value = /*size_style*/ ctx[7] || null)) && { style: svelte_element_style_value }
			]));

			toggle_class(svelte_element, "!hidden", /*visible*/ ctx[5] === false);
			toggle_class(svelte_element, "gr-panel", /*padding*/ ctx[3]);
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(svelte_element);
			if (default_slot) default_slot.d(detaching);
		}
	};
}

function create_fragment(ctx) {
	let previous_tag = /*tag*/ ctx[11];
	let svelte_element_anchor;
	let current;
	let svelte_element = /*tag*/ ctx[11] && create_dynamic_element(ctx);

	return {
		c() {
			if (svelte_element) svelte_element.c();
			svelte_element_anchor = empty();
		},
		m(target, anchor) {
			if (svelte_element) svelte_element.m(target, anchor);
			insert(target, svelte_element_anchor, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			if (/*tag*/ ctx[11]) {
				if (!previous_tag) {
					svelte_element = create_dynamic_element(ctx);
					svelte_element.c();
					svelte_element.m(svelte_element_anchor.parentNode, svelte_element_anchor);
				} else if (safe_not_equal(previous_tag, /*tag*/ ctx[11])) {
					svelte_element.d(1);
					svelte_element = create_dynamic_element(ctx);
					svelte_element.c();
					svelte_element.m(svelte_element_anchor.parentNode, svelte_element_anchor);
				} else {
					svelte_element.p(ctx, dirty);
				}
			} else if (previous_tag) {
				svelte_element.d(1);
				svelte_element = null;
			}

			previous_tag = /*tag*/ ctx[11];
		},
		i(local) {
			if (current) return;
			transition_in(svelte_element);
			current = true;
		},
		o(local) {
			transition_out(svelte_element);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(svelte_element_anchor);
			if (svelte_element) svelte_element.d(detaching);
		}
	};
}

function instance($$self, $$props, $$invalidate) {
	let classes;
	let rounded;
	let rounded_style;
	let size_style;
	let { $$slots: slots = {}, $$scope } = $$props;
	let { style = {} } = $$props;
	let { elem_id = "" } = $$props;
	let { variant = "solid" } = $$props;
	let { color = "grey" } = $$props;
	let { padding = true } = $$props;
	let { type = "normal" } = $$props;
	let { test_id = undefined } = $$props;
	let { disable = false } = $$props;
	let { explicit_call = false } = $$props;
	let { visible = true } = $$props;

	const styles = {
		dashed: "border-dashed border border-gray-300",
		solid: "border-solid border",
		grey: "border-gray-200",
		green: "border-green-400",
		none: "!border-0"
	};

	let tag = type === "fieldset" ? "fieldset" : "div";
	getContext("BLOCK_KEY");

	$$self.$$set = $$props => {
		if ('style' in $$props) $$invalidate(12, style = $$props.style);
		if ('elem_id' in $$props) $$invalidate(0, elem_id = $$props.elem_id);
		if ('variant' in $$props) $$invalidate(1, variant = $$props.variant);
		if ('color' in $$props) $$invalidate(2, color = $$props.color);
		if ('padding' in $$props) $$invalidate(3, padding = $$props.padding);
		if ('type' in $$props) $$invalidate(13, type = $$props.type);
		if ('test_id' in $$props) $$invalidate(4, test_id = $$props.test_id);
		if ('disable' in $$props) $$invalidate(14, disable = $$props.disable);
		if ('explicit_call' in $$props) $$invalidate(15, explicit_call = $$props.explicit_call);
		if ('visible' in $$props) $$invalidate(5, visible = $$props.visible);
		if ('$$scope' in $$props) $$invalidate(16, $$scope = $$props.$$scope);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*explicit_call, style, disable*/ 53248) {
			$$invalidate(
				9,
				{ classes } = explicit_call
				? get_styles(style, ["rounded", "border"])
				: disable
					? get_styles({ container: false }, ["container"])
					: { classes: "" },
				classes
			);
		}

		if ($$self.$$.dirty & /*style*/ 4096) {
			$$invalidate(6, rounded = typeof style.rounded !== "boolean" || typeof style.rounded === "boolean" && style.rounded);
		}

		if ($$self.$$.dirty & /*style, rounded*/ 4160) {
			$$invalidate(8, rounded_style = typeof style.rounded === "boolean"
			? get_styles({ rounded }, ["rounded"]).classes
			: "");
		}

		if ($$self.$$.dirty & /*style*/ 4096) {
			$$invalidate(7, size_style = "" + (typeof style.height === "number"
			? `height: ${style.height}px; `
			: "") + (typeof style.width === "number"
			? `width: ${style.width}px;`
			: ""));
		}
	};

	return [
		elem_id,
		variant,
		color,
		padding,
		test_id,
		visible,
		rounded,
		size_style,
		rounded_style,
		classes,
		styles,
		tag,
		style,
		type,
		disable,
		explicit_call,
		$$scope,
		slots
	];
}

class Block extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance, create_fragment, safe_not_equal, {
			style: 12,
			elem_id: 0,
			variant: 1,
			color: 2,
			padding: 3,
			type: 13,
			test_id: 4,
			disable: 14,
			explicit_call: 15,
			visible: 5
		});
	}
}

export { Block as B };
